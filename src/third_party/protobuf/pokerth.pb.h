// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pokerth.proto

#ifndef PROTOBUF_INCLUDED_pokerth_2eproto
#define PROTOBUF_INCLUDED_pokerth_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pokerth_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_pokerth_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[91]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
class AdminBanPlayerAckMessage;
class AdminBanPlayerAckMessageDefaultTypeInternal;
extern AdminBanPlayerAckMessageDefaultTypeInternal _AdminBanPlayerAckMessage_default_instance_;
class AdminBanPlayerMessage;
class AdminBanPlayerMessageDefaultTypeInternal;
extern AdminBanPlayerMessageDefaultTypeInternal _AdminBanPlayerMessage_default_instance_;
class AdminRemoveGameAckMessage;
class AdminRemoveGameAckMessageDefaultTypeInternal;
extern AdminRemoveGameAckMessageDefaultTypeInternal _AdminRemoveGameAckMessage_default_instance_;
class AdminRemoveGameMessage;
class AdminRemoveGameMessageDefaultTypeInternal;
extern AdminRemoveGameMessageDefaultTypeInternal _AdminRemoveGameMessage_default_instance_;
class AfterHandShowCardsMessage;
class AfterHandShowCardsMessageDefaultTypeInternal;
extern AfterHandShowCardsMessageDefaultTypeInternal _AfterHandShowCardsMessage_default_instance_;
class AllInShowCardsMessage;
class AllInShowCardsMessageDefaultTypeInternal;
extern AllInShowCardsMessageDefaultTypeInternal _AllInShowCardsMessage_default_instance_;
class AllInShowCardsMessage_PlayerAllIn;
class AllInShowCardsMessage_PlayerAllInDefaultTypeInternal;
extern AllInShowCardsMessage_PlayerAllInDefaultTypeInternal _AllInShowCardsMessage_PlayerAllIn_default_instance_;
class AnnounceMessage;
class AnnounceMessageDefaultTypeInternal;
extern AnnounceMessageDefaultTypeInternal _AnnounceMessage_default_instance_;
class AnnounceMessage_Version;
class AnnounceMessage_VersionDefaultTypeInternal;
extern AnnounceMessage_VersionDefaultTypeInternal _AnnounceMessage_Version_default_instance_;
class AskKickDeniedMessage;
class AskKickDeniedMessageDefaultTypeInternal;
extern AskKickDeniedMessageDefaultTypeInternal _AskKickDeniedMessage_default_instance_;
class AskKickPlayerMessage;
class AskKickPlayerMessageDefaultTypeInternal;
extern AskKickPlayerMessageDefaultTypeInternal _AskKickPlayerMessage_default_instance_;
class AuthClientResponseMessage;
class AuthClientResponseMessageDefaultTypeInternal;
extern AuthClientResponseMessageDefaultTypeInternal _AuthClientResponseMessage_default_instance_;
class AuthServerChallengeMessage;
class AuthServerChallengeMessageDefaultTypeInternal;
extern AuthServerChallengeMessageDefaultTypeInternal _AuthServerChallengeMessage_default_instance_;
class AuthServerVerificationMessage;
class AuthServerVerificationMessageDefaultTypeInternal;
extern AuthServerVerificationMessageDefaultTypeInternal _AuthServerVerificationMessage_default_instance_;
class AvatarDataMessage;
class AvatarDataMessageDefaultTypeInternal;
extern AvatarDataMessageDefaultTypeInternal _AvatarDataMessage_default_instance_;
class AvatarEndMessage;
class AvatarEndMessageDefaultTypeInternal;
extern AvatarEndMessageDefaultTypeInternal _AvatarEndMessage_default_instance_;
class AvatarHeaderMessage;
class AvatarHeaderMessageDefaultTypeInternal;
extern AvatarHeaderMessageDefaultTypeInternal _AvatarHeaderMessage_default_instance_;
class AvatarRequestMessage;
class AvatarRequestMessageDefaultTypeInternal;
extern AvatarRequestMessageDefaultTypeInternal _AvatarRequestMessage_default_instance_;
class ChatMessage;
class ChatMessageDefaultTypeInternal;
extern ChatMessageDefaultTypeInternal _ChatMessage_default_instance_;
class ChatRejectMessage;
class ChatRejectMessageDefaultTypeInternal;
extern ChatRejectMessageDefaultTypeInternal _ChatRejectMessage_default_instance_;
class ChatRequestMessage;
class ChatRequestMessageDefaultTypeInternal;
extern ChatRequestMessageDefaultTypeInternal _ChatRequestMessage_default_instance_;
class DealFlopCardsMessage;
class DealFlopCardsMessageDefaultTypeInternal;
extern DealFlopCardsMessageDefaultTypeInternal _DealFlopCardsMessage_default_instance_;
class DealRiverCardMessage;
class DealRiverCardMessageDefaultTypeInternal;
extern DealRiverCardMessageDefaultTypeInternal _DealRiverCardMessage_default_instance_;
class DealTurnCardMessage;
class DealTurnCardMessageDefaultTypeInternal;
extern DealTurnCardMessageDefaultTypeInternal _DealTurnCardMessage_default_instance_;
class DialogMessage;
class DialogMessageDefaultTypeInternal;
extern DialogMessageDefaultTypeInternal _DialogMessage_default_instance_;
class EndKickPetitionMessage;
class EndKickPetitionMessageDefaultTypeInternal;
extern EndKickPetitionMessageDefaultTypeInternal _EndKickPetitionMessage_default_instance_;
class EndOfGameMessage;
class EndOfGameMessageDefaultTypeInternal;
extern EndOfGameMessageDefaultTypeInternal _EndOfGameMessage_default_instance_;
class EndOfHandHideCardsMessage;
class EndOfHandHideCardsMessageDefaultTypeInternal;
extern EndOfHandHideCardsMessageDefaultTypeInternal _EndOfHandHideCardsMessage_default_instance_;
class EndOfHandShowCardsMessage;
class EndOfHandShowCardsMessageDefaultTypeInternal;
extern EndOfHandShowCardsMessageDefaultTypeInternal _EndOfHandShowCardsMessage_default_instance_;
class ErrorMessage;
class ErrorMessageDefaultTypeInternal;
extern ErrorMessageDefaultTypeInternal _ErrorMessage_default_instance_;
class GameAdminChangedMessage;
class GameAdminChangedMessageDefaultTypeInternal;
extern GameAdminChangedMessageDefaultTypeInternal _GameAdminChangedMessage_default_instance_;
class GameListAdminChangedMessage;
class GameListAdminChangedMessageDefaultTypeInternal;
extern GameListAdminChangedMessageDefaultTypeInternal _GameListAdminChangedMessage_default_instance_;
class GameListNewMessage;
class GameListNewMessageDefaultTypeInternal;
extern GameListNewMessageDefaultTypeInternal _GameListNewMessage_default_instance_;
class GameListPlayerJoinedMessage;
class GameListPlayerJoinedMessageDefaultTypeInternal;
extern GameListPlayerJoinedMessageDefaultTypeInternal _GameListPlayerJoinedMessage_default_instance_;
class GameListPlayerLeftMessage;
class GameListPlayerLeftMessageDefaultTypeInternal;
extern GameListPlayerLeftMessageDefaultTypeInternal _GameListPlayerLeftMessage_default_instance_;
class GameListSpectatorJoinedMessage;
class GameListSpectatorJoinedMessageDefaultTypeInternal;
extern GameListSpectatorJoinedMessageDefaultTypeInternal _GameListSpectatorJoinedMessage_default_instance_;
class GameListSpectatorLeftMessage;
class GameListSpectatorLeftMessageDefaultTypeInternal;
extern GameListSpectatorLeftMessageDefaultTypeInternal _GameListSpectatorLeftMessage_default_instance_;
class GameListUpdateMessage;
class GameListUpdateMessageDefaultTypeInternal;
extern GameListUpdateMessageDefaultTypeInternal _GameListUpdateMessage_default_instance_;
class GamePlayerJoinedMessage;
class GamePlayerJoinedMessageDefaultTypeInternal;
extern GamePlayerJoinedMessageDefaultTypeInternal _GamePlayerJoinedMessage_default_instance_;
class GamePlayerLeftMessage;
class GamePlayerLeftMessageDefaultTypeInternal;
extern GamePlayerLeftMessageDefaultTypeInternal _GamePlayerLeftMessage_default_instance_;
class GameSpectatorJoinedMessage;
class GameSpectatorJoinedMessageDefaultTypeInternal;
extern GameSpectatorJoinedMessageDefaultTypeInternal _GameSpectatorJoinedMessage_default_instance_;
class GameSpectatorLeftMessage;
class GameSpectatorLeftMessageDefaultTypeInternal;
extern GameSpectatorLeftMessageDefaultTypeInternal _GameSpectatorLeftMessage_default_instance_;
class GameStartInitialMessage;
class GameStartInitialMessageDefaultTypeInternal;
extern GameStartInitialMessageDefaultTypeInternal _GameStartInitialMessage_default_instance_;
class GameStartRejoinMessage;
class GameStartRejoinMessageDefaultTypeInternal;
extern GameStartRejoinMessageDefaultTypeInternal _GameStartRejoinMessage_default_instance_;
class GameStartRejoinMessage_RejoinPlayerData;
class GameStartRejoinMessage_RejoinPlayerDataDefaultTypeInternal;
extern GameStartRejoinMessage_RejoinPlayerDataDefaultTypeInternal _GameStartRejoinMessage_RejoinPlayerData_default_instance_;
class HandStartMessage;
class HandStartMessageDefaultTypeInternal;
extern HandStartMessageDefaultTypeInternal _HandStartMessage_default_instance_;
class HandStartMessage_PlainCards;
class HandStartMessage_PlainCardsDefaultTypeInternal;
extern HandStartMessage_PlainCardsDefaultTypeInternal _HandStartMessage_PlainCards_default_instance_;
class InitAckMessage;
class InitAckMessageDefaultTypeInternal;
extern InitAckMessageDefaultTypeInternal _InitAckMessage_default_instance_;
class InitMessage;
class InitMessageDefaultTypeInternal;
extern InitMessageDefaultTypeInternal _InitMessage_default_instance_;
class InviteNotifyMessage;
class InviteNotifyMessageDefaultTypeInternal;
extern InviteNotifyMessageDefaultTypeInternal _InviteNotifyMessage_default_instance_;
class InvitePlayerToGameMessage;
class InvitePlayerToGameMessageDefaultTypeInternal;
extern InvitePlayerToGameMessageDefaultTypeInternal _InvitePlayerToGameMessage_default_instance_;
class JoinExistingGameMessage;
class JoinExistingGameMessageDefaultTypeInternal;
extern JoinExistingGameMessageDefaultTypeInternal _JoinExistingGameMessage_default_instance_;
class JoinGameAckMessage;
class JoinGameAckMessageDefaultTypeInternal;
extern JoinGameAckMessageDefaultTypeInternal _JoinGameAckMessage_default_instance_;
class JoinGameFailedMessage;
class JoinGameFailedMessageDefaultTypeInternal;
extern JoinGameFailedMessageDefaultTypeInternal _JoinGameFailedMessage_default_instance_;
class JoinNewGameMessage;
class JoinNewGameMessageDefaultTypeInternal;
extern JoinNewGameMessageDefaultTypeInternal _JoinNewGameMessage_default_instance_;
class KickPetitionUpdateMessage;
class KickPetitionUpdateMessageDefaultTypeInternal;
extern KickPetitionUpdateMessageDefaultTypeInternal _KickPetitionUpdateMessage_default_instance_;
class KickPlayerRequestMessage;
class KickPlayerRequestMessageDefaultTypeInternal;
extern KickPlayerRequestMessageDefaultTypeInternal _KickPlayerRequestMessage_default_instance_;
class LeaveGameRequestMessage;
class LeaveGameRequestMessageDefaultTypeInternal;
extern LeaveGameRequestMessageDefaultTypeInternal _LeaveGameRequestMessage_default_instance_;
class MyActionRequestMessage;
class MyActionRequestMessageDefaultTypeInternal;
extern MyActionRequestMessageDefaultTypeInternal _MyActionRequestMessage_default_instance_;
class NetGameInfo;
class NetGameInfoDefaultTypeInternal;
extern NetGameInfoDefaultTypeInternal _NetGameInfo_default_instance_;
class PlayerIdChangedMessage;
class PlayerIdChangedMessageDefaultTypeInternal;
extern PlayerIdChangedMessageDefaultTypeInternal _PlayerIdChangedMessage_default_instance_;
class PlayerInfoReplyMessage;
class PlayerInfoReplyMessageDefaultTypeInternal;
extern PlayerInfoReplyMessageDefaultTypeInternal _PlayerInfoReplyMessage_default_instance_;
class PlayerInfoReplyMessage_PlayerInfoData;
class PlayerInfoReplyMessage_PlayerInfoDataDefaultTypeInternal;
extern PlayerInfoReplyMessage_PlayerInfoDataDefaultTypeInternal _PlayerInfoReplyMessage_PlayerInfoData_default_instance_;
class PlayerInfoReplyMessage_PlayerInfoData_AvatarData;
class PlayerInfoReplyMessage_PlayerInfoData_AvatarDataDefaultTypeInternal;
extern PlayerInfoReplyMessage_PlayerInfoData_AvatarDataDefaultTypeInternal _PlayerInfoReplyMessage_PlayerInfoData_AvatarData_default_instance_;
class PlayerInfoRequestMessage;
class PlayerInfoRequestMessageDefaultTypeInternal;
extern PlayerInfoRequestMessageDefaultTypeInternal _PlayerInfoRequestMessage_default_instance_;
class PlayerListMessage;
class PlayerListMessageDefaultTypeInternal;
extern PlayerListMessageDefaultTypeInternal _PlayerListMessage_default_instance_;
class PlayerResult;
class PlayerResultDefaultTypeInternal;
extern PlayerResultDefaultTypeInternal _PlayerResult_default_instance_;
class PlayersActionDoneMessage;
class PlayersActionDoneMessageDefaultTypeInternal;
extern PlayersActionDoneMessageDefaultTypeInternal _PlayersActionDoneMessage_default_instance_;
class PlayersTurnMessage;
class PlayersTurnMessageDefaultTypeInternal;
extern PlayersTurnMessageDefaultTypeInternal _PlayersTurnMessage_default_instance_;
class PokerTHMessage;
class PokerTHMessageDefaultTypeInternal;
extern PokerTHMessageDefaultTypeInternal _PokerTHMessage_default_instance_;
class RejectGameInvitationMessage;
class RejectGameInvitationMessageDefaultTypeInternal;
extern RejectGameInvitationMessageDefaultTypeInternal _RejectGameInvitationMessage_default_instance_;
class RejectInvNotifyMessage;
class RejectInvNotifyMessageDefaultTypeInternal;
extern RejectInvNotifyMessageDefaultTypeInternal _RejectInvNotifyMessage_default_instance_;
class RejoinExistingGameMessage;
class RejoinExistingGameMessageDefaultTypeInternal;
extern RejoinExistingGameMessageDefaultTypeInternal _RejoinExistingGameMessage_default_instance_;
class RemovedFromGameMessage;
class RemovedFromGameMessageDefaultTypeInternal;
extern RemovedFromGameMessageDefaultTypeInternal _RemovedFromGameMessage_default_instance_;
class ReportAvatarAckMessage;
class ReportAvatarAckMessageDefaultTypeInternal;
extern ReportAvatarAckMessageDefaultTypeInternal _ReportAvatarAckMessage_default_instance_;
class ReportAvatarMessage;
class ReportAvatarMessageDefaultTypeInternal;
extern ReportAvatarMessageDefaultTypeInternal _ReportAvatarMessage_default_instance_;
class ReportGameAckMessage;
class ReportGameAckMessageDefaultTypeInternal;
extern ReportGameAckMessageDefaultTypeInternal _ReportGameAckMessage_default_instance_;
class ReportGameMessage;
class ReportGameMessageDefaultTypeInternal;
extern ReportGameMessageDefaultTypeInternal _ReportGameMessage_default_instance_;
class ResetTimeoutMessage;
class ResetTimeoutMessageDefaultTypeInternal;
extern ResetTimeoutMessageDefaultTypeInternal _ResetTimeoutMessage_default_instance_;
class ShowMyCardsRequestMessage;
class ShowMyCardsRequestMessageDefaultTypeInternal;
extern ShowMyCardsRequestMessageDefaultTypeInternal _ShowMyCardsRequestMessage_default_instance_;
class StartEventAckMessage;
class StartEventAckMessageDefaultTypeInternal;
extern StartEventAckMessageDefaultTypeInternal _StartEventAckMessage_default_instance_;
class StartEventMessage;
class StartEventMessageDefaultTypeInternal;
extern StartEventMessageDefaultTypeInternal _StartEventMessage_default_instance_;
class StartKickPetitionMessage;
class StartKickPetitionMessageDefaultTypeInternal;
extern StartKickPetitionMessageDefaultTypeInternal _StartKickPetitionMessage_default_instance_;
class StatisticsMessage;
class StatisticsMessageDefaultTypeInternal;
extern StatisticsMessageDefaultTypeInternal _StatisticsMessage_default_instance_;
class StatisticsMessage_StatisticsData;
class StatisticsMessage_StatisticsDataDefaultTypeInternal;
extern StatisticsMessage_StatisticsDataDefaultTypeInternal _StatisticsMessage_StatisticsData_default_instance_;
class SubscriptionRequestMessage;
class SubscriptionRequestMessageDefaultTypeInternal;
extern SubscriptionRequestMessageDefaultTypeInternal _SubscriptionRequestMessage_default_instance_;
class TimeoutWarningMessage;
class TimeoutWarningMessageDefaultTypeInternal;
extern TimeoutWarningMessageDefaultTypeInternal _TimeoutWarningMessage_default_instance_;
class UnknownAvatarMessage;
class UnknownAvatarMessageDefaultTypeInternal;
extern UnknownAvatarMessageDefaultTypeInternal _UnknownAvatarMessage_default_instance_;
class VoteKickReplyMessage;
class VoteKickReplyMessageDefaultTypeInternal;
extern VoteKickReplyMessageDefaultTypeInternal _VoteKickReplyMessage_default_instance_;
class VoteKickRequestMessage;
class VoteKickRequestMessageDefaultTypeInternal;
extern VoteKickRequestMessageDefaultTypeInternal _VoteKickRequestMessage_default_instance_;
class YourActionRejectedMessage;
class YourActionRejectedMessageDefaultTypeInternal;
extern YourActionRejectedMessageDefaultTypeInternal _YourActionRejectedMessage_default_instance_;
namespace google {
namespace protobuf {
template<> ::AdminBanPlayerAckMessage* Arena::CreateMaybeMessage<::AdminBanPlayerAckMessage>(Arena*);
template<> ::AdminBanPlayerMessage* Arena::CreateMaybeMessage<::AdminBanPlayerMessage>(Arena*);
template<> ::AdminRemoveGameAckMessage* Arena::CreateMaybeMessage<::AdminRemoveGameAckMessage>(Arena*);
template<> ::AdminRemoveGameMessage* Arena::CreateMaybeMessage<::AdminRemoveGameMessage>(Arena*);
template<> ::AfterHandShowCardsMessage* Arena::CreateMaybeMessage<::AfterHandShowCardsMessage>(Arena*);
template<> ::AllInShowCardsMessage* Arena::CreateMaybeMessage<::AllInShowCardsMessage>(Arena*);
template<> ::AllInShowCardsMessage_PlayerAllIn* Arena::CreateMaybeMessage<::AllInShowCardsMessage_PlayerAllIn>(Arena*);
template<> ::AnnounceMessage* Arena::CreateMaybeMessage<::AnnounceMessage>(Arena*);
template<> ::AnnounceMessage_Version* Arena::CreateMaybeMessage<::AnnounceMessage_Version>(Arena*);
template<> ::AskKickDeniedMessage* Arena::CreateMaybeMessage<::AskKickDeniedMessage>(Arena*);
template<> ::AskKickPlayerMessage* Arena::CreateMaybeMessage<::AskKickPlayerMessage>(Arena*);
template<> ::AuthClientResponseMessage* Arena::CreateMaybeMessage<::AuthClientResponseMessage>(Arena*);
template<> ::AuthServerChallengeMessage* Arena::CreateMaybeMessage<::AuthServerChallengeMessage>(Arena*);
template<> ::AuthServerVerificationMessage* Arena::CreateMaybeMessage<::AuthServerVerificationMessage>(Arena*);
template<> ::AvatarDataMessage* Arena::CreateMaybeMessage<::AvatarDataMessage>(Arena*);
template<> ::AvatarEndMessage* Arena::CreateMaybeMessage<::AvatarEndMessage>(Arena*);
template<> ::AvatarHeaderMessage* Arena::CreateMaybeMessage<::AvatarHeaderMessage>(Arena*);
template<> ::AvatarRequestMessage* Arena::CreateMaybeMessage<::AvatarRequestMessage>(Arena*);
template<> ::ChatMessage* Arena::CreateMaybeMessage<::ChatMessage>(Arena*);
template<> ::ChatRejectMessage* Arena::CreateMaybeMessage<::ChatRejectMessage>(Arena*);
template<> ::ChatRequestMessage* Arena::CreateMaybeMessage<::ChatRequestMessage>(Arena*);
template<> ::DealFlopCardsMessage* Arena::CreateMaybeMessage<::DealFlopCardsMessage>(Arena*);
template<> ::DealRiverCardMessage* Arena::CreateMaybeMessage<::DealRiverCardMessage>(Arena*);
template<> ::DealTurnCardMessage* Arena::CreateMaybeMessage<::DealTurnCardMessage>(Arena*);
template<> ::DialogMessage* Arena::CreateMaybeMessage<::DialogMessage>(Arena*);
template<> ::EndKickPetitionMessage* Arena::CreateMaybeMessage<::EndKickPetitionMessage>(Arena*);
template<> ::EndOfGameMessage* Arena::CreateMaybeMessage<::EndOfGameMessage>(Arena*);
template<> ::EndOfHandHideCardsMessage* Arena::CreateMaybeMessage<::EndOfHandHideCardsMessage>(Arena*);
template<> ::EndOfHandShowCardsMessage* Arena::CreateMaybeMessage<::EndOfHandShowCardsMessage>(Arena*);
template<> ::ErrorMessage* Arena::CreateMaybeMessage<::ErrorMessage>(Arena*);
template<> ::GameAdminChangedMessage* Arena::CreateMaybeMessage<::GameAdminChangedMessage>(Arena*);
template<> ::GameListAdminChangedMessage* Arena::CreateMaybeMessage<::GameListAdminChangedMessage>(Arena*);
template<> ::GameListNewMessage* Arena::CreateMaybeMessage<::GameListNewMessage>(Arena*);
template<> ::GameListPlayerJoinedMessage* Arena::CreateMaybeMessage<::GameListPlayerJoinedMessage>(Arena*);
template<> ::GameListPlayerLeftMessage* Arena::CreateMaybeMessage<::GameListPlayerLeftMessage>(Arena*);
template<> ::GameListSpectatorJoinedMessage* Arena::CreateMaybeMessage<::GameListSpectatorJoinedMessage>(Arena*);
template<> ::GameListSpectatorLeftMessage* Arena::CreateMaybeMessage<::GameListSpectatorLeftMessage>(Arena*);
template<> ::GameListUpdateMessage* Arena::CreateMaybeMessage<::GameListUpdateMessage>(Arena*);
template<> ::GamePlayerJoinedMessage* Arena::CreateMaybeMessage<::GamePlayerJoinedMessage>(Arena*);
template<> ::GamePlayerLeftMessage* Arena::CreateMaybeMessage<::GamePlayerLeftMessage>(Arena*);
template<> ::GameSpectatorJoinedMessage* Arena::CreateMaybeMessage<::GameSpectatorJoinedMessage>(Arena*);
template<> ::GameSpectatorLeftMessage* Arena::CreateMaybeMessage<::GameSpectatorLeftMessage>(Arena*);
template<> ::GameStartInitialMessage* Arena::CreateMaybeMessage<::GameStartInitialMessage>(Arena*);
template<> ::GameStartRejoinMessage* Arena::CreateMaybeMessage<::GameStartRejoinMessage>(Arena*);
template<> ::GameStartRejoinMessage_RejoinPlayerData* Arena::CreateMaybeMessage<::GameStartRejoinMessage_RejoinPlayerData>(Arena*);
template<> ::HandStartMessage* Arena::CreateMaybeMessage<::HandStartMessage>(Arena*);
template<> ::HandStartMessage_PlainCards* Arena::CreateMaybeMessage<::HandStartMessage_PlainCards>(Arena*);
template<> ::InitAckMessage* Arena::CreateMaybeMessage<::InitAckMessage>(Arena*);
template<> ::InitMessage* Arena::CreateMaybeMessage<::InitMessage>(Arena*);
template<> ::InviteNotifyMessage* Arena::CreateMaybeMessage<::InviteNotifyMessage>(Arena*);
template<> ::InvitePlayerToGameMessage* Arena::CreateMaybeMessage<::InvitePlayerToGameMessage>(Arena*);
template<> ::JoinExistingGameMessage* Arena::CreateMaybeMessage<::JoinExistingGameMessage>(Arena*);
template<> ::JoinGameAckMessage* Arena::CreateMaybeMessage<::JoinGameAckMessage>(Arena*);
template<> ::JoinGameFailedMessage* Arena::CreateMaybeMessage<::JoinGameFailedMessage>(Arena*);
template<> ::JoinNewGameMessage* Arena::CreateMaybeMessage<::JoinNewGameMessage>(Arena*);
template<> ::KickPetitionUpdateMessage* Arena::CreateMaybeMessage<::KickPetitionUpdateMessage>(Arena*);
template<> ::KickPlayerRequestMessage* Arena::CreateMaybeMessage<::KickPlayerRequestMessage>(Arena*);
template<> ::LeaveGameRequestMessage* Arena::CreateMaybeMessage<::LeaveGameRequestMessage>(Arena*);
template<> ::MyActionRequestMessage* Arena::CreateMaybeMessage<::MyActionRequestMessage>(Arena*);
template<> ::NetGameInfo* Arena::CreateMaybeMessage<::NetGameInfo>(Arena*);
template<> ::PlayerIdChangedMessage* Arena::CreateMaybeMessage<::PlayerIdChangedMessage>(Arena*);
template<> ::PlayerInfoReplyMessage* Arena::CreateMaybeMessage<::PlayerInfoReplyMessage>(Arena*);
template<> ::PlayerInfoReplyMessage_PlayerInfoData* Arena::CreateMaybeMessage<::PlayerInfoReplyMessage_PlayerInfoData>(Arena*);
template<> ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* Arena::CreateMaybeMessage<::PlayerInfoReplyMessage_PlayerInfoData_AvatarData>(Arena*);
template<> ::PlayerInfoRequestMessage* Arena::CreateMaybeMessage<::PlayerInfoRequestMessage>(Arena*);
template<> ::PlayerListMessage* Arena::CreateMaybeMessage<::PlayerListMessage>(Arena*);
template<> ::PlayerResult* Arena::CreateMaybeMessage<::PlayerResult>(Arena*);
template<> ::PlayersActionDoneMessage* Arena::CreateMaybeMessage<::PlayersActionDoneMessage>(Arena*);
template<> ::PlayersTurnMessage* Arena::CreateMaybeMessage<::PlayersTurnMessage>(Arena*);
template<> ::PokerTHMessage* Arena::CreateMaybeMessage<::PokerTHMessage>(Arena*);
template<> ::RejectGameInvitationMessage* Arena::CreateMaybeMessage<::RejectGameInvitationMessage>(Arena*);
template<> ::RejectInvNotifyMessage* Arena::CreateMaybeMessage<::RejectInvNotifyMessage>(Arena*);
template<> ::RejoinExistingGameMessage* Arena::CreateMaybeMessage<::RejoinExistingGameMessage>(Arena*);
template<> ::RemovedFromGameMessage* Arena::CreateMaybeMessage<::RemovedFromGameMessage>(Arena*);
template<> ::ReportAvatarAckMessage* Arena::CreateMaybeMessage<::ReportAvatarAckMessage>(Arena*);
template<> ::ReportAvatarMessage* Arena::CreateMaybeMessage<::ReportAvatarMessage>(Arena*);
template<> ::ReportGameAckMessage* Arena::CreateMaybeMessage<::ReportGameAckMessage>(Arena*);
template<> ::ReportGameMessage* Arena::CreateMaybeMessage<::ReportGameMessage>(Arena*);
template<> ::ResetTimeoutMessage* Arena::CreateMaybeMessage<::ResetTimeoutMessage>(Arena*);
template<> ::ShowMyCardsRequestMessage* Arena::CreateMaybeMessage<::ShowMyCardsRequestMessage>(Arena*);
template<> ::StartEventAckMessage* Arena::CreateMaybeMessage<::StartEventAckMessage>(Arena*);
template<> ::StartEventMessage* Arena::CreateMaybeMessage<::StartEventMessage>(Arena*);
template<> ::StartKickPetitionMessage* Arena::CreateMaybeMessage<::StartKickPetitionMessage>(Arena*);
template<> ::StatisticsMessage* Arena::CreateMaybeMessage<::StatisticsMessage>(Arena*);
template<> ::StatisticsMessage_StatisticsData* Arena::CreateMaybeMessage<::StatisticsMessage_StatisticsData>(Arena*);
template<> ::SubscriptionRequestMessage* Arena::CreateMaybeMessage<::SubscriptionRequestMessage>(Arena*);
template<> ::TimeoutWarningMessage* Arena::CreateMaybeMessage<::TimeoutWarningMessage>(Arena*);
template<> ::UnknownAvatarMessage* Arena::CreateMaybeMessage<::UnknownAvatarMessage>(Arena*);
template<> ::VoteKickReplyMessage* Arena::CreateMaybeMessage<::VoteKickReplyMessage>(Arena*);
template<> ::VoteKickRequestMessage* Arena::CreateMaybeMessage<::VoteKickRequestMessage>(Arena*);
template<> ::YourActionRejectedMessage* Arena::CreateMaybeMessage<::YourActionRejectedMessage>(Arena*);
}  // namespace protobuf
}  // namespace google

enum NetGameInfo_NetGameType {
  NetGameInfo_NetGameType_normalGame = 1,
  NetGameInfo_NetGameType_registeredOnlyGame = 2,
  NetGameInfo_NetGameType_inviteOnlyGame = 3,
  NetGameInfo_NetGameType_rankingGame = 4
};
bool NetGameInfo_NetGameType_IsValid(int value);
const NetGameInfo_NetGameType NetGameInfo_NetGameType_NetGameType_MIN = NetGameInfo_NetGameType_normalGame;
const NetGameInfo_NetGameType NetGameInfo_NetGameType_NetGameType_MAX = NetGameInfo_NetGameType_rankingGame;
const int NetGameInfo_NetGameType_NetGameType_ARRAYSIZE = NetGameInfo_NetGameType_NetGameType_MAX + 1;

enum NetGameInfo_RaiseIntervalMode {
  NetGameInfo_RaiseIntervalMode_raiseOnHandNum = 1,
  NetGameInfo_RaiseIntervalMode_raiseOnMinutes = 2
};
bool NetGameInfo_RaiseIntervalMode_IsValid(int value);
const NetGameInfo_RaiseIntervalMode NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MIN = NetGameInfo_RaiseIntervalMode_raiseOnHandNum;
const NetGameInfo_RaiseIntervalMode NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MAX = NetGameInfo_RaiseIntervalMode_raiseOnMinutes;
const int NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_ARRAYSIZE = NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MAX + 1;

enum NetGameInfo_EndRaiseMode {
  NetGameInfo_EndRaiseMode_doubleBlinds = 1,
  NetGameInfo_EndRaiseMode_raiseByEndValue = 2,
  NetGameInfo_EndRaiseMode_keepLastBlind = 3
};
bool NetGameInfo_EndRaiseMode_IsValid(int value);
const NetGameInfo_EndRaiseMode NetGameInfo_EndRaiseMode_EndRaiseMode_MIN = NetGameInfo_EndRaiseMode_doubleBlinds;
const NetGameInfo_EndRaiseMode NetGameInfo_EndRaiseMode_EndRaiseMode_MAX = NetGameInfo_EndRaiseMode_keepLastBlind;
const int NetGameInfo_EndRaiseMode_EndRaiseMode_ARRAYSIZE = NetGameInfo_EndRaiseMode_EndRaiseMode_MAX + 1;

enum AnnounceMessage_ServerType {
  AnnounceMessage_ServerType_serverTypeLAN = 0,
  AnnounceMessage_ServerType_serverTypeInternetNoAuth = 1,
  AnnounceMessage_ServerType_serverTypeInternetAuth = 2
};
bool AnnounceMessage_ServerType_IsValid(int value);
const AnnounceMessage_ServerType AnnounceMessage_ServerType_ServerType_MIN = AnnounceMessage_ServerType_serverTypeLAN;
const AnnounceMessage_ServerType AnnounceMessage_ServerType_ServerType_MAX = AnnounceMessage_ServerType_serverTypeInternetAuth;
const int AnnounceMessage_ServerType_ServerType_ARRAYSIZE = AnnounceMessage_ServerType_ServerType_MAX + 1;

enum InitMessage_LoginType {
  InitMessage_LoginType_guestLogin = 0,
  InitMessage_LoginType_authenticatedLogin = 1,
  InitMessage_LoginType_unauthenticatedLogin = 2
};
bool InitMessage_LoginType_IsValid(int value);
const InitMessage_LoginType InitMessage_LoginType_LoginType_MIN = InitMessage_LoginType_guestLogin;
const InitMessage_LoginType InitMessage_LoginType_LoginType_MAX = InitMessage_LoginType_unauthenticatedLogin;
const int InitMessage_LoginType_LoginType_ARRAYSIZE = InitMessage_LoginType_LoginType_MAX + 1;

enum PlayerListMessage_PlayerListNotification {
  PlayerListMessage_PlayerListNotification_playerListNew = 0,
  PlayerListMessage_PlayerListNotification_playerListLeft = 1
};
bool PlayerListMessage_PlayerListNotification_IsValid(int value);
const PlayerListMessage_PlayerListNotification PlayerListMessage_PlayerListNotification_PlayerListNotification_MIN = PlayerListMessage_PlayerListNotification_playerListNew;
const PlayerListMessage_PlayerListNotification PlayerListMessage_PlayerListNotification_PlayerListNotification_MAX = PlayerListMessage_PlayerListNotification_playerListLeft;
const int PlayerListMessage_PlayerListNotification_PlayerListNotification_ARRAYSIZE = PlayerListMessage_PlayerListNotification_PlayerListNotification_MAX + 1;

enum SubscriptionRequestMessage_SubscriptionAction {
  SubscriptionRequestMessage_SubscriptionAction_unsubscribeGameList = 1,
  SubscriptionRequestMessage_SubscriptionAction_resubscribeGameList = 2
};
bool SubscriptionRequestMessage_SubscriptionAction_IsValid(int value);
const SubscriptionRequestMessage_SubscriptionAction SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MIN = SubscriptionRequestMessage_SubscriptionAction_unsubscribeGameList;
const SubscriptionRequestMessage_SubscriptionAction SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MAX = SubscriptionRequestMessage_SubscriptionAction_resubscribeGameList;
const int SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_ARRAYSIZE = SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MAX + 1;

enum JoinGameFailedMessage_JoinGameFailureReason {
  JoinGameFailedMessage_JoinGameFailureReason_invalidGame = 1,
  JoinGameFailedMessage_JoinGameFailureReason_gameIsFull = 2,
  JoinGameFailedMessage_JoinGameFailureReason_gameIsRunning = 3,
  JoinGameFailedMessage_JoinGameFailureReason_invalidPassword = 4,
  JoinGameFailedMessage_JoinGameFailureReason_notAllowedAsGuest = 5,
  JoinGameFailedMessage_JoinGameFailureReason_notInvited = 6,
  JoinGameFailedMessage_JoinGameFailureReason_gameNameInUse = 7,
  JoinGameFailedMessage_JoinGameFailureReason_badGameName = 8,
  JoinGameFailedMessage_JoinGameFailureReason_invalidSettings = 9,
  JoinGameFailedMessage_JoinGameFailureReason_ipAddressBlocked = 10,
  JoinGameFailedMessage_JoinGameFailureReason_rejoinFailed = 11,
  JoinGameFailedMessage_JoinGameFailureReason_noSpectatorsAllowed = 12
};
bool JoinGameFailedMessage_JoinGameFailureReason_IsValid(int value);
const JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MIN = JoinGameFailedMessage_JoinGameFailureReason_invalidGame;
const JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MAX = JoinGameFailedMessage_JoinGameFailureReason_noSpectatorsAllowed;
const int JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_ARRAYSIZE = JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MAX + 1;

enum GamePlayerLeftMessage_GamePlayerLeftReason {
  GamePlayerLeftMessage_GamePlayerLeftReason_leftOnRequest = 0,
  GamePlayerLeftMessage_GamePlayerLeftReason_leftKicked = 1,
  GamePlayerLeftMessage_GamePlayerLeftReason_leftError = 2
};
bool GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(int value);
const GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MIN = GamePlayerLeftMessage_GamePlayerLeftReason_leftOnRequest;
const GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MAX = GamePlayerLeftMessage_GamePlayerLeftReason_leftError;
const int GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_ARRAYSIZE = GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MAX + 1;

enum RemovedFromGameMessage_RemovedFromGameReason {
  RemovedFromGameMessage_RemovedFromGameReason_removedOnRequest = 0,
  RemovedFromGameMessage_RemovedFromGameReason_kickedFromGame = 1,
  RemovedFromGameMessage_RemovedFromGameReason_gameIsFull = 2,
  RemovedFromGameMessage_RemovedFromGameReason_gameIsRunning = 3,
  RemovedFromGameMessage_RemovedFromGameReason_gameTimeout = 4,
  RemovedFromGameMessage_RemovedFromGameReason_removedStartFailed = 5,
  RemovedFromGameMessage_RemovedFromGameReason_gameClosed = 6
};
bool RemovedFromGameMessage_RemovedFromGameReason_IsValid(int value);
const RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MIN = RemovedFromGameMessage_RemovedFromGameReason_removedOnRequest;
const RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MAX = RemovedFromGameMessage_RemovedFromGameReason_gameClosed;
const int RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_ARRAYSIZE = RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MAX + 1;

enum RejectGameInvitationMessage_RejectGameInvReason {
  RejectGameInvitationMessage_RejectGameInvReason_rejectReasonNo = 0,
  RejectGameInvitationMessage_RejectGameInvReason_rejectReasonBusy = 1
};
bool RejectGameInvitationMessage_RejectGameInvReason_IsValid(int value);
const RejectGameInvitationMessage_RejectGameInvReason RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MIN = RejectGameInvitationMessage_RejectGameInvReason_rejectReasonNo;
const RejectGameInvitationMessage_RejectGameInvReason RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MAX = RejectGameInvitationMessage_RejectGameInvReason_rejectReasonBusy;
const int RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_ARRAYSIZE = RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MAX + 1;

enum StartEventMessage_StartEventType {
  StartEventMessage_StartEventType_startEvent = 0,
  StartEventMessage_StartEventType_rejoinEvent = 1
};
bool StartEventMessage_StartEventType_IsValid(int value);
const StartEventMessage_StartEventType StartEventMessage_StartEventType_StartEventType_MIN = StartEventMessage_StartEventType_startEvent;
const StartEventMessage_StartEventType StartEventMessage_StartEventType_StartEventType_MAX = StartEventMessage_StartEventType_rejoinEvent;
const int StartEventMessage_StartEventType_StartEventType_ARRAYSIZE = StartEventMessage_StartEventType_StartEventType_MAX + 1;

enum YourActionRejectedMessage_RejectionReason {
  YourActionRejectedMessage_RejectionReason_rejectedInvalidGameState = 1,
  YourActionRejectedMessage_RejectionReason_rejectedNotYourTurn = 2,
  YourActionRejectedMessage_RejectionReason_rejectedActionNotAllowed = 3
};
bool YourActionRejectedMessage_RejectionReason_IsValid(int value);
const YourActionRejectedMessage_RejectionReason YourActionRejectedMessage_RejectionReason_RejectionReason_MIN = YourActionRejectedMessage_RejectionReason_rejectedInvalidGameState;
const YourActionRejectedMessage_RejectionReason YourActionRejectedMessage_RejectionReason_RejectionReason_MAX = YourActionRejectedMessage_RejectionReason_rejectedActionNotAllowed;
const int YourActionRejectedMessage_RejectionReason_RejectionReason_ARRAYSIZE = YourActionRejectedMessage_RejectionReason_RejectionReason_MAX + 1;

enum AskKickDeniedMessage_KickDeniedReason {
  AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidGameState = 0,
  AskKickDeniedMessage_KickDeniedReason_kickDeniedNotPossible = 1,
  AskKickDeniedMessage_KickDeniedReason_kickDeniedTryAgainLater = 2,
  AskKickDeniedMessage_KickDeniedReason_kickDeniedAlreadyInProgress = 3,
  AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidPlayerId = 4
};
bool AskKickDeniedMessage_KickDeniedReason_IsValid(int value);
const AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MIN = AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidGameState;
const AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MAX = AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidPlayerId;
const int AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_ARRAYSIZE = AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MAX + 1;

enum VoteKickReplyMessage_VoteKickReplyType {
  VoteKickReplyMessage_VoteKickReplyType_voteKickAck = 0,
  VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedInvalid = 1,
  VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedAlreadyVoted = 2
};
bool VoteKickReplyMessage_VoteKickReplyType_IsValid(int value);
const VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MIN = VoteKickReplyMessage_VoteKickReplyType_voteKickAck;
const VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MAX = VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedAlreadyVoted;
const int VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_ARRAYSIZE = VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MAX + 1;

enum EndKickPetitionMessage_PetitionEndReason {
  EndKickPetitionMessage_PetitionEndReason_petitionEndEnoughVotes = 0,
  EndKickPetitionMessage_PetitionEndReason_petitionEndTooFewPlayers = 1,
  EndKickPetitionMessage_PetitionEndReason_petitionEndPlayerLeft = 2,
  EndKickPetitionMessage_PetitionEndReason_petitionEndTimeout = 3
};
bool EndKickPetitionMessage_PetitionEndReason_IsValid(int value);
const EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MIN = EndKickPetitionMessage_PetitionEndReason_petitionEndEnoughVotes;
const EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MAX = EndKickPetitionMessage_PetitionEndReason_petitionEndTimeout;
const int EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_ARRAYSIZE = EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MAX + 1;

enum StatisticsMessage_StatisticsData_StatisticsType {
  StatisticsMessage_StatisticsData_StatisticsType_statNumberOfPlayers = 1
};
bool StatisticsMessage_StatisticsData_StatisticsType_IsValid(int value);
const StatisticsMessage_StatisticsData_StatisticsType StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MIN = StatisticsMessage_StatisticsData_StatisticsType_statNumberOfPlayers;
const StatisticsMessage_StatisticsData_StatisticsType StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MAX = StatisticsMessage_StatisticsData_StatisticsType_statNumberOfPlayers;
const int StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_ARRAYSIZE = StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MAX + 1;

enum ChatMessage_ChatType {
  ChatMessage_ChatType_chatTypeLobby = 0,
  ChatMessage_ChatType_chatTypeGame = 1,
  ChatMessage_ChatType_chatTypeBot = 2,
  ChatMessage_ChatType_chatTypeBroadcast = 3,
  ChatMessage_ChatType_chatTypePrivate = 4
};
bool ChatMessage_ChatType_IsValid(int value);
const ChatMessage_ChatType ChatMessage_ChatType_ChatType_MIN = ChatMessage_ChatType_chatTypeLobby;
const ChatMessage_ChatType ChatMessage_ChatType_ChatType_MAX = ChatMessage_ChatType_chatTypePrivate;
const int ChatMessage_ChatType_ChatType_ARRAYSIZE = ChatMessage_ChatType_ChatType_MAX + 1;

enum TimeoutWarningMessage_TimeoutReason {
  TimeoutWarningMessage_TimeoutReason_timeoutNoDataReceived = 0,
  TimeoutWarningMessage_TimeoutReason_timeoutInactiveGame = 1,
  TimeoutWarningMessage_TimeoutReason_timeoutKickAfterAutofold = 2
};
bool TimeoutWarningMessage_TimeoutReason_IsValid(int value);
const TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage_TimeoutReason_TimeoutReason_MIN = TimeoutWarningMessage_TimeoutReason_timeoutNoDataReceived;
const TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage_TimeoutReason_TimeoutReason_MAX = TimeoutWarningMessage_TimeoutReason_timeoutKickAfterAutofold;
const int TimeoutWarningMessage_TimeoutReason_TimeoutReason_ARRAYSIZE = TimeoutWarningMessage_TimeoutReason_TimeoutReason_MAX + 1;

enum ReportAvatarAckMessage_ReportAvatarResult {
  ReportAvatarAckMessage_ReportAvatarResult_avatarReportAccepted = 0,
  ReportAvatarAckMessage_ReportAvatarResult_avatarReportDuplicate = 1,
  ReportAvatarAckMessage_ReportAvatarResult_avatarReportInvalid = 2
};
bool ReportAvatarAckMessage_ReportAvatarResult_IsValid(int value);
const ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MIN = ReportAvatarAckMessage_ReportAvatarResult_avatarReportAccepted;
const ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MAX = ReportAvatarAckMessage_ReportAvatarResult_avatarReportInvalid;
const int ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_ARRAYSIZE = ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MAX + 1;

enum ReportGameAckMessage_ReportGameResult {
  ReportGameAckMessage_ReportGameResult_gameReportAccepted = 0,
  ReportGameAckMessage_ReportGameResult_gameReportDuplicate = 1,
  ReportGameAckMessage_ReportGameResult_gameReportInvalid = 2
};
bool ReportGameAckMessage_ReportGameResult_IsValid(int value);
const ReportGameAckMessage_ReportGameResult ReportGameAckMessage_ReportGameResult_ReportGameResult_MIN = ReportGameAckMessage_ReportGameResult_gameReportAccepted;
const ReportGameAckMessage_ReportGameResult ReportGameAckMessage_ReportGameResult_ReportGameResult_MAX = ReportGameAckMessage_ReportGameResult_gameReportInvalid;
const int ReportGameAckMessage_ReportGameResult_ReportGameResult_ARRAYSIZE = ReportGameAckMessage_ReportGameResult_ReportGameResult_MAX + 1;

enum ErrorMessage_ErrorReason {
  ErrorMessage_ErrorReason_custReserved = 0,
  ErrorMessage_ErrorReason_initVersionNotSupported = 1,
  ErrorMessage_ErrorReason_initServerFull = 2,
  ErrorMessage_ErrorReason_initAuthFailure = 3,
  ErrorMessage_ErrorReason_initPlayerNameInUse = 4,
  ErrorMessage_ErrorReason_initInvalidPlayerName = 5,
  ErrorMessage_ErrorReason_initServerMaintenance = 6,
  ErrorMessage_ErrorReason_initBlocked = 7,
  ErrorMessage_ErrorReason_avatarTooLarge = 8,
  ErrorMessage_ErrorReason_invalidPacket = 9,
  ErrorMessage_ErrorReason_invalidState = 10,
  ErrorMessage_ErrorReason_kickedFromServer = 11,
  ErrorMessage_ErrorReason_bannedFromServer = 12,
  ErrorMessage_ErrorReason_blockedByServer = 13,
  ErrorMessage_ErrorReason_sessionTimeout = 14
};
bool ErrorMessage_ErrorReason_IsValid(int value);
const ErrorMessage_ErrorReason ErrorMessage_ErrorReason_ErrorReason_MIN = ErrorMessage_ErrorReason_custReserved;
const ErrorMessage_ErrorReason ErrorMessage_ErrorReason_ErrorReason_MAX = ErrorMessage_ErrorReason_sessionTimeout;
const int ErrorMessage_ErrorReason_ErrorReason_ARRAYSIZE = ErrorMessage_ErrorReason_ErrorReason_MAX + 1;

enum AdminRemoveGameAckMessage_AdminRemoveGameResult {
  AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveAccepted = 0,
  AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveInvalid = 1
};
bool AdminRemoveGameAckMessage_AdminRemoveGameResult_IsValid(int value);
const AdminRemoveGameAckMessage_AdminRemoveGameResult AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_MIN = AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveAccepted;
const AdminRemoveGameAckMessage_AdminRemoveGameResult AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_MAX = AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveInvalid;
const int AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_ARRAYSIZE = AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_MAX + 1;

enum AdminBanPlayerAckMessage_AdminBanPlayerResult {
  AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerAccepted = 0,
  AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerPending = 1,
  AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerNoDB = 2,
  AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerDBError = 3,
  AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerInvalid = 4
};
bool AdminBanPlayerAckMessage_AdminBanPlayerResult_IsValid(int value);
const AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_MIN = AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerAccepted;
const AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_MAX = AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerInvalid;
const int AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_ARRAYSIZE = AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_MAX + 1;

enum PokerTHMessage_PokerTHMessageType {
  PokerTHMessage_PokerTHMessageType_Type_AnnounceMessage = 1,
  PokerTHMessage_PokerTHMessageType_Type_InitMessage = 2,
  PokerTHMessage_PokerTHMessageType_Type_AuthServerChallengeMessage = 3,
  PokerTHMessage_PokerTHMessageType_Type_AuthClientResponseMessage = 4,
  PokerTHMessage_PokerTHMessageType_Type_AuthServerVerificationMessage = 5,
  PokerTHMessage_PokerTHMessageType_Type_InitAckMessage = 6,
  PokerTHMessage_PokerTHMessageType_Type_AvatarRequestMessage = 7,
  PokerTHMessage_PokerTHMessageType_Type_AvatarHeaderMessage = 8,
  PokerTHMessage_PokerTHMessageType_Type_AvatarDataMessage = 9,
  PokerTHMessage_PokerTHMessageType_Type_AvatarEndMessage = 10,
  PokerTHMessage_PokerTHMessageType_Type_UnknownAvatarMessage = 11,
  PokerTHMessage_PokerTHMessageType_Type_PlayerListMessage = 12,
  PokerTHMessage_PokerTHMessageType_Type_GameListNewMessage = 13,
  PokerTHMessage_PokerTHMessageType_Type_GameListUpdateMessage = 14,
  PokerTHMessage_PokerTHMessageType_Type_GameListPlayerJoinedMessage = 15,
  PokerTHMessage_PokerTHMessageType_Type_GameListPlayerLeftMessage = 16,
  PokerTHMessage_PokerTHMessageType_Type_GameListAdminChangedMessage = 17,
  PokerTHMessage_PokerTHMessageType_Type_PlayerInfoRequestMessage = 18,
  PokerTHMessage_PokerTHMessageType_Type_PlayerInfoReplyMessage = 19,
  PokerTHMessage_PokerTHMessageType_Type_SubscriptionRequestMessage = 20,
  PokerTHMessage_PokerTHMessageType_Type_JoinExistingGameMessage = 21,
  PokerTHMessage_PokerTHMessageType_Type_JoinNewGameMessage = 22,
  PokerTHMessage_PokerTHMessageType_Type_RejoinExistingGameMessage = 23,
  PokerTHMessage_PokerTHMessageType_Type_JoinGameAckMessage = 24,
  PokerTHMessage_PokerTHMessageType_Type_JoinGameFailedMessage = 25,
  PokerTHMessage_PokerTHMessageType_Type_GamePlayerJoinedMessage = 26,
  PokerTHMessage_PokerTHMessageType_Type_GamePlayerLeftMessage = 27,
  PokerTHMessage_PokerTHMessageType_Type_GameAdminChangedMessage = 28,
  PokerTHMessage_PokerTHMessageType_Type_RemovedFromGameMessage = 29,
  PokerTHMessage_PokerTHMessageType_Type_KickPlayerRequestMessage = 30,
  PokerTHMessage_PokerTHMessageType_Type_LeaveGameRequestMessage = 31,
  PokerTHMessage_PokerTHMessageType_Type_InvitePlayerToGameMessage = 32,
  PokerTHMessage_PokerTHMessageType_Type_InviteNotifyMessage = 33,
  PokerTHMessage_PokerTHMessageType_Type_RejectGameInvitationMessage = 34,
  PokerTHMessage_PokerTHMessageType_Type_RejectInvNotifyMessage = 35,
  PokerTHMessage_PokerTHMessageType_Type_StartEventMessage = 36,
  PokerTHMessage_PokerTHMessageType_Type_StartEventAckMessage = 37,
  PokerTHMessage_PokerTHMessageType_Type_GameStartInitialMessage = 38,
  PokerTHMessage_PokerTHMessageType_Type_GameStartRejoinMessage = 39,
  PokerTHMessage_PokerTHMessageType_Type_HandStartMessage = 40,
  PokerTHMessage_PokerTHMessageType_Type_PlayersTurnMessage = 41,
  PokerTHMessage_PokerTHMessageType_Type_MyActionRequestMessage = 42,
  PokerTHMessage_PokerTHMessageType_Type_YourActionRejectedMessage = 43,
  PokerTHMessage_PokerTHMessageType_Type_PlayersActionDoneMessage = 44,
  PokerTHMessage_PokerTHMessageType_Type_DealFlopCardsMessage = 45,
  PokerTHMessage_PokerTHMessageType_Type_DealTurnCardMessage = 46,
  PokerTHMessage_PokerTHMessageType_Type_DealRiverCardMessage = 47,
  PokerTHMessage_PokerTHMessageType_Type_AllInShowCardsMessage = 48,
  PokerTHMessage_PokerTHMessageType_Type_EndOfHandShowCardsMessage = 49,
  PokerTHMessage_PokerTHMessageType_Type_EndOfHandHideCardsMessage = 50,
  PokerTHMessage_PokerTHMessageType_Type_ShowMyCardsRequestMessage = 51,
  PokerTHMessage_PokerTHMessageType_Type_AfterHandShowCardsMessage = 52,
  PokerTHMessage_PokerTHMessageType_Type_EndOfGameMessage = 53,
  PokerTHMessage_PokerTHMessageType_Type_PlayerIdChangedMessage = 54,
  PokerTHMessage_PokerTHMessageType_Type_AskKickPlayerMessage = 55,
  PokerTHMessage_PokerTHMessageType_Type_AskKickDeniedMessage = 56,
  PokerTHMessage_PokerTHMessageType_Type_StartKickPetitionMessage = 57,
  PokerTHMessage_PokerTHMessageType_Type_VoteKickRequestMessage = 58,
  PokerTHMessage_PokerTHMessageType_Type_VoteKickReplyMessage = 59,
  PokerTHMessage_PokerTHMessageType_Type_KickPetitionUpdateMessage = 60,
  PokerTHMessage_PokerTHMessageType_Type_EndKickPetitionMessage = 61,
  PokerTHMessage_PokerTHMessageType_Type_StatisticsMessage = 62,
  PokerTHMessage_PokerTHMessageType_Type_ChatRequestMessage = 63,
  PokerTHMessage_PokerTHMessageType_Type_ChatMessage = 64,
  PokerTHMessage_PokerTHMessageType_Type_ChatRejectMessage = 65,
  PokerTHMessage_PokerTHMessageType_Type_DialogMessage = 66,
  PokerTHMessage_PokerTHMessageType_Type_TimeoutWarningMessage = 67,
  PokerTHMessage_PokerTHMessageType_Type_ResetTimeoutMessage = 68,
  PokerTHMessage_PokerTHMessageType_Type_ReportAvatarMessage = 69,
  PokerTHMessage_PokerTHMessageType_Type_ReportAvatarAckMessage = 70,
  PokerTHMessage_PokerTHMessageType_Type_ReportGameMessage = 71,
  PokerTHMessage_PokerTHMessageType_Type_ReportGameAckMessage = 72,
  PokerTHMessage_PokerTHMessageType_Type_ErrorMessage = 73,
  PokerTHMessage_PokerTHMessageType_Type_AdminRemoveGameMessage = 74,
  PokerTHMessage_PokerTHMessageType_Type_AdminRemoveGameAckMessage = 75,
  PokerTHMessage_PokerTHMessageType_Type_AdminBanPlayerMessage = 76,
  PokerTHMessage_PokerTHMessageType_Type_AdminBanPlayerAckMessage = 77,
  PokerTHMessage_PokerTHMessageType_Type_GameListSpectatorJoinedMessage = 78,
  PokerTHMessage_PokerTHMessageType_Type_GameListSpectatorLeftMessage = 79,
  PokerTHMessage_PokerTHMessageType_Type_GameSpectatorJoinedMessage = 80,
  PokerTHMessage_PokerTHMessageType_Type_GameSpectatorLeftMessage = 81
};
bool PokerTHMessage_PokerTHMessageType_IsValid(int value);
const PokerTHMessage_PokerTHMessageType PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MIN = PokerTHMessage_PokerTHMessageType_Type_AnnounceMessage;
const PokerTHMessage_PokerTHMessageType PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MAX = PokerTHMessage_PokerTHMessageType_Type_GameSpectatorLeftMessage;
const int PokerTHMessage_PokerTHMessageType_PokerTHMessageType_ARRAYSIZE = PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MAX + 1;

enum NetGameMode {
  netGameCreated = 1,
  netGameStarted = 2,
  netGameClosed = 3
};
bool NetGameMode_IsValid(int value);
const NetGameMode NetGameMode_MIN = netGameCreated;
const NetGameMode NetGameMode_MAX = netGameClosed;
const int NetGameMode_ARRAYSIZE = NetGameMode_MAX + 1;

enum NetGameState {
  netStatePreflop = 0,
  netStateFlop = 1,
  netStateTurn = 2,
  netStateRiver = 3,
  netStatePreflopSmallBlind = 4,
  netStatePreflopBigBlind = 5
};
bool NetGameState_IsValid(int value);
const NetGameState NetGameState_MIN = netStatePreflop;
const NetGameState NetGameState_MAX = netStatePreflopBigBlind;
const int NetGameState_ARRAYSIZE = NetGameState_MAX + 1;

enum NetPlayerAction {
  netActionNone = 0,
  netActionFold = 1,
  netActionCheck = 2,
  netActionCall = 3,
  netActionBet = 4,
  netActionRaise = 5,
  netActionAllIn = 6
};
bool NetPlayerAction_IsValid(int value);
const NetPlayerAction NetPlayerAction_MIN = netActionNone;
const NetPlayerAction NetPlayerAction_MAX = netActionAllIn;
const int NetPlayerAction_ARRAYSIZE = NetPlayerAction_MAX + 1;

enum NetPlayerState {
  netPlayerStateNormal = 0,
  netPlayerStateSessionInactive = 1,
  netPlayerStateNoMoney = 2
};
bool NetPlayerState_IsValid(int value);
const NetPlayerState NetPlayerState_MIN = netPlayerStateNormal;
const NetPlayerState NetPlayerState_MAX = netPlayerStateNoMoney;
const int NetPlayerState_ARRAYSIZE = NetPlayerState_MAX + 1;

enum NetPlayerInfoRights {
  netPlayerRightsGuest = 1,
  netPlayerRightsNormal = 2,
  netPlayerRightsAdmin = 3
};
bool NetPlayerInfoRights_IsValid(int value);
const NetPlayerInfoRights NetPlayerInfoRights_MIN = netPlayerRightsGuest;
const NetPlayerInfoRights NetPlayerInfoRights_MAX = netPlayerRightsAdmin;
const int NetPlayerInfoRights_ARRAYSIZE = NetPlayerInfoRights_MAX + 1;

enum NetAvatarType {
  netAvatarImagePng = 1,
  netAvatarImageJpg = 2,
  netAvatarImageGif = 3
};
bool NetAvatarType_IsValid(int value);
const NetAvatarType NetAvatarType_MIN = netAvatarImagePng;
const NetAvatarType NetAvatarType_MAX = netAvatarImageGif;
const int NetAvatarType_ARRAYSIZE = NetAvatarType_MAX + 1;

// ===================================================================

class NetGameInfo :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:NetGameInfo) */ {
 public:
  NetGameInfo();
  virtual ~NetGameInfo();

  NetGameInfo(const NetGameInfo& from);

  inline NetGameInfo& operator=(const NetGameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetGameInfo(NetGameInfo&& from) noexcept
    : NetGameInfo() {
    *this = ::std::move(from);
  }

  inline NetGameInfo& operator=(NetGameInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const NetGameInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetGameInfo* internal_default_instance() {
    return reinterpret_cast<const NetGameInfo*>(
               &_NetGameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(NetGameInfo* other);
  friend void swap(NetGameInfo& a, NetGameInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetGameInfo* New() const final {
    return CreateMaybeMessage<NetGameInfo>(nullptr);
  }

  NetGameInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NetGameInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const NetGameInfo& from);
  void MergeFrom(const NetGameInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetGameInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef NetGameInfo_NetGameType NetGameType;
  static const NetGameType normalGame =
    NetGameInfo_NetGameType_normalGame;
  static const NetGameType registeredOnlyGame =
    NetGameInfo_NetGameType_registeredOnlyGame;
  static const NetGameType inviteOnlyGame =
    NetGameInfo_NetGameType_inviteOnlyGame;
  static const NetGameType rankingGame =
    NetGameInfo_NetGameType_rankingGame;
  static inline bool NetGameType_IsValid(int value) {
    return NetGameInfo_NetGameType_IsValid(value);
  }
  static const NetGameType NetGameType_MIN =
    NetGameInfo_NetGameType_NetGameType_MIN;
  static const NetGameType NetGameType_MAX =
    NetGameInfo_NetGameType_NetGameType_MAX;
  static const int NetGameType_ARRAYSIZE =
    NetGameInfo_NetGameType_NetGameType_ARRAYSIZE;

  typedef NetGameInfo_RaiseIntervalMode RaiseIntervalMode;
  static const RaiseIntervalMode raiseOnHandNum =
    NetGameInfo_RaiseIntervalMode_raiseOnHandNum;
  static const RaiseIntervalMode raiseOnMinutes =
    NetGameInfo_RaiseIntervalMode_raiseOnMinutes;
  static inline bool RaiseIntervalMode_IsValid(int value) {
    return NetGameInfo_RaiseIntervalMode_IsValid(value);
  }
  static const RaiseIntervalMode RaiseIntervalMode_MIN =
    NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MIN;
  static const RaiseIntervalMode RaiseIntervalMode_MAX =
    NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_MAX;
  static const int RaiseIntervalMode_ARRAYSIZE =
    NetGameInfo_RaiseIntervalMode_RaiseIntervalMode_ARRAYSIZE;

  typedef NetGameInfo_EndRaiseMode EndRaiseMode;
  static const EndRaiseMode doubleBlinds =
    NetGameInfo_EndRaiseMode_doubleBlinds;
  static const EndRaiseMode raiseByEndValue =
    NetGameInfo_EndRaiseMode_raiseByEndValue;
  static const EndRaiseMode keepLastBlind =
    NetGameInfo_EndRaiseMode_keepLastBlind;
  static inline bool EndRaiseMode_IsValid(int value) {
    return NetGameInfo_EndRaiseMode_IsValid(value);
  }
  static const EndRaiseMode EndRaiseMode_MIN =
    NetGameInfo_EndRaiseMode_EndRaiseMode_MIN;
  static const EndRaiseMode EndRaiseMode_MAX =
    NetGameInfo_EndRaiseMode_EndRaiseMode_MAX;
  static const int EndRaiseMode_ARRAYSIZE =
    NetGameInfo_EndRaiseMode_EndRaiseMode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated uint32 manualBlinds = 14 [packed = true];
  int manualblinds_size() const;
  void clear_manualblinds();
  static const int kManualBlindsFieldNumber = 14;
  ::google::protobuf::uint32 manualblinds(int index) const;
  void set_manualblinds(int index, ::google::protobuf::uint32 value);
  void add_manualblinds(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      manualblinds() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_manualblinds();

  // required string gameName = 1;
  bool has_gamename() const;
  void clear_gamename();
  static const int kGameNameFieldNumber = 1;
  const ::std::string& gamename() const;
  void set_gamename(const ::std::string& value);
  #if LANG_CXX11
  void set_gamename(::std::string&& value);
  #endif
  void set_gamename(const char* value);
  void set_gamename(const char* value, size_t size);
  ::std::string* mutable_gamename();
  ::std::string* release_gamename();
  void set_allocated_gamename(::std::string* gamename);

  // required uint32 maxNumPlayers = 3;
  bool has_maxnumplayers() const;
  void clear_maxnumplayers();
  static const int kMaxNumPlayersFieldNumber = 3;
  ::google::protobuf::uint32 maxnumplayers() const;
  void set_maxnumplayers(::google::protobuf::uint32 value);

  // optional uint32 raiseEveryHands = 5;
  bool has_raiseeveryhands() const;
  void clear_raiseeveryhands();
  static const int kRaiseEveryHandsFieldNumber = 5;
  ::google::protobuf::uint32 raiseeveryhands() const;
  void set_raiseeveryhands(::google::protobuf::uint32 value);

  // optional uint32 raiseEveryMinutes = 6;
  bool has_raiseeveryminutes() const;
  void clear_raiseeveryminutes();
  static const int kRaiseEveryMinutesFieldNumber = 6;
  ::google::protobuf::uint32 raiseeveryminutes() const;
  void set_raiseeveryminutes(::google::protobuf::uint32 value);

  // optional uint32 endRaiseSmallBlindValue = 8;
  bool has_endraisesmallblindvalue() const;
  void clear_endraisesmallblindvalue();
  static const int kEndRaiseSmallBlindValueFieldNumber = 8;
  ::google::protobuf::uint32 endraisesmallblindvalue() const;
  void set_endraisesmallblindvalue(::google::protobuf::uint32 value);

  // required uint32 proposedGuiSpeed = 9;
  bool has_proposedguispeed() const;
  void clear_proposedguispeed();
  static const int kProposedGuiSpeedFieldNumber = 9;
  ::google::protobuf::uint32 proposedguispeed() const;
  void set_proposedguispeed(::google::protobuf::uint32 value);

  // required uint32 delayBetweenHands = 10;
  bool has_delaybetweenhands() const;
  void clear_delaybetweenhands();
  static const int kDelayBetweenHandsFieldNumber = 10;
  ::google::protobuf::uint32 delaybetweenhands() const;
  void set_delaybetweenhands(::google::protobuf::uint32 value);

  // required uint32 playerActionTimeout = 11;
  bool has_playeractiontimeout() const;
  void clear_playeractiontimeout();
  static const int kPlayerActionTimeoutFieldNumber = 11;
  ::google::protobuf::uint32 playeractiontimeout() const;
  void set_playeractiontimeout(::google::protobuf::uint32 value);

  // required uint32 firstSmallBlind = 12;
  bool has_firstsmallblind() const;
  void clear_firstsmallblind();
  static const int kFirstSmallBlindFieldNumber = 12;
  ::google::protobuf::uint32 firstsmallblind() const;
  void set_firstsmallblind(::google::protobuf::uint32 value);

  // required uint32 startMoney = 13;
  bool has_startmoney() const;
  void clear_startmoney();
  static const int kStartMoneyFieldNumber = 13;
  ::google::protobuf::uint32 startmoney() const;
  void set_startmoney(::google::protobuf::uint32 value);

  // required .NetGameInfo.NetGameType netGameType = 2;
  bool has_netgametype() const;
  void clear_netgametype();
  static const int kNetGameTypeFieldNumber = 2;
  ::NetGameInfo_NetGameType netgametype() const;
  void set_netgametype(::NetGameInfo_NetGameType value);

  // required .NetGameInfo.RaiseIntervalMode raiseIntervalMode = 4;
  bool has_raiseintervalmode() const;
  void clear_raiseintervalmode();
  static const int kRaiseIntervalModeFieldNumber = 4;
  ::NetGameInfo_RaiseIntervalMode raiseintervalmode() const;
  void set_raiseintervalmode(::NetGameInfo_RaiseIntervalMode value);

  // required .NetGameInfo.EndRaiseMode endRaiseMode = 7;
  bool has_endraisemode() const;
  void clear_endraisemode();
  static const int kEndRaiseModeFieldNumber = 7;
  ::NetGameInfo_EndRaiseMode endraisemode() const;
  void set_endraisemode(::NetGameInfo_EndRaiseMode value);

  // optional bool allowSpectators = 15 [default = true];
  bool has_allowspectators() const;
  void clear_allowspectators();
  static const int kAllowSpectatorsFieldNumber = 15;
  bool allowspectators() const;
  void set_allowspectators(bool value);

  // @@protoc_insertion_point(class_scope:NetGameInfo)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > manualblinds_;
  mutable std::atomic<int> _manualblinds_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr gamename_;
  ::google::protobuf::uint32 maxnumplayers_;
  ::google::protobuf::uint32 raiseeveryhands_;
  ::google::protobuf::uint32 raiseeveryminutes_;
  ::google::protobuf::uint32 endraisesmallblindvalue_;
  ::google::protobuf::uint32 proposedguispeed_;
  ::google::protobuf::uint32 delaybetweenhands_;
  ::google::protobuf::uint32 playeractiontimeout_;
  ::google::protobuf::uint32 firstsmallblind_;
  ::google::protobuf::uint32 startmoney_;
  int netgametype_;
  int raiseintervalmode_;
  int endraisemode_;
  bool allowspectators_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayerResult :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PlayerResult) */ {
 public:
  PlayerResult();
  virtual ~PlayerResult();

  PlayerResult(const PlayerResult& from);

  inline PlayerResult& operator=(const PlayerResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerResult(PlayerResult&& from) noexcept
    : PlayerResult() {
    *this = ::std::move(from);
  }

  inline PlayerResult& operator=(PlayerResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PlayerResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerResult* internal_default_instance() {
    return reinterpret_cast<const PlayerResult*>(
               &_PlayerResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PlayerResult* other);
  friend void swap(PlayerResult& a, PlayerResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerResult* New() const final {
    return CreateMaybeMessage<PlayerResult>(nullptr);
  }

  PlayerResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerResult>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PlayerResult& from);
  void MergeFrom(const PlayerResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 bestHandPosition = 4 [packed = true];
  int besthandposition_size() const;
  void clear_besthandposition();
  static const int kBestHandPositionFieldNumber = 4;
  ::google::protobuf::uint32 besthandposition(int index) const;
  void set_besthandposition(int index, ::google::protobuf::uint32 value);
  void add_besthandposition(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      besthandposition() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_besthandposition();

  // required uint32 playerId = 1;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required uint32 resultCard1 = 2;
  bool has_resultcard1() const;
  void clear_resultcard1();
  static const int kResultCard1FieldNumber = 2;
  ::google::protobuf::uint32 resultcard1() const;
  void set_resultcard1(::google::protobuf::uint32 value);

  // required uint32 resultCard2 = 3;
  bool has_resultcard2() const;
  void clear_resultcard2();
  static const int kResultCard2FieldNumber = 3;
  ::google::protobuf::uint32 resultcard2() const;
  void set_resultcard2(::google::protobuf::uint32 value);

  // required uint32 moneyWon = 5;
  bool has_moneywon() const;
  void clear_moneywon();
  static const int kMoneyWonFieldNumber = 5;
  ::google::protobuf::uint32 moneywon() const;
  void set_moneywon(::google::protobuf::uint32 value);

  // required uint32 playerMoney = 6;
  bool has_playermoney() const;
  void clear_playermoney();
  static const int kPlayerMoneyFieldNumber = 6;
  ::google::protobuf::uint32 playermoney() const;
  void set_playermoney(::google::protobuf::uint32 value);

  // optional uint32 cardsValue = 7;
  bool has_cardsvalue() const;
  void clear_cardsvalue();
  static const int kCardsValueFieldNumber = 7;
  ::google::protobuf::uint32 cardsvalue() const;
  void set_cardsvalue(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PlayerResult)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > besthandposition_;
  mutable std::atomic<int> _besthandposition_cached_byte_size_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 resultcard1_;
  ::google::protobuf::uint32 resultcard2_;
  ::google::protobuf::uint32 moneywon_;
  ::google::protobuf::uint32 playermoney_;
  ::google::protobuf::uint32 cardsvalue_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AnnounceMessage_Version :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AnnounceMessage.Version) */ {
 public:
  AnnounceMessage_Version();
  virtual ~AnnounceMessage_Version();

  AnnounceMessage_Version(const AnnounceMessage_Version& from);

  inline AnnounceMessage_Version& operator=(const AnnounceMessage_Version& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnnounceMessage_Version(AnnounceMessage_Version&& from) noexcept
    : AnnounceMessage_Version() {
    *this = ::std::move(from);
  }

  inline AnnounceMessage_Version& operator=(AnnounceMessage_Version&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AnnounceMessage_Version& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnnounceMessage_Version* internal_default_instance() {
    return reinterpret_cast<const AnnounceMessage_Version*>(
               &_AnnounceMessage_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(AnnounceMessage_Version* other);
  friend void swap(AnnounceMessage_Version& a, AnnounceMessage_Version& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnnounceMessage_Version* New() const final {
    return CreateMaybeMessage<AnnounceMessage_Version>(nullptr);
  }

  AnnounceMessage_Version* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AnnounceMessage_Version>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AnnounceMessage_Version& from);
  void MergeFrom(const AnnounceMessage_Version& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AnnounceMessage_Version* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 majorVersion = 1;
  bool has_majorversion() const;
  void clear_majorversion();
  static const int kMajorVersionFieldNumber = 1;
  ::google::protobuf::uint32 majorversion() const;
  void set_majorversion(::google::protobuf::uint32 value);

  // required uint32 minorVersion = 2;
  bool has_minorversion() const;
  void clear_minorversion();
  static const int kMinorVersionFieldNumber = 2;
  ::google::protobuf::uint32 minorversion() const;
  void set_minorversion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AnnounceMessage.Version)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 majorversion_;
  ::google::protobuf::uint32 minorversion_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AnnounceMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AnnounceMessage) */ {
 public:
  AnnounceMessage();
  virtual ~AnnounceMessage();

  AnnounceMessage(const AnnounceMessage& from);

  inline AnnounceMessage& operator=(const AnnounceMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnnounceMessage(AnnounceMessage&& from) noexcept
    : AnnounceMessage() {
    *this = ::std::move(from);
  }

  inline AnnounceMessage& operator=(AnnounceMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AnnounceMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnnounceMessage* internal_default_instance() {
    return reinterpret_cast<const AnnounceMessage*>(
               &_AnnounceMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AnnounceMessage* other);
  friend void swap(AnnounceMessage& a, AnnounceMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnnounceMessage* New() const final {
    return CreateMaybeMessage<AnnounceMessage>(nullptr);
  }

  AnnounceMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AnnounceMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AnnounceMessage& from);
  void MergeFrom(const AnnounceMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AnnounceMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AnnounceMessage_Version Version;

  typedef AnnounceMessage_ServerType ServerType;
  static const ServerType serverTypeLAN =
    AnnounceMessage_ServerType_serverTypeLAN;
  static const ServerType serverTypeInternetNoAuth =
    AnnounceMessage_ServerType_serverTypeInternetNoAuth;
  static const ServerType serverTypeInternetAuth =
    AnnounceMessage_ServerType_serverTypeInternetAuth;
  static inline bool ServerType_IsValid(int value) {
    return AnnounceMessage_ServerType_IsValid(value);
  }
  static const ServerType ServerType_MIN =
    AnnounceMessage_ServerType_ServerType_MIN;
  static const ServerType ServerType_MAX =
    AnnounceMessage_ServerType_ServerType_MAX;
  static const int ServerType_ARRAYSIZE =
    AnnounceMessage_ServerType_ServerType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .AnnounceMessage.Version protocolVersion = 1;
  bool has_protocolversion() const;
  void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 1;
  const ::AnnounceMessage_Version& protocolversion() const;
  ::AnnounceMessage_Version* release_protocolversion();
  ::AnnounceMessage_Version* mutable_protocolversion();
  void set_allocated_protocolversion(::AnnounceMessage_Version* protocolversion);

  // required .AnnounceMessage.Version latestGameVersion = 2;
  bool has_latestgameversion() const;
  void clear_latestgameversion();
  static const int kLatestGameVersionFieldNumber = 2;
  const ::AnnounceMessage_Version& latestgameversion() const;
  ::AnnounceMessage_Version* release_latestgameversion();
  ::AnnounceMessage_Version* mutable_latestgameversion();
  void set_allocated_latestgameversion(::AnnounceMessage_Version* latestgameversion);

  // required uint32 latestBetaRevision = 3;
  bool has_latestbetarevision() const;
  void clear_latestbetarevision();
  static const int kLatestBetaRevisionFieldNumber = 3;
  ::google::protobuf::uint32 latestbetarevision() const;
  void set_latestbetarevision(::google::protobuf::uint32 value);

  // required .AnnounceMessage.ServerType serverType = 4;
  bool has_servertype() const;
  void clear_servertype();
  static const int kServerTypeFieldNumber = 4;
  ::AnnounceMessage_ServerType servertype() const;
  void set_servertype(::AnnounceMessage_ServerType value);

  // required uint32 numPlayersOnServer = 5;
  bool has_numplayersonserver() const;
  void clear_numplayersonserver();
  static const int kNumPlayersOnServerFieldNumber = 5;
  ::google::protobuf::uint32 numplayersonserver() const;
  void set_numplayersonserver(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AnnounceMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::AnnounceMessage_Version* protocolversion_;
  ::AnnounceMessage_Version* latestgameversion_;
  ::google::protobuf::uint32 latestbetarevision_;
  int servertype_;
  ::google::protobuf::uint32 numplayersonserver_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class InitMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:InitMessage) */ {
 public:
  InitMessage();
  virtual ~InitMessage();

  InitMessage(const InitMessage& from);

  inline InitMessage& operator=(const InitMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitMessage(InitMessage&& from) noexcept
    : InitMessage() {
    *this = ::std::move(from);
  }

  inline InitMessage& operator=(InitMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const InitMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitMessage* internal_default_instance() {
    return reinterpret_cast<const InitMessage*>(
               &_InitMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(InitMessage* other);
  friend void swap(InitMessage& a, InitMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitMessage* New() const final {
    return CreateMaybeMessage<InitMessage>(nullptr);
  }

  InitMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const InitMessage& from);
  void MergeFrom(const InitMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef InitMessage_LoginType LoginType;
  static const LoginType guestLogin =
    InitMessage_LoginType_guestLogin;
  static const LoginType authenticatedLogin =
    InitMessage_LoginType_authenticatedLogin;
  static const LoginType unauthenticatedLogin =
    InitMessage_LoginType_unauthenticatedLogin;
  static inline bool LoginType_IsValid(int value) {
    return InitMessage_LoginType_IsValid(value);
  }
  static const LoginType LoginType_MIN =
    InitMessage_LoginType_LoginType_MIN;
  static const LoginType LoginType_MAX =
    InitMessage_LoginType_LoginType_MAX;
  static const int LoginType_ARRAYSIZE =
    InitMessage_LoginType_LoginType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional bytes myLastSessionId = 3;
  bool has_mylastsessionid() const;
  void clear_mylastsessionid();
  static const int kMyLastSessionIdFieldNumber = 3;
  const ::std::string& mylastsessionid() const;
  void set_mylastsessionid(const ::std::string& value);
  #if LANG_CXX11
  void set_mylastsessionid(::std::string&& value);
  #endif
  void set_mylastsessionid(const char* value);
  void set_mylastsessionid(const void* value, size_t size);
  ::std::string* mutable_mylastsessionid();
  ::std::string* release_mylastsessionid();
  void set_allocated_mylastsessionid(::std::string* mylastsessionid);

  // optional string authServerPassword = 4;
  bool has_authserverpassword() const;
  void clear_authserverpassword();
  static const int kAuthServerPasswordFieldNumber = 4;
  const ::std::string& authserverpassword() const;
  void set_authserverpassword(const ::std::string& value);
  #if LANG_CXX11
  void set_authserverpassword(::std::string&& value);
  #endif
  void set_authserverpassword(const char* value);
  void set_authserverpassword(const char* value, size_t size);
  ::std::string* mutable_authserverpassword();
  ::std::string* release_authserverpassword();
  void set_allocated_authserverpassword(::std::string* authserverpassword);

  // optional string nickName = 6;
  bool has_nickname() const;
  void clear_nickname();
  static const int kNickNameFieldNumber = 6;
  const ::std::string& nickname() const;
  void set_nickname(const ::std::string& value);
  #if LANG_CXX11
  void set_nickname(::std::string&& value);
  #endif
  void set_nickname(const char* value);
  void set_nickname(const char* value, size_t size);
  ::std::string* mutable_nickname();
  ::std::string* release_nickname();
  void set_allocated_nickname(::std::string* nickname);

  // optional bytes clientUserData = 7;
  bool has_clientuserdata() const;
  void clear_clientuserdata();
  static const int kClientUserDataFieldNumber = 7;
  const ::std::string& clientuserdata() const;
  void set_clientuserdata(const ::std::string& value);
  #if LANG_CXX11
  void set_clientuserdata(::std::string&& value);
  #endif
  void set_clientuserdata(const char* value);
  void set_clientuserdata(const void* value, size_t size);
  ::std::string* mutable_clientuserdata();
  ::std::string* release_clientuserdata();
  void set_allocated_clientuserdata(::std::string* clientuserdata);

  // optional bytes avatarHash = 8;
  bool has_avatarhash() const;
  void clear_avatarhash();
  static const int kAvatarHashFieldNumber = 8;
  const ::std::string& avatarhash() const;
  void set_avatarhash(const ::std::string& value);
  #if LANG_CXX11
  void set_avatarhash(::std::string&& value);
  #endif
  void set_avatarhash(const char* value);
  void set_avatarhash(const void* value, size_t size);
  ::std::string* mutable_avatarhash();
  ::std::string* release_avatarhash();
  void set_allocated_avatarhash(::std::string* avatarhash);

  // required .AnnounceMessage.Version requestedVersion = 1;
  bool has_requestedversion() const;
  void clear_requestedversion();
  static const int kRequestedVersionFieldNumber = 1;
  const ::AnnounceMessage_Version& requestedversion() const;
  ::AnnounceMessage_Version* release_requestedversion();
  ::AnnounceMessage_Version* mutable_requestedversion();
  void set_allocated_requestedversion(::AnnounceMessage_Version* requestedversion);

  // required uint32 buildId = 2;
  bool has_buildid() const;
  void clear_buildid();
  static const int kBuildIdFieldNumber = 2;
  ::google::protobuf::uint32 buildid() const;
  void set_buildid(::google::protobuf::uint32 value);

  // required .InitMessage.LoginType login = 5;
  bool has_login() const;
  void clear_login();
  static const int kLoginFieldNumber = 5;
  ::InitMessage_LoginType login() const;
  void set_login(::InitMessage_LoginType value);

  // @@protoc_insertion_point(class_scope:InitMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr mylastsessionid_;
  ::google::protobuf::internal::ArenaStringPtr authserverpassword_;
  ::google::protobuf::internal::ArenaStringPtr nickname_;
  ::google::protobuf::internal::ArenaStringPtr clientuserdata_;
  ::google::protobuf::internal::ArenaStringPtr avatarhash_;
  ::AnnounceMessage_Version* requestedversion_;
  ::google::protobuf::uint32 buildid_;
  int login_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AuthServerChallengeMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AuthServerChallengeMessage) */ {
 public:
  AuthServerChallengeMessage();
  virtual ~AuthServerChallengeMessage();

  AuthServerChallengeMessage(const AuthServerChallengeMessage& from);

  inline AuthServerChallengeMessage& operator=(const AuthServerChallengeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthServerChallengeMessage(AuthServerChallengeMessage&& from) noexcept
    : AuthServerChallengeMessage() {
    *this = ::std::move(from);
  }

  inline AuthServerChallengeMessage& operator=(AuthServerChallengeMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AuthServerChallengeMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthServerChallengeMessage* internal_default_instance() {
    return reinterpret_cast<const AuthServerChallengeMessage*>(
               &_AuthServerChallengeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AuthServerChallengeMessage* other);
  friend void swap(AuthServerChallengeMessage& a, AuthServerChallengeMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthServerChallengeMessage* New() const final {
    return CreateMaybeMessage<AuthServerChallengeMessage>(nullptr);
  }

  AuthServerChallengeMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AuthServerChallengeMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AuthServerChallengeMessage& from);
  void MergeFrom(const AuthServerChallengeMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthServerChallengeMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes serverChallenge = 1;
  bool has_serverchallenge() const;
  void clear_serverchallenge();
  static const int kServerChallengeFieldNumber = 1;
  const ::std::string& serverchallenge() const;
  void set_serverchallenge(const ::std::string& value);
  #if LANG_CXX11
  void set_serverchallenge(::std::string&& value);
  #endif
  void set_serverchallenge(const char* value);
  void set_serverchallenge(const void* value, size_t size);
  ::std::string* mutable_serverchallenge();
  ::std::string* release_serverchallenge();
  void set_allocated_serverchallenge(::std::string* serverchallenge);

  // @@protoc_insertion_point(class_scope:AuthServerChallengeMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serverchallenge_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AuthClientResponseMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AuthClientResponseMessage) */ {
 public:
  AuthClientResponseMessage();
  virtual ~AuthClientResponseMessage();

  AuthClientResponseMessage(const AuthClientResponseMessage& from);

  inline AuthClientResponseMessage& operator=(const AuthClientResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthClientResponseMessage(AuthClientResponseMessage&& from) noexcept
    : AuthClientResponseMessage() {
    *this = ::std::move(from);
  }

  inline AuthClientResponseMessage& operator=(AuthClientResponseMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AuthClientResponseMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthClientResponseMessage* internal_default_instance() {
    return reinterpret_cast<const AuthClientResponseMessage*>(
               &_AuthClientResponseMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(AuthClientResponseMessage* other);
  friend void swap(AuthClientResponseMessage& a, AuthClientResponseMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthClientResponseMessage* New() const final {
    return CreateMaybeMessage<AuthClientResponseMessage>(nullptr);
  }

  AuthClientResponseMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AuthClientResponseMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AuthClientResponseMessage& from);
  void MergeFrom(const AuthClientResponseMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthClientResponseMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes clientResponse = 1;
  bool has_clientresponse() const;
  void clear_clientresponse();
  static const int kClientResponseFieldNumber = 1;
  const ::std::string& clientresponse() const;
  void set_clientresponse(const ::std::string& value);
  #if LANG_CXX11
  void set_clientresponse(::std::string&& value);
  #endif
  void set_clientresponse(const char* value);
  void set_clientresponse(const void* value, size_t size);
  ::std::string* mutable_clientresponse();
  ::std::string* release_clientresponse();
  void set_allocated_clientresponse(::std::string* clientresponse);

  // @@protoc_insertion_point(class_scope:AuthClientResponseMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr clientresponse_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AuthServerVerificationMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AuthServerVerificationMessage) */ {
 public:
  AuthServerVerificationMessage();
  virtual ~AuthServerVerificationMessage();

  AuthServerVerificationMessage(const AuthServerVerificationMessage& from);

  inline AuthServerVerificationMessage& operator=(const AuthServerVerificationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthServerVerificationMessage(AuthServerVerificationMessage&& from) noexcept
    : AuthServerVerificationMessage() {
    *this = ::std::move(from);
  }

  inline AuthServerVerificationMessage& operator=(AuthServerVerificationMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AuthServerVerificationMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthServerVerificationMessage* internal_default_instance() {
    return reinterpret_cast<const AuthServerVerificationMessage*>(
               &_AuthServerVerificationMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(AuthServerVerificationMessage* other);
  friend void swap(AuthServerVerificationMessage& a, AuthServerVerificationMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthServerVerificationMessage* New() const final {
    return CreateMaybeMessage<AuthServerVerificationMessage>(nullptr);
  }

  AuthServerVerificationMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AuthServerVerificationMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AuthServerVerificationMessage& from);
  void MergeFrom(const AuthServerVerificationMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AuthServerVerificationMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes serverVerification = 1;
  bool has_serververification() const;
  void clear_serververification();
  static const int kServerVerificationFieldNumber = 1;
  const ::std::string& serververification() const;
  void set_serververification(const ::std::string& value);
  #if LANG_CXX11
  void set_serververification(::std::string&& value);
  #endif
  void set_serververification(const char* value);
  void set_serververification(const void* value, size_t size);
  ::std::string* mutable_serververification();
  ::std::string* release_serververification();
  void set_allocated_serververification(::std::string* serververification);

  // @@protoc_insertion_point(class_scope:AuthServerVerificationMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serververification_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class InitAckMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:InitAckMessage) */ {
 public:
  InitAckMessage();
  virtual ~InitAckMessage();

  InitAckMessage(const InitAckMessage& from);

  inline InitAckMessage& operator=(const InitAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitAckMessage(InitAckMessage&& from) noexcept
    : InitAckMessage() {
    *this = ::std::move(from);
  }

  inline InitAckMessage& operator=(InitAckMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const InitAckMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitAckMessage* internal_default_instance() {
    return reinterpret_cast<const InitAckMessage*>(
               &_InitAckMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(InitAckMessage* other);
  friend void swap(InitAckMessage& a, InitAckMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitAckMessage* New() const final {
    return CreateMaybeMessage<InitAckMessage>(nullptr);
  }

  InitAckMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitAckMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const InitAckMessage& from);
  void MergeFrom(const InitAckMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitAckMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes yourSessionId = 1;
  bool has_yoursessionid() const;
  void clear_yoursessionid();
  static const int kYourSessionIdFieldNumber = 1;
  const ::std::string& yoursessionid() const;
  void set_yoursessionid(const ::std::string& value);
  #if LANG_CXX11
  void set_yoursessionid(::std::string&& value);
  #endif
  void set_yoursessionid(const char* value);
  void set_yoursessionid(const void* value, size_t size);
  ::std::string* mutable_yoursessionid();
  ::std::string* release_yoursessionid();
  void set_allocated_yoursessionid(::std::string* yoursessionid);

  // optional bytes yourAvatarHash = 3;
  bool has_youravatarhash() const;
  void clear_youravatarhash();
  static const int kYourAvatarHashFieldNumber = 3;
  const ::std::string& youravatarhash() const;
  void set_youravatarhash(const ::std::string& value);
  #if LANG_CXX11
  void set_youravatarhash(::std::string&& value);
  #endif
  void set_youravatarhash(const char* value);
  void set_youravatarhash(const void* value, size_t size);
  ::std::string* mutable_youravatarhash();
  ::std::string* release_youravatarhash();
  void set_allocated_youravatarhash(::std::string* youravatarhash);

  // required uint32 yourPlayerId = 2;
  bool has_yourplayerid() const;
  void clear_yourplayerid();
  static const int kYourPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 yourplayerid() const;
  void set_yourplayerid(::google::protobuf::uint32 value);

  // optional uint32 rejoinGameId = 4;
  bool has_rejoingameid() const;
  void clear_rejoingameid();
  static const int kRejoinGameIdFieldNumber = 4;
  ::google::protobuf::uint32 rejoingameid() const;
  void set_rejoingameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:InitAckMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr yoursessionid_;
  ::google::protobuf::internal::ArenaStringPtr youravatarhash_;
  ::google::protobuf::uint32 yourplayerid_;
  ::google::protobuf::uint32 rejoingameid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AvatarRequestMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AvatarRequestMessage) */ {
 public:
  AvatarRequestMessage();
  virtual ~AvatarRequestMessage();

  AvatarRequestMessage(const AvatarRequestMessage& from);

  inline AvatarRequestMessage& operator=(const AvatarRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AvatarRequestMessage(AvatarRequestMessage&& from) noexcept
    : AvatarRequestMessage() {
    *this = ::std::move(from);
  }

  inline AvatarRequestMessage& operator=(AvatarRequestMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AvatarRequestMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AvatarRequestMessage* internal_default_instance() {
    return reinterpret_cast<const AvatarRequestMessage*>(
               &_AvatarRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(AvatarRequestMessage* other);
  friend void swap(AvatarRequestMessage& a, AvatarRequestMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AvatarRequestMessage* New() const final {
    return CreateMaybeMessage<AvatarRequestMessage>(nullptr);
  }

  AvatarRequestMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AvatarRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AvatarRequestMessage& from);
  void MergeFrom(const AvatarRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AvatarRequestMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes avatarHash = 2;
  bool has_avatarhash() const;
  void clear_avatarhash();
  static const int kAvatarHashFieldNumber = 2;
  const ::std::string& avatarhash() const;
  void set_avatarhash(const ::std::string& value);
  #if LANG_CXX11
  void set_avatarhash(::std::string&& value);
  #endif
  void set_avatarhash(const char* value);
  void set_avatarhash(const void* value, size_t size);
  ::std::string* mutable_avatarhash();
  ::std::string* release_avatarhash();
  void set_allocated_avatarhash(::std::string* avatarhash);

  // required uint32 requestId = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  ::google::protobuf::uint32 requestid() const;
  void set_requestid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AvatarRequestMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr avatarhash_;
  ::google::protobuf::uint32 requestid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AvatarHeaderMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AvatarHeaderMessage) */ {
 public:
  AvatarHeaderMessage();
  virtual ~AvatarHeaderMessage();

  AvatarHeaderMessage(const AvatarHeaderMessage& from);

  inline AvatarHeaderMessage& operator=(const AvatarHeaderMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AvatarHeaderMessage(AvatarHeaderMessage&& from) noexcept
    : AvatarHeaderMessage() {
    *this = ::std::move(from);
  }

  inline AvatarHeaderMessage& operator=(AvatarHeaderMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AvatarHeaderMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AvatarHeaderMessage* internal_default_instance() {
    return reinterpret_cast<const AvatarHeaderMessage*>(
               &_AvatarHeaderMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(AvatarHeaderMessage* other);
  friend void swap(AvatarHeaderMessage& a, AvatarHeaderMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AvatarHeaderMessage* New() const final {
    return CreateMaybeMessage<AvatarHeaderMessage>(nullptr);
  }

  AvatarHeaderMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AvatarHeaderMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AvatarHeaderMessage& from);
  void MergeFrom(const AvatarHeaderMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AvatarHeaderMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 requestId = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  ::google::protobuf::uint32 requestid() const;
  void set_requestid(::google::protobuf::uint32 value);

  // required uint32 avatarSize = 3;
  bool has_avatarsize() const;
  void clear_avatarsize();
  static const int kAvatarSizeFieldNumber = 3;
  ::google::protobuf::uint32 avatarsize() const;
  void set_avatarsize(::google::protobuf::uint32 value);

  // required .NetAvatarType avatarType = 2;
  bool has_avatartype() const;
  void clear_avatartype();
  static const int kAvatarTypeFieldNumber = 2;
  ::NetAvatarType avatartype() const;
  void set_avatartype(::NetAvatarType value);

  // @@protoc_insertion_point(class_scope:AvatarHeaderMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 requestid_;
  ::google::protobuf::uint32 avatarsize_;
  int avatartype_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AvatarDataMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AvatarDataMessage) */ {
 public:
  AvatarDataMessage();
  virtual ~AvatarDataMessage();

  AvatarDataMessage(const AvatarDataMessage& from);

  inline AvatarDataMessage& operator=(const AvatarDataMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AvatarDataMessage(AvatarDataMessage&& from) noexcept
    : AvatarDataMessage() {
    *this = ::std::move(from);
  }

  inline AvatarDataMessage& operator=(AvatarDataMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AvatarDataMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AvatarDataMessage* internal_default_instance() {
    return reinterpret_cast<const AvatarDataMessage*>(
               &_AvatarDataMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(AvatarDataMessage* other);
  friend void swap(AvatarDataMessage& a, AvatarDataMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AvatarDataMessage* New() const final {
    return CreateMaybeMessage<AvatarDataMessage>(nullptr);
  }

  AvatarDataMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AvatarDataMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AvatarDataMessage& from);
  void MergeFrom(const AvatarDataMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AvatarDataMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes avatarBlock = 2;
  bool has_avatarblock() const;
  void clear_avatarblock();
  static const int kAvatarBlockFieldNumber = 2;
  const ::std::string& avatarblock() const;
  void set_avatarblock(const ::std::string& value);
  #if LANG_CXX11
  void set_avatarblock(::std::string&& value);
  #endif
  void set_avatarblock(const char* value);
  void set_avatarblock(const void* value, size_t size);
  ::std::string* mutable_avatarblock();
  ::std::string* release_avatarblock();
  void set_allocated_avatarblock(::std::string* avatarblock);

  // required uint32 requestId = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  ::google::protobuf::uint32 requestid() const;
  void set_requestid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AvatarDataMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr avatarblock_;
  ::google::protobuf::uint32 requestid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AvatarEndMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AvatarEndMessage) */ {
 public:
  AvatarEndMessage();
  virtual ~AvatarEndMessage();

  AvatarEndMessage(const AvatarEndMessage& from);

  inline AvatarEndMessage& operator=(const AvatarEndMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AvatarEndMessage(AvatarEndMessage&& from) noexcept
    : AvatarEndMessage() {
    *this = ::std::move(from);
  }

  inline AvatarEndMessage& operator=(AvatarEndMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AvatarEndMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AvatarEndMessage* internal_default_instance() {
    return reinterpret_cast<const AvatarEndMessage*>(
               &_AvatarEndMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(AvatarEndMessage* other);
  friend void swap(AvatarEndMessage& a, AvatarEndMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AvatarEndMessage* New() const final {
    return CreateMaybeMessage<AvatarEndMessage>(nullptr);
  }

  AvatarEndMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AvatarEndMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AvatarEndMessage& from);
  void MergeFrom(const AvatarEndMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AvatarEndMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 requestId = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  ::google::protobuf::uint32 requestid() const;
  void set_requestid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AvatarEndMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 requestid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class UnknownAvatarMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:UnknownAvatarMessage) */ {
 public:
  UnknownAvatarMessage();
  virtual ~UnknownAvatarMessage();

  UnknownAvatarMessage(const UnknownAvatarMessage& from);

  inline UnknownAvatarMessage& operator=(const UnknownAvatarMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnknownAvatarMessage(UnknownAvatarMessage&& from) noexcept
    : UnknownAvatarMessage() {
    *this = ::std::move(from);
  }

  inline UnknownAvatarMessage& operator=(UnknownAvatarMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const UnknownAvatarMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnknownAvatarMessage* internal_default_instance() {
    return reinterpret_cast<const UnknownAvatarMessage*>(
               &_UnknownAvatarMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(UnknownAvatarMessage* other);
  friend void swap(UnknownAvatarMessage& a, UnknownAvatarMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnknownAvatarMessage* New() const final {
    return CreateMaybeMessage<UnknownAvatarMessage>(nullptr);
  }

  UnknownAvatarMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnknownAvatarMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const UnknownAvatarMessage& from);
  void MergeFrom(const UnknownAvatarMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnknownAvatarMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 requestId = 1;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  ::google::protobuf::uint32 requestid() const;
  void set_requestid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:UnknownAvatarMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 requestid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayerListMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PlayerListMessage) */ {
 public:
  PlayerListMessage();
  virtual ~PlayerListMessage();

  PlayerListMessage(const PlayerListMessage& from);

  inline PlayerListMessage& operator=(const PlayerListMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerListMessage(PlayerListMessage&& from) noexcept
    : PlayerListMessage() {
    *this = ::std::move(from);
  }

  inline PlayerListMessage& operator=(PlayerListMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PlayerListMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerListMessage* internal_default_instance() {
    return reinterpret_cast<const PlayerListMessage*>(
               &_PlayerListMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(PlayerListMessage* other);
  friend void swap(PlayerListMessage& a, PlayerListMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerListMessage* New() const final {
    return CreateMaybeMessage<PlayerListMessage>(nullptr);
  }

  PlayerListMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerListMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PlayerListMessage& from);
  void MergeFrom(const PlayerListMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerListMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PlayerListMessage_PlayerListNotification PlayerListNotification;
  static const PlayerListNotification playerListNew =
    PlayerListMessage_PlayerListNotification_playerListNew;
  static const PlayerListNotification playerListLeft =
    PlayerListMessage_PlayerListNotification_playerListLeft;
  static inline bool PlayerListNotification_IsValid(int value) {
    return PlayerListMessage_PlayerListNotification_IsValid(value);
  }
  static const PlayerListNotification PlayerListNotification_MIN =
    PlayerListMessage_PlayerListNotification_PlayerListNotification_MIN;
  static const PlayerListNotification PlayerListNotification_MAX =
    PlayerListMessage_PlayerListNotification_PlayerListNotification_MAX;
  static const int PlayerListNotification_ARRAYSIZE =
    PlayerListMessage_PlayerListNotification_PlayerListNotification_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 playerId = 1;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required .PlayerListMessage.PlayerListNotification playerListNotification = 2;
  bool has_playerlistnotification() const;
  void clear_playerlistnotification();
  static const int kPlayerListNotificationFieldNumber = 2;
  ::PlayerListMessage_PlayerListNotification playerlistnotification() const;
  void set_playerlistnotification(::PlayerListMessage_PlayerListNotification value);

  // @@protoc_insertion_point(class_scope:PlayerListMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 playerid_;
  int playerlistnotification_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameListNewMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GameListNewMessage) */ {
 public:
  GameListNewMessage();
  virtual ~GameListNewMessage();

  GameListNewMessage(const GameListNewMessage& from);

  inline GameListNewMessage& operator=(const GameListNewMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameListNewMessage(GameListNewMessage&& from) noexcept
    : GameListNewMessage() {
    *this = ::std::move(from);
  }

  inline GameListNewMessage& operator=(GameListNewMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GameListNewMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameListNewMessage* internal_default_instance() {
    return reinterpret_cast<const GameListNewMessage*>(
               &_GameListNewMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(GameListNewMessage* other);
  friend void swap(GameListNewMessage& a, GameListNewMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameListNewMessage* New() const final {
    return CreateMaybeMessage<GameListNewMessage>(nullptr);
  }

  GameListNewMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameListNewMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GameListNewMessage& from);
  void MergeFrom(const GameListNewMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameListNewMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 playerIds = 4 [packed = true];
  int playerids_size() const;
  void clear_playerids();
  static const int kPlayerIdsFieldNumber = 4;
  ::google::protobuf::uint32 playerids(int index) const;
  void set_playerids(int index, ::google::protobuf::uint32 value);
  void add_playerids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      playerids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_playerids();

  // repeated uint32 spectatorIds = 7 [packed = true];
  int spectatorids_size() const;
  void clear_spectatorids();
  static const int kSpectatorIdsFieldNumber = 7;
  ::google::protobuf::uint32 spectatorids(int index) const;
  void set_spectatorids(int index, ::google::protobuf::uint32 value);
  void add_spectatorids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      spectatorids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_spectatorids();

  // required .NetGameInfo gameInfo = 6;
  bool has_gameinfo() const;
  void clear_gameinfo();
  static const int kGameInfoFieldNumber = 6;
  const ::NetGameInfo& gameinfo() const;
  ::NetGameInfo* release_gameinfo();
  ::NetGameInfo* mutable_gameinfo();
  void set_allocated_gameinfo(::NetGameInfo* gameinfo);

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required bool isPrivate = 3;
  bool has_isprivate() const;
  void clear_isprivate();
  static const int kIsPrivateFieldNumber = 3;
  bool isprivate() const;
  void set_isprivate(bool value);

  // required uint32 adminPlayerId = 5;
  bool has_adminplayerid() const;
  void clear_adminplayerid();
  static const int kAdminPlayerIdFieldNumber = 5;
  ::google::protobuf::uint32 adminplayerid() const;
  void set_adminplayerid(::google::protobuf::uint32 value);

  // required .NetGameMode gameMode = 2;
  bool has_gamemode() const;
  void clear_gamemode();
  static const int kGameModeFieldNumber = 2;
  ::NetGameMode gamemode() const;
  void set_gamemode(::NetGameMode value);

  // @@protoc_insertion_point(class_scope:GameListNewMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > playerids_;
  mutable std::atomic<int> _playerids_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > spectatorids_;
  mutable std::atomic<int> _spectatorids_cached_byte_size_;
  ::NetGameInfo* gameinfo_;
  ::google::protobuf::uint32 gameid_;
  bool isprivate_;
  ::google::protobuf::uint32 adminplayerid_;
  int gamemode_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameListUpdateMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GameListUpdateMessage) */ {
 public:
  GameListUpdateMessage();
  virtual ~GameListUpdateMessage();

  GameListUpdateMessage(const GameListUpdateMessage& from);

  inline GameListUpdateMessage& operator=(const GameListUpdateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameListUpdateMessage(GameListUpdateMessage&& from) noexcept
    : GameListUpdateMessage() {
    *this = ::std::move(from);
  }

  inline GameListUpdateMessage& operator=(GameListUpdateMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GameListUpdateMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameListUpdateMessage* internal_default_instance() {
    return reinterpret_cast<const GameListUpdateMessage*>(
               &_GameListUpdateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(GameListUpdateMessage* other);
  friend void swap(GameListUpdateMessage& a, GameListUpdateMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameListUpdateMessage* New() const final {
    return CreateMaybeMessage<GameListUpdateMessage>(nullptr);
  }

  GameListUpdateMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameListUpdateMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GameListUpdateMessage& from);
  void MergeFrom(const GameListUpdateMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameListUpdateMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required .NetGameMode gameMode = 2;
  bool has_gamemode() const;
  void clear_gamemode();
  static const int kGameModeFieldNumber = 2;
  ::NetGameMode gamemode() const;
  void set_gamemode(::NetGameMode value);

  // @@protoc_insertion_point(class_scope:GameListUpdateMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  int gamemode_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameListPlayerJoinedMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GameListPlayerJoinedMessage) */ {
 public:
  GameListPlayerJoinedMessage();
  virtual ~GameListPlayerJoinedMessage();

  GameListPlayerJoinedMessage(const GameListPlayerJoinedMessage& from);

  inline GameListPlayerJoinedMessage& operator=(const GameListPlayerJoinedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameListPlayerJoinedMessage(GameListPlayerJoinedMessage&& from) noexcept
    : GameListPlayerJoinedMessage() {
    *this = ::std::move(from);
  }

  inline GameListPlayerJoinedMessage& operator=(GameListPlayerJoinedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GameListPlayerJoinedMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameListPlayerJoinedMessage* internal_default_instance() {
    return reinterpret_cast<const GameListPlayerJoinedMessage*>(
               &_GameListPlayerJoinedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(GameListPlayerJoinedMessage* other);
  friend void swap(GameListPlayerJoinedMessage& a, GameListPlayerJoinedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameListPlayerJoinedMessage* New() const final {
    return CreateMaybeMessage<GameListPlayerJoinedMessage>(nullptr);
  }

  GameListPlayerJoinedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameListPlayerJoinedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GameListPlayerJoinedMessage& from);
  void MergeFrom(const GameListPlayerJoinedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameListPlayerJoinedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameListPlayerJoinedMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameListPlayerLeftMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GameListPlayerLeftMessage) */ {
 public:
  GameListPlayerLeftMessage();
  virtual ~GameListPlayerLeftMessage();

  GameListPlayerLeftMessage(const GameListPlayerLeftMessage& from);

  inline GameListPlayerLeftMessage& operator=(const GameListPlayerLeftMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameListPlayerLeftMessage(GameListPlayerLeftMessage&& from) noexcept
    : GameListPlayerLeftMessage() {
    *this = ::std::move(from);
  }

  inline GameListPlayerLeftMessage& operator=(GameListPlayerLeftMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GameListPlayerLeftMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameListPlayerLeftMessage* internal_default_instance() {
    return reinterpret_cast<const GameListPlayerLeftMessage*>(
               &_GameListPlayerLeftMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(GameListPlayerLeftMessage* other);
  friend void swap(GameListPlayerLeftMessage& a, GameListPlayerLeftMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameListPlayerLeftMessage* New() const final {
    return CreateMaybeMessage<GameListPlayerLeftMessage>(nullptr);
  }

  GameListPlayerLeftMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameListPlayerLeftMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GameListPlayerLeftMessage& from);
  void MergeFrom(const GameListPlayerLeftMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameListPlayerLeftMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameListPlayerLeftMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameListSpectatorJoinedMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GameListSpectatorJoinedMessage) */ {
 public:
  GameListSpectatorJoinedMessage();
  virtual ~GameListSpectatorJoinedMessage();

  GameListSpectatorJoinedMessage(const GameListSpectatorJoinedMessage& from);

  inline GameListSpectatorJoinedMessage& operator=(const GameListSpectatorJoinedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameListSpectatorJoinedMessage(GameListSpectatorJoinedMessage&& from) noexcept
    : GameListSpectatorJoinedMessage() {
    *this = ::std::move(from);
  }

  inline GameListSpectatorJoinedMessage& operator=(GameListSpectatorJoinedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GameListSpectatorJoinedMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameListSpectatorJoinedMessage* internal_default_instance() {
    return reinterpret_cast<const GameListSpectatorJoinedMessage*>(
               &_GameListSpectatorJoinedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(GameListSpectatorJoinedMessage* other);
  friend void swap(GameListSpectatorJoinedMessage& a, GameListSpectatorJoinedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameListSpectatorJoinedMessage* New() const final {
    return CreateMaybeMessage<GameListSpectatorJoinedMessage>(nullptr);
  }

  GameListSpectatorJoinedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameListSpectatorJoinedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GameListSpectatorJoinedMessage& from);
  void MergeFrom(const GameListSpectatorJoinedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameListSpectatorJoinedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameListSpectatorJoinedMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameListSpectatorLeftMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GameListSpectatorLeftMessage) */ {
 public:
  GameListSpectatorLeftMessage();
  virtual ~GameListSpectatorLeftMessage();

  GameListSpectatorLeftMessage(const GameListSpectatorLeftMessage& from);

  inline GameListSpectatorLeftMessage& operator=(const GameListSpectatorLeftMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameListSpectatorLeftMessage(GameListSpectatorLeftMessage&& from) noexcept
    : GameListSpectatorLeftMessage() {
    *this = ::std::move(from);
  }

  inline GameListSpectatorLeftMessage& operator=(GameListSpectatorLeftMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GameListSpectatorLeftMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameListSpectatorLeftMessage* internal_default_instance() {
    return reinterpret_cast<const GameListSpectatorLeftMessage*>(
               &_GameListSpectatorLeftMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(GameListSpectatorLeftMessage* other);
  friend void swap(GameListSpectatorLeftMessage& a, GameListSpectatorLeftMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameListSpectatorLeftMessage* New() const final {
    return CreateMaybeMessage<GameListSpectatorLeftMessage>(nullptr);
  }

  GameListSpectatorLeftMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameListSpectatorLeftMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GameListSpectatorLeftMessage& from);
  void MergeFrom(const GameListSpectatorLeftMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameListSpectatorLeftMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameListSpectatorLeftMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameListAdminChangedMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GameListAdminChangedMessage) */ {
 public:
  GameListAdminChangedMessage();
  virtual ~GameListAdminChangedMessage();

  GameListAdminChangedMessage(const GameListAdminChangedMessage& from);

  inline GameListAdminChangedMessage& operator=(const GameListAdminChangedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameListAdminChangedMessage(GameListAdminChangedMessage&& from) noexcept
    : GameListAdminChangedMessage() {
    *this = ::std::move(from);
  }

  inline GameListAdminChangedMessage& operator=(GameListAdminChangedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GameListAdminChangedMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameListAdminChangedMessage* internal_default_instance() {
    return reinterpret_cast<const GameListAdminChangedMessage*>(
               &_GameListAdminChangedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(GameListAdminChangedMessage* other);
  friend void swap(GameListAdminChangedMessage& a, GameListAdminChangedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameListAdminChangedMessage* New() const final {
    return CreateMaybeMessage<GameListAdminChangedMessage>(nullptr);
  }

  GameListAdminChangedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameListAdminChangedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GameListAdminChangedMessage& from);
  void MergeFrom(const GameListAdminChangedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameListAdminChangedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 newAdminPlayerId = 2;
  bool has_newadminplayerid() const;
  void clear_newadminplayerid();
  static const int kNewAdminPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 newadminplayerid() const;
  void set_newadminplayerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameListAdminChangedMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 newadminplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfoRequestMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PlayerInfoRequestMessage) */ {
 public:
  PlayerInfoRequestMessage();
  virtual ~PlayerInfoRequestMessage();

  PlayerInfoRequestMessage(const PlayerInfoRequestMessage& from);

  inline PlayerInfoRequestMessage& operator=(const PlayerInfoRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerInfoRequestMessage(PlayerInfoRequestMessage&& from) noexcept
    : PlayerInfoRequestMessage() {
    *this = ::std::move(from);
  }

  inline PlayerInfoRequestMessage& operator=(PlayerInfoRequestMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PlayerInfoRequestMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerInfoRequestMessage* internal_default_instance() {
    return reinterpret_cast<const PlayerInfoRequestMessage*>(
               &_PlayerInfoRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(PlayerInfoRequestMessage* other);
  friend void swap(PlayerInfoRequestMessage& a, PlayerInfoRequestMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfoRequestMessage* New() const final {
    return CreateMaybeMessage<PlayerInfoRequestMessage>(nullptr);
  }

  PlayerInfoRequestMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfoRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PlayerInfoRequestMessage& from);
  void MergeFrom(const PlayerInfoRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerInfoRequestMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 playerId = 1 [packed = true];
  int playerid_size() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 playerid(int index) const;
  void set_playerid(int index, ::google::protobuf::uint32 value);
  void add_playerid(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      playerid() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_playerid();

  // @@protoc_insertion_point(class_scope:PlayerInfoRequestMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > playerid_;
  mutable std::atomic<int> _playerid_cached_byte_size_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfoReplyMessage_PlayerInfoData_AvatarData :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PlayerInfoReplyMessage.PlayerInfoData.AvatarData) */ {
 public:
  PlayerInfoReplyMessage_PlayerInfoData_AvatarData();
  virtual ~PlayerInfoReplyMessage_PlayerInfoData_AvatarData();

  PlayerInfoReplyMessage_PlayerInfoData_AvatarData(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from);

  inline PlayerInfoReplyMessage_PlayerInfoData_AvatarData& operator=(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerInfoReplyMessage_PlayerInfoData_AvatarData(PlayerInfoReplyMessage_PlayerInfoData_AvatarData&& from) noexcept
    : PlayerInfoReplyMessage_PlayerInfoData_AvatarData() {
    *this = ::std::move(from);
  }

  inline PlayerInfoReplyMessage_PlayerInfoData_AvatarData& operator=(PlayerInfoReplyMessage_PlayerInfoData_AvatarData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerInfoReplyMessage_PlayerInfoData_AvatarData* internal_default_instance() {
    return reinterpret_cast<const PlayerInfoReplyMessage_PlayerInfoData_AvatarData*>(
               &_PlayerInfoReplyMessage_PlayerInfoData_AvatarData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(PlayerInfoReplyMessage_PlayerInfoData_AvatarData* other);
  friend void swap(PlayerInfoReplyMessage_PlayerInfoData_AvatarData& a, PlayerInfoReplyMessage_PlayerInfoData_AvatarData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfoReplyMessage_PlayerInfoData_AvatarData* New() const final {
    return CreateMaybeMessage<PlayerInfoReplyMessage_PlayerInfoData_AvatarData>(nullptr);
  }

  PlayerInfoReplyMessage_PlayerInfoData_AvatarData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfoReplyMessage_PlayerInfoData_AvatarData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from);
  void MergeFrom(const PlayerInfoReplyMessage_PlayerInfoData_AvatarData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerInfoReplyMessage_PlayerInfoData_AvatarData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes avatarHash = 2;
  bool has_avatarhash() const;
  void clear_avatarhash();
  static const int kAvatarHashFieldNumber = 2;
  const ::std::string& avatarhash() const;
  void set_avatarhash(const ::std::string& value);
  #if LANG_CXX11
  void set_avatarhash(::std::string&& value);
  #endif
  void set_avatarhash(const char* value);
  void set_avatarhash(const void* value, size_t size);
  ::std::string* mutable_avatarhash();
  ::std::string* release_avatarhash();
  void set_allocated_avatarhash(::std::string* avatarhash);

  // required .NetAvatarType avatarType = 1;
  bool has_avatartype() const;
  void clear_avatartype();
  static const int kAvatarTypeFieldNumber = 1;
  ::NetAvatarType avatartype() const;
  void set_avatartype(::NetAvatarType value);

  // @@protoc_insertion_point(class_scope:PlayerInfoReplyMessage.PlayerInfoData.AvatarData)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr avatarhash_;
  int avatartype_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfoReplyMessage_PlayerInfoData :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PlayerInfoReplyMessage.PlayerInfoData) */ {
 public:
  PlayerInfoReplyMessage_PlayerInfoData();
  virtual ~PlayerInfoReplyMessage_PlayerInfoData();

  PlayerInfoReplyMessage_PlayerInfoData(const PlayerInfoReplyMessage_PlayerInfoData& from);

  inline PlayerInfoReplyMessage_PlayerInfoData& operator=(const PlayerInfoReplyMessage_PlayerInfoData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerInfoReplyMessage_PlayerInfoData(PlayerInfoReplyMessage_PlayerInfoData&& from) noexcept
    : PlayerInfoReplyMessage_PlayerInfoData() {
    *this = ::std::move(from);
  }

  inline PlayerInfoReplyMessage_PlayerInfoData& operator=(PlayerInfoReplyMessage_PlayerInfoData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PlayerInfoReplyMessage_PlayerInfoData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerInfoReplyMessage_PlayerInfoData* internal_default_instance() {
    return reinterpret_cast<const PlayerInfoReplyMessage_PlayerInfoData*>(
               &_PlayerInfoReplyMessage_PlayerInfoData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(PlayerInfoReplyMessage_PlayerInfoData* other);
  friend void swap(PlayerInfoReplyMessage_PlayerInfoData& a, PlayerInfoReplyMessage_PlayerInfoData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfoReplyMessage_PlayerInfoData* New() const final {
    return CreateMaybeMessage<PlayerInfoReplyMessage_PlayerInfoData>(nullptr);
  }

  PlayerInfoReplyMessage_PlayerInfoData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfoReplyMessage_PlayerInfoData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PlayerInfoReplyMessage_PlayerInfoData& from);
  void MergeFrom(const PlayerInfoReplyMessage_PlayerInfoData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerInfoReplyMessage_PlayerInfoData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PlayerInfoReplyMessage_PlayerInfoData_AvatarData AvatarData;

  // accessors -------------------------------------------------------

  // required string playerName = 1;
  bool has_playername() const;
  void clear_playername();
  static const int kPlayerNameFieldNumber = 1;
  const ::std::string& playername() const;
  void set_playername(const ::std::string& value);
  #if LANG_CXX11
  void set_playername(::std::string&& value);
  #endif
  void set_playername(const char* value);
  void set_playername(const char* value, size_t size);
  ::std::string* mutable_playername();
  ::std::string* release_playername();
  void set_allocated_playername(::std::string* playername);

  // optional string countryCode = 4;
  bool has_countrycode() const;
  void clear_countrycode();
  static const int kCountryCodeFieldNumber = 4;
  const ::std::string& countrycode() const;
  void set_countrycode(const ::std::string& value);
  #if LANG_CXX11
  void set_countrycode(::std::string&& value);
  #endif
  void set_countrycode(const char* value);
  void set_countrycode(const char* value, size_t size);
  ::std::string* mutable_countrycode();
  ::std::string* release_countrycode();
  void set_allocated_countrycode(::std::string* countrycode);

  // optional .PlayerInfoReplyMessage.PlayerInfoData.AvatarData avatarData = 5;
  bool has_avatardata() const;
  void clear_avatardata();
  static const int kAvatarDataFieldNumber = 5;
  const ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData& avatardata() const;
  ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* release_avatardata();
  ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* mutable_avatardata();
  void set_allocated_avatardata(::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* avatardata);

  // required bool isHuman = 2;
  bool has_ishuman() const;
  void clear_ishuman();
  static const int kIsHumanFieldNumber = 2;
  bool ishuman() const;
  void set_ishuman(bool value);

  // required .NetPlayerInfoRights playerRights = 3;
  bool has_playerrights() const;
  void clear_playerrights();
  static const int kPlayerRightsFieldNumber = 3;
  ::NetPlayerInfoRights playerrights() const;
  void set_playerrights(::NetPlayerInfoRights value);

  // @@protoc_insertion_point(class_scope:PlayerInfoReplyMessage.PlayerInfoData)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr playername_;
  ::google::protobuf::internal::ArenaStringPtr countrycode_;
  ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* avatardata_;
  bool ishuman_;
  int playerrights_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfoReplyMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PlayerInfoReplyMessage) */ {
 public:
  PlayerInfoReplyMessage();
  virtual ~PlayerInfoReplyMessage();

  PlayerInfoReplyMessage(const PlayerInfoReplyMessage& from);

  inline PlayerInfoReplyMessage& operator=(const PlayerInfoReplyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerInfoReplyMessage(PlayerInfoReplyMessage&& from) noexcept
    : PlayerInfoReplyMessage() {
    *this = ::std::move(from);
  }

  inline PlayerInfoReplyMessage& operator=(PlayerInfoReplyMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PlayerInfoReplyMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerInfoReplyMessage* internal_default_instance() {
    return reinterpret_cast<const PlayerInfoReplyMessage*>(
               &_PlayerInfoReplyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(PlayerInfoReplyMessage* other);
  friend void swap(PlayerInfoReplyMessage& a, PlayerInfoReplyMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfoReplyMessage* New() const final {
    return CreateMaybeMessage<PlayerInfoReplyMessage>(nullptr);
  }

  PlayerInfoReplyMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfoReplyMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PlayerInfoReplyMessage& from);
  void MergeFrom(const PlayerInfoReplyMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerInfoReplyMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PlayerInfoReplyMessage_PlayerInfoData PlayerInfoData;

  // accessors -------------------------------------------------------

  // optional .PlayerInfoReplyMessage.PlayerInfoData playerInfoData = 2;
  bool has_playerinfodata() const;
  void clear_playerinfodata();
  static const int kPlayerInfoDataFieldNumber = 2;
  const ::PlayerInfoReplyMessage_PlayerInfoData& playerinfodata() const;
  ::PlayerInfoReplyMessage_PlayerInfoData* release_playerinfodata();
  ::PlayerInfoReplyMessage_PlayerInfoData* mutable_playerinfodata();
  void set_allocated_playerinfodata(::PlayerInfoReplyMessage_PlayerInfoData* playerinfodata);

  // required uint32 playerId = 1;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfoReplyMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::PlayerInfoReplyMessage_PlayerInfoData* playerinfodata_;
  ::google::protobuf::uint32 playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionRequestMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:SubscriptionRequestMessage) */ {
 public:
  SubscriptionRequestMessage();
  virtual ~SubscriptionRequestMessage();

  SubscriptionRequestMessage(const SubscriptionRequestMessage& from);

  inline SubscriptionRequestMessage& operator=(const SubscriptionRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubscriptionRequestMessage(SubscriptionRequestMessage&& from) noexcept
    : SubscriptionRequestMessage() {
    *this = ::std::move(from);
  }

  inline SubscriptionRequestMessage& operator=(SubscriptionRequestMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SubscriptionRequestMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscriptionRequestMessage* internal_default_instance() {
    return reinterpret_cast<const SubscriptionRequestMessage*>(
               &_SubscriptionRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(SubscriptionRequestMessage* other);
  friend void swap(SubscriptionRequestMessage& a, SubscriptionRequestMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubscriptionRequestMessage* New() const final {
    return CreateMaybeMessage<SubscriptionRequestMessage>(nullptr);
  }

  SubscriptionRequestMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SubscriptionRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SubscriptionRequestMessage& from);
  void MergeFrom(const SubscriptionRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubscriptionRequestMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SubscriptionRequestMessage_SubscriptionAction SubscriptionAction;
  static const SubscriptionAction unsubscribeGameList =
    SubscriptionRequestMessage_SubscriptionAction_unsubscribeGameList;
  static const SubscriptionAction resubscribeGameList =
    SubscriptionRequestMessage_SubscriptionAction_resubscribeGameList;
  static inline bool SubscriptionAction_IsValid(int value) {
    return SubscriptionRequestMessage_SubscriptionAction_IsValid(value);
  }
  static const SubscriptionAction SubscriptionAction_MIN =
    SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MIN;
  static const SubscriptionAction SubscriptionAction_MAX =
    SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_MAX;
  static const int SubscriptionAction_ARRAYSIZE =
    SubscriptionRequestMessage_SubscriptionAction_SubscriptionAction_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .SubscriptionRequestMessage.SubscriptionAction subscriptionAction = 1;
  bool has_subscriptionaction() const;
  void clear_subscriptionaction();
  static const int kSubscriptionActionFieldNumber = 1;
  ::SubscriptionRequestMessage_SubscriptionAction subscriptionaction() const;
  void set_subscriptionaction(::SubscriptionRequestMessage_SubscriptionAction value);

  // @@protoc_insertion_point(class_scope:SubscriptionRequestMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int subscriptionaction_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class JoinExistingGameMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:JoinExistingGameMessage) */ {
 public:
  JoinExistingGameMessage();
  virtual ~JoinExistingGameMessage();

  JoinExistingGameMessage(const JoinExistingGameMessage& from);

  inline JoinExistingGameMessage& operator=(const JoinExistingGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinExistingGameMessage(JoinExistingGameMessage&& from) noexcept
    : JoinExistingGameMessage() {
    *this = ::std::move(from);
  }

  inline JoinExistingGameMessage& operator=(JoinExistingGameMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const JoinExistingGameMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinExistingGameMessage* internal_default_instance() {
    return reinterpret_cast<const JoinExistingGameMessage*>(
               &_JoinExistingGameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(JoinExistingGameMessage* other);
  friend void swap(JoinExistingGameMessage& a, JoinExistingGameMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinExistingGameMessage* New() const final {
    return CreateMaybeMessage<JoinExistingGameMessage>(nullptr);
  }

  JoinExistingGameMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JoinExistingGameMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const JoinExistingGameMessage& from);
  void MergeFrom(const JoinExistingGameMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JoinExistingGameMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string password = 2;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // optional bool autoLeave = 3 [default = false];
  bool has_autoleave() const;
  void clear_autoleave();
  static const int kAutoLeaveFieldNumber = 3;
  bool autoleave() const;
  void set_autoleave(bool value);

  // optional bool spectateOnly = 4 [default = false];
  bool has_spectateonly() const;
  void clear_spectateonly();
  static const int kSpectateOnlyFieldNumber = 4;
  bool spectateonly() const;
  void set_spectateonly(bool value);

  // @@protoc_insertion_point(class_scope:JoinExistingGameMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::uint32 gameid_;
  bool autoleave_;
  bool spectateonly_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class JoinNewGameMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:JoinNewGameMessage) */ {
 public:
  JoinNewGameMessage();
  virtual ~JoinNewGameMessage();

  JoinNewGameMessage(const JoinNewGameMessage& from);

  inline JoinNewGameMessage& operator=(const JoinNewGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinNewGameMessage(JoinNewGameMessage&& from) noexcept
    : JoinNewGameMessage() {
    *this = ::std::move(from);
  }

  inline JoinNewGameMessage& operator=(JoinNewGameMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const JoinNewGameMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinNewGameMessage* internal_default_instance() {
    return reinterpret_cast<const JoinNewGameMessage*>(
               &_JoinNewGameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(JoinNewGameMessage* other);
  friend void swap(JoinNewGameMessage& a, JoinNewGameMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinNewGameMessage* New() const final {
    return CreateMaybeMessage<JoinNewGameMessage>(nullptr);
  }

  JoinNewGameMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JoinNewGameMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const JoinNewGameMessage& from);
  void MergeFrom(const JoinNewGameMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JoinNewGameMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string password = 2;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required .NetGameInfo gameInfo = 1;
  bool has_gameinfo() const;
  void clear_gameinfo();
  static const int kGameInfoFieldNumber = 1;
  const ::NetGameInfo& gameinfo() const;
  ::NetGameInfo* release_gameinfo();
  ::NetGameInfo* mutable_gameinfo();
  void set_allocated_gameinfo(::NetGameInfo* gameinfo);

  // optional bool autoLeave = 3;
  bool has_autoleave() const;
  void clear_autoleave();
  static const int kAutoLeaveFieldNumber = 3;
  bool autoleave() const;
  void set_autoleave(bool value);

  // @@protoc_insertion_point(class_scope:JoinNewGameMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::NetGameInfo* gameinfo_;
  bool autoleave_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class RejoinExistingGameMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:RejoinExistingGameMessage) */ {
 public:
  RejoinExistingGameMessage();
  virtual ~RejoinExistingGameMessage();

  RejoinExistingGameMessage(const RejoinExistingGameMessage& from);

  inline RejoinExistingGameMessage& operator=(const RejoinExistingGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RejoinExistingGameMessage(RejoinExistingGameMessage&& from) noexcept
    : RejoinExistingGameMessage() {
    *this = ::std::move(from);
  }

  inline RejoinExistingGameMessage& operator=(RejoinExistingGameMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RejoinExistingGameMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RejoinExistingGameMessage* internal_default_instance() {
    return reinterpret_cast<const RejoinExistingGameMessage*>(
               &_RejoinExistingGameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(RejoinExistingGameMessage* other);
  friend void swap(RejoinExistingGameMessage& a, RejoinExistingGameMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RejoinExistingGameMessage* New() const final {
    return CreateMaybeMessage<RejoinExistingGameMessage>(nullptr);
  }

  RejoinExistingGameMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RejoinExistingGameMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RejoinExistingGameMessage& from);
  void MergeFrom(const RejoinExistingGameMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RejoinExistingGameMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // optional bool autoLeave = 2;
  bool has_autoleave() const;
  void clear_autoleave();
  static const int kAutoLeaveFieldNumber = 2;
  bool autoleave() const;
  void set_autoleave(bool value);

  // @@protoc_insertion_point(class_scope:RejoinExistingGameMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  bool autoleave_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class JoinGameAckMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:JoinGameAckMessage) */ {
 public:
  JoinGameAckMessage();
  virtual ~JoinGameAckMessage();

  JoinGameAckMessage(const JoinGameAckMessage& from);

  inline JoinGameAckMessage& operator=(const JoinGameAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinGameAckMessage(JoinGameAckMessage&& from) noexcept
    : JoinGameAckMessage() {
    *this = ::std::move(from);
  }

  inline JoinGameAckMessage& operator=(JoinGameAckMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const JoinGameAckMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinGameAckMessage* internal_default_instance() {
    return reinterpret_cast<const JoinGameAckMessage*>(
               &_JoinGameAckMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(JoinGameAckMessage* other);
  friend void swap(JoinGameAckMessage& a, JoinGameAckMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinGameAckMessage* New() const final {
    return CreateMaybeMessage<JoinGameAckMessage>(nullptr);
  }

  JoinGameAckMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JoinGameAckMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const JoinGameAckMessage& from);
  void MergeFrom(const JoinGameAckMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JoinGameAckMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NetGameInfo gameInfo = 3;
  bool has_gameinfo() const;
  void clear_gameinfo();
  static const int kGameInfoFieldNumber = 3;
  const ::NetGameInfo& gameinfo() const;
  ::NetGameInfo* release_gameinfo();
  ::NetGameInfo* mutable_gameinfo();
  void set_allocated_gameinfo(::NetGameInfo* gameinfo);

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required bool areYouGameAdmin = 2;
  bool has_areyougameadmin() const;
  void clear_areyougameadmin();
  static const int kAreYouGameAdminFieldNumber = 2;
  bool areyougameadmin() const;
  void set_areyougameadmin(bool value);

  // optional bool spectateOnly = 4;
  bool has_spectateonly() const;
  void clear_spectateonly();
  static const int kSpectateOnlyFieldNumber = 4;
  bool spectateonly() const;
  void set_spectateonly(bool value);

  // @@protoc_insertion_point(class_scope:JoinGameAckMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::NetGameInfo* gameinfo_;
  ::google::protobuf::uint32 gameid_;
  bool areyougameadmin_;
  bool spectateonly_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class JoinGameFailedMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:JoinGameFailedMessage) */ {
 public:
  JoinGameFailedMessage();
  virtual ~JoinGameFailedMessage();

  JoinGameFailedMessage(const JoinGameFailedMessage& from);

  inline JoinGameFailedMessage& operator=(const JoinGameFailedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinGameFailedMessage(JoinGameFailedMessage&& from) noexcept
    : JoinGameFailedMessage() {
    *this = ::std::move(from);
  }

  inline JoinGameFailedMessage& operator=(JoinGameFailedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const JoinGameFailedMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinGameFailedMessage* internal_default_instance() {
    return reinterpret_cast<const JoinGameFailedMessage*>(
               &_JoinGameFailedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(JoinGameFailedMessage* other);
  friend void swap(JoinGameFailedMessage& a, JoinGameFailedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinGameFailedMessage* New() const final {
    return CreateMaybeMessage<JoinGameFailedMessage>(nullptr);
  }

  JoinGameFailedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JoinGameFailedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const JoinGameFailedMessage& from);
  void MergeFrom(const JoinGameFailedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JoinGameFailedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef JoinGameFailedMessage_JoinGameFailureReason JoinGameFailureReason;
  static const JoinGameFailureReason invalidGame =
    JoinGameFailedMessage_JoinGameFailureReason_invalidGame;
  static const JoinGameFailureReason gameIsFull =
    JoinGameFailedMessage_JoinGameFailureReason_gameIsFull;
  static const JoinGameFailureReason gameIsRunning =
    JoinGameFailedMessage_JoinGameFailureReason_gameIsRunning;
  static const JoinGameFailureReason invalidPassword =
    JoinGameFailedMessage_JoinGameFailureReason_invalidPassword;
  static const JoinGameFailureReason notAllowedAsGuest =
    JoinGameFailedMessage_JoinGameFailureReason_notAllowedAsGuest;
  static const JoinGameFailureReason notInvited =
    JoinGameFailedMessage_JoinGameFailureReason_notInvited;
  static const JoinGameFailureReason gameNameInUse =
    JoinGameFailedMessage_JoinGameFailureReason_gameNameInUse;
  static const JoinGameFailureReason badGameName =
    JoinGameFailedMessage_JoinGameFailureReason_badGameName;
  static const JoinGameFailureReason invalidSettings =
    JoinGameFailedMessage_JoinGameFailureReason_invalidSettings;
  static const JoinGameFailureReason ipAddressBlocked =
    JoinGameFailedMessage_JoinGameFailureReason_ipAddressBlocked;
  static const JoinGameFailureReason rejoinFailed =
    JoinGameFailedMessage_JoinGameFailureReason_rejoinFailed;
  static const JoinGameFailureReason noSpectatorsAllowed =
    JoinGameFailedMessage_JoinGameFailureReason_noSpectatorsAllowed;
  static inline bool JoinGameFailureReason_IsValid(int value) {
    return JoinGameFailedMessage_JoinGameFailureReason_IsValid(value);
  }
  static const JoinGameFailureReason JoinGameFailureReason_MIN =
    JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MIN;
  static const JoinGameFailureReason JoinGameFailureReason_MAX =
    JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_MAX;
  static const int JoinGameFailureReason_ARRAYSIZE =
    JoinGameFailedMessage_JoinGameFailureReason_JoinGameFailureReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required .JoinGameFailedMessage.JoinGameFailureReason joinGameFailureReason = 2;
  bool has_joingamefailurereason() const;
  void clear_joingamefailurereason();
  static const int kJoinGameFailureReasonFieldNumber = 2;
  ::JoinGameFailedMessage_JoinGameFailureReason joingamefailurereason() const;
  void set_joingamefailurereason(::JoinGameFailedMessage_JoinGameFailureReason value);

  // @@protoc_insertion_point(class_scope:JoinGameFailedMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  int joingamefailurereason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GamePlayerJoinedMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GamePlayerJoinedMessage) */ {
 public:
  GamePlayerJoinedMessage();
  virtual ~GamePlayerJoinedMessage();

  GamePlayerJoinedMessage(const GamePlayerJoinedMessage& from);

  inline GamePlayerJoinedMessage& operator=(const GamePlayerJoinedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GamePlayerJoinedMessage(GamePlayerJoinedMessage&& from) noexcept
    : GamePlayerJoinedMessage() {
    *this = ::std::move(from);
  }

  inline GamePlayerJoinedMessage& operator=(GamePlayerJoinedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GamePlayerJoinedMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GamePlayerJoinedMessage* internal_default_instance() {
    return reinterpret_cast<const GamePlayerJoinedMessage*>(
               &_GamePlayerJoinedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(GamePlayerJoinedMessage* other);
  friend void swap(GamePlayerJoinedMessage& a, GamePlayerJoinedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GamePlayerJoinedMessage* New() const final {
    return CreateMaybeMessage<GamePlayerJoinedMessage>(nullptr);
  }

  GamePlayerJoinedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GamePlayerJoinedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GamePlayerJoinedMessage& from);
  void MergeFrom(const GamePlayerJoinedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GamePlayerJoinedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required bool isGameAdmin = 3;
  bool has_isgameadmin() const;
  void clear_isgameadmin();
  static const int kIsGameAdminFieldNumber = 3;
  bool isgameadmin() const;
  void set_isgameadmin(bool value);

  // @@protoc_insertion_point(class_scope:GamePlayerJoinedMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  bool isgameadmin_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GamePlayerLeftMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GamePlayerLeftMessage) */ {
 public:
  GamePlayerLeftMessage();
  virtual ~GamePlayerLeftMessage();

  GamePlayerLeftMessage(const GamePlayerLeftMessage& from);

  inline GamePlayerLeftMessage& operator=(const GamePlayerLeftMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GamePlayerLeftMessage(GamePlayerLeftMessage&& from) noexcept
    : GamePlayerLeftMessage() {
    *this = ::std::move(from);
  }

  inline GamePlayerLeftMessage& operator=(GamePlayerLeftMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GamePlayerLeftMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GamePlayerLeftMessage* internal_default_instance() {
    return reinterpret_cast<const GamePlayerLeftMessage*>(
               &_GamePlayerLeftMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(GamePlayerLeftMessage* other);
  friend void swap(GamePlayerLeftMessage& a, GamePlayerLeftMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GamePlayerLeftMessage* New() const final {
    return CreateMaybeMessage<GamePlayerLeftMessage>(nullptr);
  }

  GamePlayerLeftMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GamePlayerLeftMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GamePlayerLeftMessage& from);
  void MergeFrom(const GamePlayerLeftMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GamePlayerLeftMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftReason;
  static const GamePlayerLeftReason leftOnRequest =
    GamePlayerLeftMessage_GamePlayerLeftReason_leftOnRequest;
  static const GamePlayerLeftReason leftKicked =
    GamePlayerLeftMessage_GamePlayerLeftReason_leftKicked;
  static const GamePlayerLeftReason leftError =
    GamePlayerLeftMessage_GamePlayerLeftReason_leftError;
  static inline bool GamePlayerLeftReason_IsValid(int value) {
    return GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(value);
  }
  static const GamePlayerLeftReason GamePlayerLeftReason_MIN =
    GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MIN;
  static const GamePlayerLeftReason GamePlayerLeftReason_MAX =
    GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_MAX;
  static const int GamePlayerLeftReason_ARRAYSIZE =
    GamePlayerLeftMessage_GamePlayerLeftReason_GamePlayerLeftReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required .GamePlayerLeftMessage.GamePlayerLeftReason gamePlayerLeftReason = 3;
  bool has_gameplayerleftreason() const;
  void clear_gameplayerleftreason();
  static const int kGamePlayerLeftReasonFieldNumber = 3;
  ::GamePlayerLeftMessage_GamePlayerLeftReason gameplayerleftreason() const;
  void set_gameplayerleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value);

  // @@protoc_insertion_point(class_scope:GamePlayerLeftMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int gameplayerleftreason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameSpectatorJoinedMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GameSpectatorJoinedMessage) */ {
 public:
  GameSpectatorJoinedMessage();
  virtual ~GameSpectatorJoinedMessage();

  GameSpectatorJoinedMessage(const GameSpectatorJoinedMessage& from);

  inline GameSpectatorJoinedMessage& operator=(const GameSpectatorJoinedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameSpectatorJoinedMessage(GameSpectatorJoinedMessage&& from) noexcept
    : GameSpectatorJoinedMessage() {
    *this = ::std::move(from);
  }

  inline GameSpectatorJoinedMessage& operator=(GameSpectatorJoinedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GameSpectatorJoinedMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameSpectatorJoinedMessage* internal_default_instance() {
    return reinterpret_cast<const GameSpectatorJoinedMessage*>(
               &_GameSpectatorJoinedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(GameSpectatorJoinedMessage* other);
  friend void swap(GameSpectatorJoinedMessage& a, GameSpectatorJoinedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameSpectatorJoinedMessage* New() const final {
    return CreateMaybeMessage<GameSpectatorJoinedMessage>(nullptr);
  }

  GameSpectatorJoinedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameSpectatorJoinedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GameSpectatorJoinedMessage& from);
  void MergeFrom(const GameSpectatorJoinedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameSpectatorJoinedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameSpectatorJoinedMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameSpectatorLeftMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GameSpectatorLeftMessage) */ {
 public:
  GameSpectatorLeftMessage();
  virtual ~GameSpectatorLeftMessage();

  GameSpectatorLeftMessage(const GameSpectatorLeftMessage& from);

  inline GameSpectatorLeftMessage& operator=(const GameSpectatorLeftMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameSpectatorLeftMessage(GameSpectatorLeftMessage&& from) noexcept
    : GameSpectatorLeftMessage() {
    *this = ::std::move(from);
  }

  inline GameSpectatorLeftMessage& operator=(GameSpectatorLeftMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GameSpectatorLeftMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameSpectatorLeftMessage* internal_default_instance() {
    return reinterpret_cast<const GameSpectatorLeftMessage*>(
               &_GameSpectatorLeftMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(GameSpectatorLeftMessage* other);
  friend void swap(GameSpectatorLeftMessage& a, GameSpectatorLeftMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameSpectatorLeftMessage* New() const final {
    return CreateMaybeMessage<GameSpectatorLeftMessage>(nullptr);
  }

  GameSpectatorLeftMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameSpectatorLeftMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GameSpectatorLeftMessage& from);
  void MergeFrom(const GameSpectatorLeftMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameSpectatorLeftMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required .GamePlayerLeftMessage.GamePlayerLeftReason gameSpectatorLeftReason = 3;
  bool has_gamespectatorleftreason() const;
  void clear_gamespectatorleftreason();
  static const int kGameSpectatorLeftReasonFieldNumber = 3;
  ::GamePlayerLeftMessage_GamePlayerLeftReason gamespectatorleftreason() const;
  void set_gamespectatorleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value);

  // @@protoc_insertion_point(class_scope:GameSpectatorLeftMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int gamespectatorleftreason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameAdminChangedMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GameAdminChangedMessage) */ {
 public:
  GameAdminChangedMessage();
  virtual ~GameAdminChangedMessage();

  GameAdminChangedMessage(const GameAdminChangedMessage& from);

  inline GameAdminChangedMessage& operator=(const GameAdminChangedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameAdminChangedMessage(GameAdminChangedMessage&& from) noexcept
    : GameAdminChangedMessage() {
    *this = ::std::move(from);
  }

  inline GameAdminChangedMessage& operator=(GameAdminChangedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GameAdminChangedMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameAdminChangedMessage* internal_default_instance() {
    return reinterpret_cast<const GameAdminChangedMessage*>(
               &_GameAdminChangedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(GameAdminChangedMessage* other);
  friend void swap(GameAdminChangedMessage& a, GameAdminChangedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameAdminChangedMessage* New() const final {
    return CreateMaybeMessage<GameAdminChangedMessage>(nullptr);
  }

  GameAdminChangedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameAdminChangedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GameAdminChangedMessage& from);
  void MergeFrom(const GameAdminChangedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameAdminChangedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 newAdminPlayerId = 2;
  bool has_newadminplayerid() const;
  void clear_newadminplayerid();
  static const int kNewAdminPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 newadminplayerid() const;
  void set_newadminplayerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameAdminChangedMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 newadminplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class RemovedFromGameMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:RemovedFromGameMessage) */ {
 public:
  RemovedFromGameMessage();
  virtual ~RemovedFromGameMessage();

  RemovedFromGameMessage(const RemovedFromGameMessage& from);

  inline RemovedFromGameMessage& operator=(const RemovedFromGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemovedFromGameMessage(RemovedFromGameMessage&& from) noexcept
    : RemovedFromGameMessage() {
    *this = ::std::move(from);
  }

  inline RemovedFromGameMessage& operator=(RemovedFromGameMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RemovedFromGameMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemovedFromGameMessage* internal_default_instance() {
    return reinterpret_cast<const RemovedFromGameMessage*>(
               &_RemovedFromGameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(RemovedFromGameMessage* other);
  friend void swap(RemovedFromGameMessage& a, RemovedFromGameMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemovedFromGameMessage* New() const final {
    return CreateMaybeMessage<RemovedFromGameMessage>(nullptr);
  }

  RemovedFromGameMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RemovedFromGameMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RemovedFromGameMessage& from);
  void MergeFrom(const RemovedFromGameMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RemovedFromGameMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameReason;
  static const RemovedFromGameReason removedOnRequest =
    RemovedFromGameMessage_RemovedFromGameReason_removedOnRequest;
  static const RemovedFromGameReason kickedFromGame =
    RemovedFromGameMessage_RemovedFromGameReason_kickedFromGame;
  static const RemovedFromGameReason gameIsFull =
    RemovedFromGameMessage_RemovedFromGameReason_gameIsFull;
  static const RemovedFromGameReason gameIsRunning =
    RemovedFromGameMessage_RemovedFromGameReason_gameIsRunning;
  static const RemovedFromGameReason gameTimeout =
    RemovedFromGameMessage_RemovedFromGameReason_gameTimeout;
  static const RemovedFromGameReason removedStartFailed =
    RemovedFromGameMessage_RemovedFromGameReason_removedStartFailed;
  static const RemovedFromGameReason gameClosed =
    RemovedFromGameMessage_RemovedFromGameReason_gameClosed;
  static inline bool RemovedFromGameReason_IsValid(int value) {
    return RemovedFromGameMessage_RemovedFromGameReason_IsValid(value);
  }
  static const RemovedFromGameReason RemovedFromGameReason_MIN =
    RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MIN;
  static const RemovedFromGameReason RemovedFromGameReason_MAX =
    RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_MAX;
  static const int RemovedFromGameReason_ARRAYSIZE =
    RemovedFromGameMessage_RemovedFromGameReason_RemovedFromGameReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required .RemovedFromGameMessage.RemovedFromGameReason removedFromGameReason = 2;
  bool has_removedfromgamereason() const;
  void clear_removedfromgamereason();
  static const int kRemovedFromGameReasonFieldNumber = 2;
  ::RemovedFromGameMessage_RemovedFromGameReason removedfromgamereason() const;
  void set_removedfromgamereason(::RemovedFromGameMessage_RemovedFromGameReason value);

  // @@protoc_insertion_point(class_scope:RemovedFromGameMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  int removedfromgamereason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class KickPlayerRequestMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:KickPlayerRequestMessage) */ {
 public:
  KickPlayerRequestMessage();
  virtual ~KickPlayerRequestMessage();

  KickPlayerRequestMessage(const KickPlayerRequestMessage& from);

  inline KickPlayerRequestMessage& operator=(const KickPlayerRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KickPlayerRequestMessage(KickPlayerRequestMessage&& from) noexcept
    : KickPlayerRequestMessage() {
    *this = ::std::move(from);
  }

  inline KickPlayerRequestMessage& operator=(KickPlayerRequestMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const KickPlayerRequestMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KickPlayerRequestMessage* internal_default_instance() {
    return reinterpret_cast<const KickPlayerRequestMessage*>(
               &_KickPlayerRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(KickPlayerRequestMessage* other);
  friend void swap(KickPlayerRequestMessage& a, KickPlayerRequestMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KickPlayerRequestMessage* New() const final {
    return CreateMaybeMessage<KickPlayerRequestMessage>(nullptr);
  }

  KickPlayerRequestMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KickPlayerRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const KickPlayerRequestMessage& from);
  void MergeFrom(const KickPlayerRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KickPlayerRequestMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:KickPlayerRequestMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class LeaveGameRequestMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:LeaveGameRequestMessage) */ {
 public:
  LeaveGameRequestMessage();
  virtual ~LeaveGameRequestMessage();

  LeaveGameRequestMessage(const LeaveGameRequestMessage& from);

  inline LeaveGameRequestMessage& operator=(const LeaveGameRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeaveGameRequestMessage(LeaveGameRequestMessage&& from) noexcept
    : LeaveGameRequestMessage() {
    *this = ::std::move(from);
  }

  inline LeaveGameRequestMessage& operator=(LeaveGameRequestMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const LeaveGameRequestMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeaveGameRequestMessage* internal_default_instance() {
    return reinterpret_cast<const LeaveGameRequestMessage*>(
               &_LeaveGameRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(LeaveGameRequestMessage* other);
  friend void swap(LeaveGameRequestMessage& a, LeaveGameRequestMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeaveGameRequestMessage* New() const final {
    return CreateMaybeMessage<LeaveGameRequestMessage>(nullptr);
  }

  LeaveGameRequestMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LeaveGameRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const LeaveGameRequestMessage& from);
  void MergeFrom(const LeaveGameRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LeaveGameRequestMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:LeaveGameRequestMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class InvitePlayerToGameMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:InvitePlayerToGameMessage) */ {
 public:
  InvitePlayerToGameMessage();
  virtual ~InvitePlayerToGameMessage();

  InvitePlayerToGameMessage(const InvitePlayerToGameMessage& from);

  inline InvitePlayerToGameMessage& operator=(const InvitePlayerToGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InvitePlayerToGameMessage(InvitePlayerToGameMessage&& from) noexcept
    : InvitePlayerToGameMessage() {
    *this = ::std::move(from);
  }

  inline InvitePlayerToGameMessage& operator=(InvitePlayerToGameMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const InvitePlayerToGameMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InvitePlayerToGameMessage* internal_default_instance() {
    return reinterpret_cast<const InvitePlayerToGameMessage*>(
               &_InvitePlayerToGameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(InvitePlayerToGameMessage* other);
  friend void swap(InvitePlayerToGameMessage& a, InvitePlayerToGameMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InvitePlayerToGameMessage* New() const final {
    return CreateMaybeMessage<InvitePlayerToGameMessage>(nullptr);
  }

  InvitePlayerToGameMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InvitePlayerToGameMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const InvitePlayerToGameMessage& from);
  void MergeFrom(const InvitePlayerToGameMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InvitePlayerToGameMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:InvitePlayerToGameMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class InviteNotifyMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:InviteNotifyMessage) */ {
 public:
  InviteNotifyMessage();
  virtual ~InviteNotifyMessage();

  InviteNotifyMessage(const InviteNotifyMessage& from);

  inline InviteNotifyMessage& operator=(const InviteNotifyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InviteNotifyMessage(InviteNotifyMessage&& from) noexcept
    : InviteNotifyMessage() {
    *this = ::std::move(from);
  }

  inline InviteNotifyMessage& operator=(InviteNotifyMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const InviteNotifyMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InviteNotifyMessage* internal_default_instance() {
    return reinterpret_cast<const InviteNotifyMessage*>(
               &_InviteNotifyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(InviteNotifyMessage* other);
  friend void swap(InviteNotifyMessage& a, InviteNotifyMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InviteNotifyMessage* New() const final {
    return CreateMaybeMessage<InviteNotifyMessage>(nullptr);
  }

  InviteNotifyMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InviteNotifyMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const InviteNotifyMessage& from);
  void MergeFrom(const InviteNotifyMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InviteNotifyMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerIdWho = 2;
  bool has_playeridwho() const;
  void clear_playeridwho();
  static const int kPlayerIdWhoFieldNumber = 2;
  ::google::protobuf::uint32 playeridwho() const;
  void set_playeridwho(::google::protobuf::uint32 value);

  // required uint32 playerIdByWhom = 3;
  bool has_playeridbywhom() const;
  void clear_playeridbywhom();
  static const int kPlayerIdByWhomFieldNumber = 3;
  ::google::protobuf::uint32 playeridbywhom() const;
  void set_playeridbywhom(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:InviteNotifyMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playeridwho_;
  ::google::protobuf::uint32 playeridbywhom_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class RejectGameInvitationMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:RejectGameInvitationMessage) */ {
 public:
  RejectGameInvitationMessage();
  virtual ~RejectGameInvitationMessage();

  RejectGameInvitationMessage(const RejectGameInvitationMessage& from);

  inline RejectGameInvitationMessage& operator=(const RejectGameInvitationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RejectGameInvitationMessage(RejectGameInvitationMessage&& from) noexcept
    : RejectGameInvitationMessage() {
    *this = ::std::move(from);
  }

  inline RejectGameInvitationMessage& operator=(RejectGameInvitationMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RejectGameInvitationMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RejectGameInvitationMessage* internal_default_instance() {
    return reinterpret_cast<const RejectGameInvitationMessage*>(
               &_RejectGameInvitationMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(RejectGameInvitationMessage* other);
  friend void swap(RejectGameInvitationMessage& a, RejectGameInvitationMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RejectGameInvitationMessage* New() const final {
    return CreateMaybeMessage<RejectGameInvitationMessage>(nullptr);
  }

  RejectGameInvitationMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RejectGameInvitationMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RejectGameInvitationMessage& from);
  void MergeFrom(const RejectGameInvitationMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RejectGameInvitationMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RejectGameInvitationMessage_RejectGameInvReason RejectGameInvReason;
  static const RejectGameInvReason rejectReasonNo =
    RejectGameInvitationMessage_RejectGameInvReason_rejectReasonNo;
  static const RejectGameInvReason rejectReasonBusy =
    RejectGameInvitationMessage_RejectGameInvReason_rejectReasonBusy;
  static inline bool RejectGameInvReason_IsValid(int value) {
    return RejectGameInvitationMessage_RejectGameInvReason_IsValid(value);
  }
  static const RejectGameInvReason RejectGameInvReason_MIN =
    RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MIN;
  static const RejectGameInvReason RejectGameInvReason_MAX =
    RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_MAX;
  static const int RejectGameInvReason_ARRAYSIZE =
    RejectGameInvitationMessage_RejectGameInvReason_RejectGameInvReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required .RejectGameInvitationMessage.RejectGameInvReason myRejectReason = 2;
  bool has_myrejectreason() const;
  void clear_myrejectreason();
  static const int kMyRejectReasonFieldNumber = 2;
  ::RejectGameInvitationMessage_RejectGameInvReason myrejectreason() const;
  void set_myrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value);

  // @@protoc_insertion_point(class_scope:RejectGameInvitationMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  int myrejectreason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class RejectInvNotifyMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:RejectInvNotifyMessage) */ {
 public:
  RejectInvNotifyMessage();
  virtual ~RejectInvNotifyMessage();

  RejectInvNotifyMessage(const RejectInvNotifyMessage& from);

  inline RejectInvNotifyMessage& operator=(const RejectInvNotifyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RejectInvNotifyMessage(RejectInvNotifyMessage&& from) noexcept
    : RejectInvNotifyMessage() {
    *this = ::std::move(from);
  }

  inline RejectInvNotifyMessage& operator=(RejectInvNotifyMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RejectInvNotifyMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RejectInvNotifyMessage* internal_default_instance() {
    return reinterpret_cast<const RejectInvNotifyMessage*>(
               &_RejectInvNotifyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(RejectInvNotifyMessage* other);
  friend void swap(RejectInvNotifyMessage& a, RejectInvNotifyMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RejectInvNotifyMessage* New() const final {
    return CreateMaybeMessage<RejectInvNotifyMessage>(nullptr);
  }

  RejectInvNotifyMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RejectInvNotifyMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RejectInvNotifyMessage& from);
  void MergeFrom(const RejectInvNotifyMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RejectInvNotifyMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required .RejectGameInvitationMessage.RejectGameInvReason playerRejectReason = 3;
  bool has_playerrejectreason() const;
  void clear_playerrejectreason();
  static const int kPlayerRejectReasonFieldNumber = 3;
  ::RejectGameInvitationMessage_RejectGameInvReason playerrejectreason() const;
  void set_playerrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value);

  // @@protoc_insertion_point(class_scope:RejectInvNotifyMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int playerrejectreason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class StartEventMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:StartEventMessage) */ {
 public:
  StartEventMessage();
  virtual ~StartEventMessage();

  StartEventMessage(const StartEventMessage& from);

  inline StartEventMessage& operator=(const StartEventMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartEventMessage(StartEventMessage&& from) noexcept
    : StartEventMessage() {
    *this = ::std::move(from);
  }

  inline StartEventMessage& operator=(StartEventMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const StartEventMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartEventMessage* internal_default_instance() {
    return reinterpret_cast<const StartEventMessage*>(
               &_StartEventMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(StartEventMessage* other);
  friend void swap(StartEventMessage& a, StartEventMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartEventMessage* New() const final {
    return CreateMaybeMessage<StartEventMessage>(nullptr);
  }

  StartEventMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StartEventMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const StartEventMessage& from);
  void MergeFrom(const StartEventMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartEventMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef StartEventMessage_StartEventType StartEventType;
  static const StartEventType startEvent =
    StartEventMessage_StartEventType_startEvent;
  static const StartEventType rejoinEvent =
    StartEventMessage_StartEventType_rejoinEvent;
  static inline bool StartEventType_IsValid(int value) {
    return StartEventMessage_StartEventType_IsValid(value);
  }
  static const StartEventType StartEventType_MIN =
    StartEventMessage_StartEventType_StartEventType_MIN;
  static const StartEventType StartEventType_MAX =
    StartEventMessage_StartEventType_StartEventType_MAX;
  static const int StartEventType_ARRAYSIZE =
    StartEventMessage_StartEventType_StartEventType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required .StartEventMessage.StartEventType startEventType = 2;
  bool has_starteventtype() const;
  void clear_starteventtype();
  static const int kStartEventTypeFieldNumber = 2;
  ::StartEventMessage_StartEventType starteventtype() const;
  void set_starteventtype(::StartEventMessage_StartEventType value);

  // optional bool fillWithComputerPlayers = 3;
  bool has_fillwithcomputerplayers() const;
  void clear_fillwithcomputerplayers();
  static const int kFillWithComputerPlayersFieldNumber = 3;
  bool fillwithcomputerplayers() const;
  void set_fillwithcomputerplayers(bool value);

  // @@protoc_insertion_point(class_scope:StartEventMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  int starteventtype_;
  bool fillwithcomputerplayers_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class StartEventAckMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:StartEventAckMessage) */ {
 public:
  StartEventAckMessage();
  virtual ~StartEventAckMessage();

  StartEventAckMessage(const StartEventAckMessage& from);

  inline StartEventAckMessage& operator=(const StartEventAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartEventAckMessage(StartEventAckMessage&& from) noexcept
    : StartEventAckMessage() {
    *this = ::std::move(from);
  }

  inline StartEventAckMessage& operator=(StartEventAckMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const StartEventAckMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartEventAckMessage* internal_default_instance() {
    return reinterpret_cast<const StartEventAckMessage*>(
               &_StartEventAckMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(StartEventAckMessage* other);
  friend void swap(StartEventAckMessage& a, StartEventAckMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartEventAckMessage* New() const final {
    return CreateMaybeMessage<StartEventAckMessage>(nullptr);
  }

  StartEventAckMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StartEventAckMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const StartEventAckMessage& from);
  void MergeFrom(const StartEventAckMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartEventAckMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:StartEventAckMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameStartInitialMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GameStartInitialMessage) */ {
 public:
  GameStartInitialMessage();
  virtual ~GameStartInitialMessage();

  GameStartInitialMessage(const GameStartInitialMessage& from);

  inline GameStartInitialMessage& operator=(const GameStartInitialMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameStartInitialMessage(GameStartInitialMessage&& from) noexcept
    : GameStartInitialMessage() {
    *this = ::std::move(from);
  }

  inline GameStartInitialMessage& operator=(GameStartInitialMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GameStartInitialMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameStartInitialMessage* internal_default_instance() {
    return reinterpret_cast<const GameStartInitialMessage*>(
               &_GameStartInitialMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(GameStartInitialMessage* other);
  friend void swap(GameStartInitialMessage& a, GameStartInitialMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameStartInitialMessage* New() const final {
    return CreateMaybeMessage<GameStartInitialMessage>(nullptr);
  }

  GameStartInitialMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameStartInitialMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GameStartInitialMessage& from);
  void MergeFrom(const GameStartInitialMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameStartInitialMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 playerSeats = 3 [packed = true];
  int playerseats_size() const;
  void clear_playerseats();
  static const int kPlayerSeatsFieldNumber = 3;
  ::google::protobuf::uint32 playerseats(int index) const;
  void set_playerseats(int index, ::google::protobuf::uint32 value);
  void add_playerseats(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      playerseats() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_playerseats();

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 startDealerPlayerId = 2;
  bool has_startdealerplayerid() const;
  void clear_startdealerplayerid();
  static const int kStartDealerPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 startdealerplayerid() const;
  void set_startdealerplayerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameStartInitialMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > playerseats_;
  mutable std::atomic<int> _playerseats_cached_byte_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 startdealerplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameStartRejoinMessage_RejoinPlayerData :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GameStartRejoinMessage.RejoinPlayerData) */ {
 public:
  GameStartRejoinMessage_RejoinPlayerData();
  virtual ~GameStartRejoinMessage_RejoinPlayerData();

  GameStartRejoinMessage_RejoinPlayerData(const GameStartRejoinMessage_RejoinPlayerData& from);

  inline GameStartRejoinMessage_RejoinPlayerData& operator=(const GameStartRejoinMessage_RejoinPlayerData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameStartRejoinMessage_RejoinPlayerData(GameStartRejoinMessage_RejoinPlayerData&& from) noexcept
    : GameStartRejoinMessage_RejoinPlayerData() {
    *this = ::std::move(from);
  }

  inline GameStartRejoinMessage_RejoinPlayerData& operator=(GameStartRejoinMessage_RejoinPlayerData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GameStartRejoinMessage_RejoinPlayerData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameStartRejoinMessage_RejoinPlayerData* internal_default_instance() {
    return reinterpret_cast<const GameStartRejoinMessage_RejoinPlayerData*>(
               &_GameStartRejoinMessage_RejoinPlayerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(GameStartRejoinMessage_RejoinPlayerData* other);
  friend void swap(GameStartRejoinMessage_RejoinPlayerData& a, GameStartRejoinMessage_RejoinPlayerData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameStartRejoinMessage_RejoinPlayerData* New() const final {
    return CreateMaybeMessage<GameStartRejoinMessage_RejoinPlayerData>(nullptr);
  }

  GameStartRejoinMessage_RejoinPlayerData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameStartRejoinMessage_RejoinPlayerData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GameStartRejoinMessage_RejoinPlayerData& from);
  void MergeFrom(const GameStartRejoinMessage_RejoinPlayerData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameStartRejoinMessage_RejoinPlayerData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 playerId = 1;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required uint32 playerMoney = 2;
  bool has_playermoney() const;
  void clear_playermoney();
  static const int kPlayerMoneyFieldNumber = 2;
  ::google::protobuf::uint32 playermoney() const;
  void set_playermoney(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameStartRejoinMessage.RejoinPlayerData)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 playermoney_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class GameStartRejoinMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:GameStartRejoinMessage) */ {
 public:
  GameStartRejoinMessage();
  virtual ~GameStartRejoinMessage();

  GameStartRejoinMessage(const GameStartRejoinMessage& from);

  inline GameStartRejoinMessage& operator=(const GameStartRejoinMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameStartRejoinMessage(GameStartRejoinMessage&& from) noexcept
    : GameStartRejoinMessage() {
    *this = ::std::move(from);
  }

  inline GameStartRejoinMessage& operator=(GameStartRejoinMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GameStartRejoinMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameStartRejoinMessage* internal_default_instance() {
    return reinterpret_cast<const GameStartRejoinMessage*>(
               &_GameStartRejoinMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(GameStartRejoinMessage* other);
  friend void swap(GameStartRejoinMessage& a, GameStartRejoinMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameStartRejoinMessage* New() const final {
    return CreateMaybeMessage<GameStartRejoinMessage>(nullptr);
  }

  GameStartRejoinMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameStartRejoinMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GameStartRejoinMessage& from);
  void MergeFrom(const GameStartRejoinMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameStartRejoinMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef GameStartRejoinMessage_RejoinPlayerData RejoinPlayerData;

  // accessors -------------------------------------------------------

  // repeated .GameStartRejoinMessage.RejoinPlayerData rejoinPlayerData = 4;
  int rejoinplayerdata_size() const;
  void clear_rejoinplayerdata();
  static const int kRejoinPlayerDataFieldNumber = 4;
  ::GameStartRejoinMessage_RejoinPlayerData* mutable_rejoinplayerdata(int index);
  ::google::protobuf::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData >*
      mutable_rejoinplayerdata();
  const ::GameStartRejoinMessage_RejoinPlayerData& rejoinplayerdata(int index) const;
  ::GameStartRejoinMessage_RejoinPlayerData* add_rejoinplayerdata();
  const ::google::protobuf::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData >&
      rejoinplayerdata() const;

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 startDealerPlayerId = 2;
  bool has_startdealerplayerid() const;
  void clear_startdealerplayerid();
  static const int kStartDealerPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 startdealerplayerid() const;
  void set_startdealerplayerid(::google::protobuf::uint32 value);

  // required uint32 handNum = 3;
  bool has_handnum() const;
  void clear_handnum();
  static const int kHandNumFieldNumber = 3;
  ::google::protobuf::uint32 handnum() const;
  void set_handnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GameStartRejoinMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData > rejoinplayerdata_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 startdealerplayerid_;
  ::google::protobuf::uint32 handnum_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class HandStartMessage_PlainCards :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:HandStartMessage.PlainCards) */ {
 public:
  HandStartMessage_PlainCards();
  virtual ~HandStartMessage_PlainCards();

  HandStartMessage_PlainCards(const HandStartMessage_PlainCards& from);

  inline HandStartMessage_PlainCards& operator=(const HandStartMessage_PlainCards& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HandStartMessage_PlainCards(HandStartMessage_PlainCards&& from) noexcept
    : HandStartMessage_PlainCards() {
    *this = ::std::move(from);
  }

  inline HandStartMessage_PlainCards& operator=(HandStartMessage_PlainCards&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const HandStartMessage_PlainCards& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HandStartMessage_PlainCards* internal_default_instance() {
    return reinterpret_cast<const HandStartMessage_PlainCards*>(
               &_HandStartMessage_PlainCards_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(HandStartMessage_PlainCards* other);
  friend void swap(HandStartMessage_PlainCards& a, HandStartMessage_PlainCards& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HandStartMessage_PlainCards* New() const final {
    return CreateMaybeMessage<HandStartMessage_PlainCards>(nullptr);
  }

  HandStartMessage_PlainCards* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HandStartMessage_PlainCards>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const HandStartMessage_PlainCards& from);
  void MergeFrom(const HandStartMessage_PlainCards& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HandStartMessage_PlainCards* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 plainCard1 = 1;
  bool has_plaincard1() const;
  void clear_plaincard1();
  static const int kPlainCard1FieldNumber = 1;
  ::google::protobuf::uint32 plaincard1() const;
  void set_plaincard1(::google::protobuf::uint32 value);

  // required uint32 plainCard2 = 2;
  bool has_plaincard2() const;
  void clear_plaincard2();
  static const int kPlainCard2FieldNumber = 2;
  ::google::protobuf::uint32 plaincard2() const;
  void set_plaincard2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:HandStartMessage.PlainCards)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 plaincard1_;
  ::google::protobuf::uint32 plaincard2_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class HandStartMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:HandStartMessage) */ {
 public:
  HandStartMessage();
  virtual ~HandStartMessage();

  HandStartMessage(const HandStartMessage& from);

  inline HandStartMessage& operator=(const HandStartMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HandStartMessage(HandStartMessage&& from) noexcept
    : HandStartMessage() {
    *this = ::std::move(from);
  }

  inline HandStartMessage& operator=(HandStartMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const HandStartMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HandStartMessage* internal_default_instance() {
    return reinterpret_cast<const HandStartMessage*>(
               &_HandStartMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(HandStartMessage* other);
  friend void swap(HandStartMessage& a, HandStartMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HandStartMessage* New() const final {
    return CreateMaybeMessage<HandStartMessage>(nullptr);
  }

  HandStartMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HandStartMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const HandStartMessage& from);
  void MergeFrom(const HandStartMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HandStartMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef HandStartMessage_PlainCards PlainCards;

  // accessors -------------------------------------------------------

  // repeated .NetPlayerState seatStates = 5;
  int seatstates_size() const;
  void clear_seatstates();
  static const int kSeatStatesFieldNumber = 5;
  ::NetPlayerState seatstates(int index) const;
  void set_seatstates(int index, ::NetPlayerState value);
  void add_seatstates(::NetPlayerState value);
  const ::google::protobuf::RepeatedField<int>& seatstates() const;
  ::google::protobuf::RepeatedField<int>* mutable_seatstates();

  // optional bytes encryptedCards = 3;
  bool has_encryptedcards() const;
  void clear_encryptedcards();
  static const int kEncryptedCardsFieldNumber = 3;
  const ::std::string& encryptedcards() const;
  void set_encryptedcards(const ::std::string& value);
  #if LANG_CXX11
  void set_encryptedcards(::std::string&& value);
  #endif
  void set_encryptedcards(const char* value);
  void set_encryptedcards(const void* value, size_t size);
  ::std::string* mutable_encryptedcards();
  ::std::string* release_encryptedcards();
  void set_allocated_encryptedcards(::std::string* encryptedcards);

  // optional .HandStartMessage.PlainCards plainCards = 2;
  bool has_plaincards() const;
  void clear_plaincards();
  static const int kPlainCardsFieldNumber = 2;
  const ::HandStartMessage_PlainCards& plaincards() const;
  ::HandStartMessage_PlainCards* release_plaincards();
  ::HandStartMessage_PlainCards* mutable_plaincards();
  void set_allocated_plaincards(::HandStartMessage_PlainCards* plaincards);

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 smallBlind = 4;
  bool has_smallblind() const;
  void clear_smallblind();
  static const int kSmallBlindFieldNumber = 4;
  ::google::protobuf::uint32 smallblind() const;
  void set_smallblind(::google::protobuf::uint32 value);

  // optional uint32 dealerPlayerId = 6;
  bool has_dealerplayerid() const;
  void clear_dealerplayerid();
  static const int kDealerPlayerIdFieldNumber = 6;
  ::google::protobuf::uint32 dealerplayerid() const;
  void set_dealerplayerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:HandStartMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> seatstates_;
  ::google::protobuf::internal::ArenaStringPtr encryptedcards_;
  ::HandStartMessage_PlainCards* plaincards_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 smallblind_;
  ::google::protobuf::uint32 dealerplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayersTurnMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PlayersTurnMessage) */ {
 public:
  PlayersTurnMessage();
  virtual ~PlayersTurnMessage();

  PlayersTurnMessage(const PlayersTurnMessage& from);

  inline PlayersTurnMessage& operator=(const PlayersTurnMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayersTurnMessage(PlayersTurnMessage&& from) noexcept
    : PlayersTurnMessage() {
    *this = ::std::move(from);
  }

  inline PlayersTurnMessage& operator=(PlayersTurnMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PlayersTurnMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayersTurnMessage* internal_default_instance() {
    return reinterpret_cast<const PlayersTurnMessage*>(
               &_PlayersTurnMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(PlayersTurnMessage* other);
  friend void swap(PlayersTurnMessage& a, PlayersTurnMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayersTurnMessage* New() const final {
    return CreateMaybeMessage<PlayersTurnMessage>(nullptr);
  }

  PlayersTurnMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayersTurnMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PlayersTurnMessage& from);
  void MergeFrom(const PlayersTurnMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayersTurnMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required .NetGameState gameState = 3;
  bool has_gamestate() const;
  void clear_gamestate();
  static const int kGameStateFieldNumber = 3;
  ::NetGameState gamestate() const;
  void set_gamestate(::NetGameState value);

  // @@protoc_insertion_point(class_scope:PlayersTurnMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int gamestate_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class MyActionRequestMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:MyActionRequestMessage) */ {
 public:
  MyActionRequestMessage();
  virtual ~MyActionRequestMessage();

  MyActionRequestMessage(const MyActionRequestMessage& from);

  inline MyActionRequestMessage& operator=(const MyActionRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MyActionRequestMessage(MyActionRequestMessage&& from) noexcept
    : MyActionRequestMessage() {
    *this = ::std::move(from);
  }

  inline MyActionRequestMessage& operator=(MyActionRequestMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MyActionRequestMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MyActionRequestMessage* internal_default_instance() {
    return reinterpret_cast<const MyActionRequestMessage*>(
               &_MyActionRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(MyActionRequestMessage* other);
  friend void swap(MyActionRequestMessage& a, MyActionRequestMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MyActionRequestMessage* New() const final {
    return CreateMaybeMessage<MyActionRequestMessage>(nullptr);
  }

  MyActionRequestMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MyActionRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const MyActionRequestMessage& from);
  void MergeFrom(const MyActionRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MyActionRequestMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 handNum = 2;
  bool has_handnum() const;
  void clear_handnum();
  static const int kHandNumFieldNumber = 2;
  ::google::protobuf::uint32 handnum() const;
  void set_handnum(::google::protobuf::uint32 value);

  // required .NetGameState gameState = 3;
  bool has_gamestate() const;
  void clear_gamestate();
  static const int kGameStateFieldNumber = 3;
  ::NetGameState gamestate() const;
  void set_gamestate(::NetGameState value);

  // required .NetPlayerAction myAction = 4;
  bool has_myaction() const;
  void clear_myaction();
  static const int kMyActionFieldNumber = 4;
  ::NetPlayerAction myaction() const;
  void set_myaction(::NetPlayerAction value);

  // required uint32 myRelativeBet = 5;
  bool has_myrelativebet() const;
  void clear_myrelativebet();
  static const int kMyRelativeBetFieldNumber = 5;
  ::google::protobuf::uint32 myrelativebet() const;
  void set_myrelativebet(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MyActionRequestMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 handnum_;
  int gamestate_;
  int myaction_;
  ::google::protobuf::uint32 myrelativebet_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class YourActionRejectedMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:YourActionRejectedMessage) */ {
 public:
  YourActionRejectedMessage();
  virtual ~YourActionRejectedMessage();

  YourActionRejectedMessage(const YourActionRejectedMessage& from);

  inline YourActionRejectedMessage& operator=(const YourActionRejectedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  YourActionRejectedMessage(YourActionRejectedMessage&& from) noexcept
    : YourActionRejectedMessage() {
    *this = ::std::move(from);
  }

  inline YourActionRejectedMessage& operator=(YourActionRejectedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const YourActionRejectedMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const YourActionRejectedMessage* internal_default_instance() {
    return reinterpret_cast<const YourActionRejectedMessage*>(
               &_YourActionRejectedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(YourActionRejectedMessage* other);
  friend void swap(YourActionRejectedMessage& a, YourActionRejectedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline YourActionRejectedMessage* New() const final {
    return CreateMaybeMessage<YourActionRejectedMessage>(nullptr);
  }

  YourActionRejectedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<YourActionRejectedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const YourActionRejectedMessage& from);
  void MergeFrom(const YourActionRejectedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YourActionRejectedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef YourActionRejectedMessage_RejectionReason RejectionReason;
  static const RejectionReason rejectedInvalidGameState =
    YourActionRejectedMessage_RejectionReason_rejectedInvalidGameState;
  static const RejectionReason rejectedNotYourTurn =
    YourActionRejectedMessage_RejectionReason_rejectedNotYourTurn;
  static const RejectionReason rejectedActionNotAllowed =
    YourActionRejectedMessage_RejectionReason_rejectedActionNotAllowed;
  static inline bool RejectionReason_IsValid(int value) {
    return YourActionRejectedMessage_RejectionReason_IsValid(value);
  }
  static const RejectionReason RejectionReason_MIN =
    YourActionRejectedMessage_RejectionReason_RejectionReason_MIN;
  static const RejectionReason RejectionReason_MAX =
    YourActionRejectedMessage_RejectionReason_RejectionReason_MAX;
  static const int RejectionReason_ARRAYSIZE =
    YourActionRejectedMessage_RejectionReason_RejectionReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required .NetGameState gameState = 2;
  bool has_gamestate() const;
  void clear_gamestate();
  static const int kGameStateFieldNumber = 2;
  ::NetGameState gamestate() const;
  void set_gamestate(::NetGameState value);

  // required .NetPlayerAction yourAction = 3;
  bool has_youraction() const;
  void clear_youraction();
  static const int kYourActionFieldNumber = 3;
  ::NetPlayerAction youraction() const;
  void set_youraction(::NetPlayerAction value);

  // required uint32 yourRelativeBet = 4;
  bool has_yourrelativebet() const;
  void clear_yourrelativebet();
  static const int kYourRelativeBetFieldNumber = 4;
  ::google::protobuf::uint32 yourrelativebet() const;
  void set_yourrelativebet(::google::protobuf::uint32 value);

  // required .YourActionRejectedMessage.RejectionReason rejectionReason = 5;
  bool has_rejectionreason() const;
  void clear_rejectionreason();
  static const int kRejectionReasonFieldNumber = 5;
  ::YourActionRejectedMessage_RejectionReason rejectionreason() const;
  void set_rejectionreason(::YourActionRejectedMessage_RejectionReason value);

  // @@protoc_insertion_point(class_scope:YourActionRejectedMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  int gamestate_;
  int youraction_;
  ::google::protobuf::uint32 yourrelativebet_;
  int rejectionreason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayersActionDoneMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PlayersActionDoneMessage) */ {
 public:
  PlayersActionDoneMessage();
  virtual ~PlayersActionDoneMessage();

  PlayersActionDoneMessage(const PlayersActionDoneMessage& from);

  inline PlayersActionDoneMessage& operator=(const PlayersActionDoneMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayersActionDoneMessage(PlayersActionDoneMessage&& from) noexcept
    : PlayersActionDoneMessage() {
    *this = ::std::move(from);
  }

  inline PlayersActionDoneMessage& operator=(PlayersActionDoneMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PlayersActionDoneMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayersActionDoneMessage* internal_default_instance() {
    return reinterpret_cast<const PlayersActionDoneMessage*>(
               &_PlayersActionDoneMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(PlayersActionDoneMessage* other);
  friend void swap(PlayersActionDoneMessage& a, PlayersActionDoneMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayersActionDoneMessage* New() const final {
    return CreateMaybeMessage<PlayersActionDoneMessage>(nullptr);
  }

  PlayersActionDoneMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayersActionDoneMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PlayersActionDoneMessage& from);
  void MergeFrom(const PlayersActionDoneMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayersActionDoneMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required .NetGameState gameState = 3;
  bool has_gamestate() const;
  void clear_gamestate();
  static const int kGameStateFieldNumber = 3;
  ::NetGameState gamestate() const;
  void set_gamestate(::NetGameState value);

  // required .NetPlayerAction playerAction = 4;
  bool has_playeraction() const;
  void clear_playeraction();
  static const int kPlayerActionFieldNumber = 4;
  ::NetPlayerAction playeraction() const;
  void set_playeraction(::NetPlayerAction value);

  // required uint32 totalPlayerBet = 5;
  bool has_totalplayerbet() const;
  void clear_totalplayerbet();
  static const int kTotalPlayerBetFieldNumber = 5;
  ::google::protobuf::uint32 totalplayerbet() const;
  void set_totalplayerbet(::google::protobuf::uint32 value);

  // required uint32 playerMoney = 6;
  bool has_playermoney() const;
  void clear_playermoney();
  static const int kPlayerMoneyFieldNumber = 6;
  ::google::protobuf::uint32 playermoney() const;
  void set_playermoney(::google::protobuf::uint32 value);

  // required uint32 highestSet = 7;
  bool has_highestset() const;
  void clear_highestset();
  static const int kHighestSetFieldNumber = 7;
  ::google::protobuf::uint32 highestset() const;
  void set_highestset(::google::protobuf::uint32 value);

  // required uint32 minimumRaise = 8;
  bool has_minimumraise() const;
  void clear_minimumraise();
  static const int kMinimumRaiseFieldNumber = 8;
  ::google::protobuf::uint32 minimumraise() const;
  void set_minimumraise(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PlayersActionDoneMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int gamestate_;
  int playeraction_;
  ::google::protobuf::uint32 totalplayerbet_;
  ::google::protobuf::uint32 playermoney_;
  ::google::protobuf::uint32 highestset_;
  ::google::protobuf::uint32 minimumraise_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class DealFlopCardsMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DealFlopCardsMessage) */ {
 public:
  DealFlopCardsMessage();
  virtual ~DealFlopCardsMessage();

  DealFlopCardsMessage(const DealFlopCardsMessage& from);

  inline DealFlopCardsMessage& operator=(const DealFlopCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DealFlopCardsMessage(DealFlopCardsMessage&& from) noexcept
    : DealFlopCardsMessage() {
    *this = ::std::move(from);
  }

  inline DealFlopCardsMessage& operator=(DealFlopCardsMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DealFlopCardsMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DealFlopCardsMessage* internal_default_instance() {
    return reinterpret_cast<const DealFlopCardsMessage*>(
               &_DealFlopCardsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(DealFlopCardsMessage* other);
  friend void swap(DealFlopCardsMessage& a, DealFlopCardsMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DealFlopCardsMessage* New() const final {
    return CreateMaybeMessage<DealFlopCardsMessage>(nullptr);
  }

  DealFlopCardsMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DealFlopCardsMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DealFlopCardsMessage& from);
  void MergeFrom(const DealFlopCardsMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DealFlopCardsMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 flopCard1 = 2;
  bool has_flopcard1() const;
  void clear_flopcard1();
  static const int kFlopCard1FieldNumber = 2;
  ::google::protobuf::uint32 flopcard1() const;
  void set_flopcard1(::google::protobuf::uint32 value);

  // required uint32 flopCard2 = 3;
  bool has_flopcard2() const;
  void clear_flopcard2();
  static const int kFlopCard2FieldNumber = 3;
  ::google::protobuf::uint32 flopcard2() const;
  void set_flopcard2(::google::protobuf::uint32 value);

  // required uint32 flopCard3 = 4;
  bool has_flopcard3() const;
  void clear_flopcard3();
  static const int kFlopCard3FieldNumber = 4;
  ::google::protobuf::uint32 flopcard3() const;
  void set_flopcard3(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DealFlopCardsMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 flopcard1_;
  ::google::protobuf::uint32 flopcard2_;
  ::google::protobuf::uint32 flopcard3_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class DealTurnCardMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DealTurnCardMessage) */ {
 public:
  DealTurnCardMessage();
  virtual ~DealTurnCardMessage();

  DealTurnCardMessage(const DealTurnCardMessage& from);

  inline DealTurnCardMessage& operator=(const DealTurnCardMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DealTurnCardMessage(DealTurnCardMessage&& from) noexcept
    : DealTurnCardMessage() {
    *this = ::std::move(from);
  }

  inline DealTurnCardMessage& operator=(DealTurnCardMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DealTurnCardMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DealTurnCardMessage* internal_default_instance() {
    return reinterpret_cast<const DealTurnCardMessage*>(
               &_DealTurnCardMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(DealTurnCardMessage* other);
  friend void swap(DealTurnCardMessage& a, DealTurnCardMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DealTurnCardMessage* New() const final {
    return CreateMaybeMessage<DealTurnCardMessage>(nullptr);
  }

  DealTurnCardMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DealTurnCardMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DealTurnCardMessage& from);
  void MergeFrom(const DealTurnCardMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DealTurnCardMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 turnCard = 2;
  bool has_turncard() const;
  void clear_turncard();
  static const int kTurnCardFieldNumber = 2;
  ::google::protobuf::uint32 turncard() const;
  void set_turncard(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DealTurnCardMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 turncard_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class DealRiverCardMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DealRiverCardMessage) */ {
 public:
  DealRiverCardMessage();
  virtual ~DealRiverCardMessage();

  DealRiverCardMessage(const DealRiverCardMessage& from);

  inline DealRiverCardMessage& operator=(const DealRiverCardMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DealRiverCardMessage(DealRiverCardMessage&& from) noexcept
    : DealRiverCardMessage() {
    *this = ::std::move(from);
  }

  inline DealRiverCardMessage& operator=(DealRiverCardMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DealRiverCardMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DealRiverCardMessage* internal_default_instance() {
    return reinterpret_cast<const DealRiverCardMessage*>(
               &_DealRiverCardMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  void Swap(DealRiverCardMessage* other);
  friend void swap(DealRiverCardMessage& a, DealRiverCardMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DealRiverCardMessage* New() const final {
    return CreateMaybeMessage<DealRiverCardMessage>(nullptr);
  }

  DealRiverCardMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DealRiverCardMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DealRiverCardMessage& from);
  void MergeFrom(const DealRiverCardMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DealRiverCardMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 riverCard = 2;
  bool has_rivercard() const;
  void clear_rivercard();
  static const int kRiverCardFieldNumber = 2;
  ::google::protobuf::uint32 rivercard() const;
  void set_rivercard(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DealRiverCardMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 rivercard_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AllInShowCardsMessage_PlayerAllIn :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AllInShowCardsMessage.PlayerAllIn) */ {
 public:
  AllInShowCardsMessage_PlayerAllIn();
  virtual ~AllInShowCardsMessage_PlayerAllIn();

  AllInShowCardsMessage_PlayerAllIn(const AllInShowCardsMessage_PlayerAllIn& from);

  inline AllInShowCardsMessage_PlayerAllIn& operator=(const AllInShowCardsMessage_PlayerAllIn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AllInShowCardsMessage_PlayerAllIn(AllInShowCardsMessage_PlayerAllIn&& from) noexcept
    : AllInShowCardsMessage_PlayerAllIn() {
    *this = ::std::move(from);
  }

  inline AllInShowCardsMessage_PlayerAllIn& operator=(AllInShowCardsMessage_PlayerAllIn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AllInShowCardsMessage_PlayerAllIn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllInShowCardsMessage_PlayerAllIn* internal_default_instance() {
    return reinterpret_cast<const AllInShowCardsMessage_PlayerAllIn*>(
               &_AllInShowCardsMessage_PlayerAllIn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  void Swap(AllInShowCardsMessage_PlayerAllIn* other);
  friend void swap(AllInShowCardsMessage_PlayerAllIn& a, AllInShowCardsMessage_PlayerAllIn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AllInShowCardsMessage_PlayerAllIn* New() const final {
    return CreateMaybeMessage<AllInShowCardsMessage_PlayerAllIn>(nullptr);
  }

  AllInShowCardsMessage_PlayerAllIn* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AllInShowCardsMessage_PlayerAllIn>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AllInShowCardsMessage_PlayerAllIn& from);
  void MergeFrom(const AllInShowCardsMessage_PlayerAllIn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AllInShowCardsMessage_PlayerAllIn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 playerId = 1;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required uint32 allInCard1 = 2;
  bool has_allincard1() const;
  void clear_allincard1();
  static const int kAllInCard1FieldNumber = 2;
  ::google::protobuf::uint32 allincard1() const;
  void set_allincard1(::google::protobuf::uint32 value);

  // required uint32 allInCard2 = 3;
  bool has_allincard2() const;
  void clear_allincard2();
  static const int kAllInCard2FieldNumber = 3;
  ::google::protobuf::uint32 allincard2() const;
  void set_allincard2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AllInShowCardsMessage.PlayerAllIn)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 allincard1_;
  ::google::protobuf::uint32 allincard2_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AllInShowCardsMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AllInShowCardsMessage) */ {
 public:
  AllInShowCardsMessage();
  virtual ~AllInShowCardsMessage();

  AllInShowCardsMessage(const AllInShowCardsMessage& from);

  inline AllInShowCardsMessage& operator=(const AllInShowCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AllInShowCardsMessage(AllInShowCardsMessage&& from) noexcept
    : AllInShowCardsMessage() {
    *this = ::std::move(from);
  }

  inline AllInShowCardsMessage& operator=(AllInShowCardsMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AllInShowCardsMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllInShowCardsMessage* internal_default_instance() {
    return reinterpret_cast<const AllInShowCardsMessage*>(
               &_AllInShowCardsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  void Swap(AllInShowCardsMessage* other);
  friend void swap(AllInShowCardsMessage& a, AllInShowCardsMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AllInShowCardsMessage* New() const final {
    return CreateMaybeMessage<AllInShowCardsMessage>(nullptr);
  }

  AllInShowCardsMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AllInShowCardsMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AllInShowCardsMessage& from);
  void MergeFrom(const AllInShowCardsMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AllInShowCardsMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AllInShowCardsMessage_PlayerAllIn PlayerAllIn;

  // accessors -------------------------------------------------------

  // repeated .AllInShowCardsMessage.PlayerAllIn playersAllIn = 2;
  int playersallin_size() const;
  void clear_playersallin();
  static const int kPlayersAllInFieldNumber = 2;
  ::AllInShowCardsMessage_PlayerAllIn* mutable_playersallin(int index);
  ::google::protobuf::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn >*
      mutable_playersallin();
  const ::AllInShowCardsMessage_PlayerAllIn& playersallin(int index) const;
  ::AllInShowCardsMessage_PlayerAllIn* add_playersallin();
  const ::google::protobuf::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn >&
      playersallin() const;

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AllInShowCardsMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn > playersallin_;
  ::google::protobuf::uint32 gameid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class EndOfHandShowCardsMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:EndOfHandShowCardsMessage) */ {
 public:
  EndOfHandShowCardsMessage();
  virtual ~EndOfHandShowCardsMessage();

  EndOfHandShowCardsMessage(const EndOfHandShowCardsMessage& from);

  inline EndOfHandShowCardsMessage& operator=(const EndOfHandShowCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EndOfHandShowCardsMessage(EndOfHandShowCardsMessage&& from) noexcept
    : EndOfHandShowCardsMessage() {
    *this = ::std::move(from);
  }

  inline EndOfHandShowCardsMessage& operator=(EndOfHandShowCardsMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const EndOfHandShowCardsMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EndOfHandShowCardsMessage* internal_default_instance() {
    return reinterpret_cast<const EndOfHandShowCardsMessage*>(
               &_EndOfHandShowCardsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  void Swap(EndOfHandShowCardsMessage* other);
  friend void swap(EndOfHandShowCardsMessage& a, EndOfHandShowCardsMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EndOfHandShowCardsMessage* New() const final {
    return CreateMaybeMessage<EndOfHandShowCardsMessage>(nullptr);
  }

  EndOfHandShowCardsMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EndOfHandShowCardsMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const EndOfHandShowCardsMessage& from);
  void MergeFrom(const EndOfHandShowCardsMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EndOfHandShowCardsMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerResult playerResults = 2;
  int playerresults_size() const;
  void clear_playerresults();
  static const int kPlayerResultsFieldNumber = 2;
  ::PlayerResult* mutable_playerresults(int index);
  ::google::protobuf::RepeatedPtrField< ::PlayerResult >*
      mutable_playerresults();
  const ::PlayerResult& playerresults(int index) const;
  ::PlayerResult* add_playerresults();
  const ::google::protobuf::RepeatedPtrField< ::PlayerResult >&
      playerresults() const;

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:EndOfHandShowCardsMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PlayerResult > playerresults_;
  ::google::protobuf::uint32 gameid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class EndOfHandHideCardsMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:EndOfHandHideCardsMessage) */ {
 public:
  EndOfHandHideCardsMessage();
  virtual ~EndOfHandHideCardsMessage();

  EndOfHandHideCardsMessage(const EndOfHandHideCardsMessage& from);

  inline EndOfHandHideCardsMessage& operator=(const EndOfHandHideCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EndOfHandHideCardsMessage(EndOfHandHideCardsMessage&& from) noexcept
    : EndOfHandHideCardsMessage() {
    *this = ::std::move(from);
  }

  inline EndOfHandHideCardsMessage& operator=(EndOfHandHideCardsMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const EndOfHandHideCardsMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EndOfHandHideCardsMessage* internal_default_instance() {
    return reinterpret_cast<const EndOfHandHideCardsMessage*>(
               &_EndOfHandHideCardsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  void Swap(EndOfHandHideCardsMessage* other);
  friend void swap(EndOfHandHideCardsMessage& a, EndOfHandHideCardsMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EndOfHandHideCardsMessage* New() const final {
    return CreateMaybeMessage<EndOfHandHideCardsMessage>(nullptr);
  }

  EndOfHandHideCardsMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EndOfHandHideCardsMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const EndOfHandHideCardsMessage& from);
  void MergeFrom(const EndOfHandHideCardsMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EndOfHandHideCardsMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required uint32 moneyWon = 3;
  bool has_moneywon() const;
  void clear_moneywon();
  static const int kMoneyWonFieldNumber = 3;
  ::google::protobuf::uint32 moneywon() const;
  void set_moneywon(::google::protobuf::uint32 value);

  // required uint32 playerMoney = 4;
  bool has_playermoney() const;
  void clear_playermoney();
  static const int kPlayerMoneyFieldNumber = 4;
  ::google::protobuf::uint32 playermoney() const;
  void set_playermoney(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:EndOfHandHideCardsMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 moneywon_;
  ::google::protobuf::uint32 playermoney_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ShowMyCardsRequestMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ShowMyCardsRequestMessage) */ {
 public:
  ShowMyCardsRequestMessage();
  virtual ~ShowMyCardsRequestMessage();

  ShowMyCardsRequestMessage(const ShowMyCardsRequestMessage& from);

  inline ShowMyCardsRequestMessage& operator=(const ShowMyCardsRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShowMyCardsRequestMessage(ShowMyCardsRequestMessage&& from) noexcept
    : ShowMyCardsRequestMessage() {
    *this = ::std::move(from);
  }

  inline ShowMyCardsRequestMessage& operator=(ShowMyCardsRequestMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ShowMyCardsRequestMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShowMyCardsRequestMessage* internal_default_instance() {
    return reinterpret_cast<const ShowMyCardsRequestMessage*>(
               &_ShowMyCardsRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  void Swap(ShowMyCardsRequestMessage* other);
  friend void swap(ShowMyCardsRequestMessage& a, ShowMyCardsRequestMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShowMyCardsRequestMessage* New() const final {
    return CreateMaybeMessage<ShowMyCardsRequestMessage>(nullptr);
  }

  ShowMyCardsRequestMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShowMyCardsRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ShowMyCardsRequestMessage& from);
  void MergeFrom(const ShowMyCardsRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowMyCardsRequestMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ShowMyCardsRequestMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AfterHandShowCardsMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AfterHandShowCardsMessage) */ {
 public:
  AfterHandShowCardsMessage();
  virtual ~AfterHandShowCardsMessage();

  AfterHandShowCardsMessage(const AfterHandShowCardsMessage& from);

  inline AfterHandShowCardsMessage& operator=(const AfterHandShowCardsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AfterHandShowCardsMessage(AfterHandShowCardsMessage&& from) noexcept
    : AfterHandShowCardsMessage() {
    *this = ::std::move(from);
  }

  inline AfterHandShowCardsMessage& operator=(AfterHandShowCardsMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AfterHandShowCardsMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AfterHandShowCardsMessage* internal_default_instance() {
    return reinterpret_cast<const AfterHandShowCardsMessage*>(
               &_AfterHandShowCardsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  void Swap(AfterHandShowCardsMessage* other);
  friend void swap(AfterHandShowCardsMessage& a, AfterHandShowCardsMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AfterHandShowCardsMessage* New() const final {
    return CreateMaybeMessage<AfterHandShowCardsMessage>(nullptr);
  }

  AfterHandShowCardsMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AfterHandShowCardsMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AfterHandShowCardsMessage& from);
  void MergeFrom(const AfterHandShowCardsMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AfterHandShowCardsMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PlayerResult playerResult = 1;
  bool has_playerresult() const;
  void clear_playerresult();
  static const int kPlayerResultFieldNumber = 1;
  const ::PlayerResult& playerresult() const;
  ::PlayerResult* release_playerresult();
  ::PlayerResult* mutable_playerresult();
  void set_allocated_playerresult(::PlayerResult* playerresult);

  // @@protoc_insertion_point(class_scope:AfterHandShowCardsMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::PlayerResult* playerresult_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class EndOfGameMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:EndOfGameMessage) */ {
 public:
  EndOfGameMessage();
  virtual ~EndOfGameMessage();

  EndOfGameMessage(const EndOfGameMessage& from);

  inline EndOfGameMessage& operator=(const EndOfGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EndOfGameMessage(EndOfGameMessage&& from) noexcept
    : EndOfGameMessage() {
    *this = ::std::move(from);
  }

  inline EndOfGameMessage& operator=(EndOfGameMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const EndOfGameMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EndOfGameMessage* internal_default_instance() {
    return reinterpret_cast<const EndOfGameMessage*>(
               &_EndOfGameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  void Swap(EndOfGameMessage* other);
  friend void swap(EndOfGameMessage& a, EndOfGameMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EndOfGameMessage* New() const final {
    return CreateMaybeMessage<EndOfGameMessage>(nullptr);
  }

  EndOfGameMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EndOfGameMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const EndOfGameMessage& from);
  void MergeFrom(const EndOfGameMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EndOfGameMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 winnerPlayerId = 2;
  bool has_winnerplayerid() const;
  void clear_winnerplayerid();
  static const int kWinnerPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 winnerplayerid() const;
  void set_winnerplayerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:EndOfGameMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 winnerplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PlayerIdChangedMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PlayerIdChangedMessage) */ {
 public:
  PlayerIdChangedMessage();
  virtual ~PlayerIdChangedMessage();

  PlayerIdChangedMessage(const PlayerIdChangedMessage& from);

  inline PlayerIdChangedMessage& operator=(const PlayerIdChangedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerIdChangedMessage(PlayerIdChangedMessage&& from) noexcept
    : PlayerIdChangedMessage() {
    *this = ::std::move(from);
  }

  inline PlayerIdChangedMessage& operator=(PlayerIdChangedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PlayerIdChangedMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerIdChangedMessage* internal_default_instance() {
    return reinterpret_cast<const PlayerIdChangedMessage*>(
               &_PlayerIdChangedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  void Swap(PlayerIdChangedMessage* other);
  friend void swap(PlayerIdChangedMessage& a, PlayerIdChangedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerIdChangedMessage* New() const final {
    return CreateMaybeMessage<PlayerIdChangedMessage>(nullptr);
  }

  PlayerIdChangedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerIdChangedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PlayerIdChangedMessage& from);
  void MergeFrom(const PlayerIdChangedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerIdChangedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 oldPlayerId = 1;
  bool has_oldplayerid() const;
  void clear_oldplayerid();
  static const int kOldPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 oldplayerid() const;
  void set_oldplayerid(::google::protobuf::uint32 value);

  // required uint32 newPlayerId = 2;
  bool has_newplayerid() const;
  void clear_newplayerid();
  static const int kNewPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 newplayerid() const;
  void set_newplayerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PlayerIdChangedMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 oldplayerid_;
  ::google::protobuf::uint32 newplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AskKickPlayerMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AskKickPlayerMessage) */ {
 public:
  AskKickPlayerMessage();
  virtual ~AskKickPlayerMessage();

  AskKickPlayerMessage(const AskKickPlayerMessage& from);

  inline AskKickPlayerMessage& operator=(const AskKickPlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AskKickPlayerMessage(AskKickPlayerMessage&& from) noexcept
    : AskKickPlayerMessage() {
    *this = ::std::move(from);
  }

  inline AskKickPlayerMessage& operator=(AskKickPlayerMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AskKickPlayerMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AskKickPlayerMessage* internal_default_instance() {
    return reinterpret_cast<const AskKickPlayerMessage*>(
               &_AskKickPlayerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  void Swap(AskKickPlayerMessage* other);
  friend void swap(AskKickPlayerMessage& a, AskKickPlayerMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AskKickPlayerMessage* New() const final {
    return CreateMaybeMessage<AskKickPlayerMessage>(nullptr);
  }

  AskKickPlayerMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AskKickPlayerMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AskKickPlayerMessage& from);
  void MergeFrom(const AskKickPlayerMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AskKickPlayerMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AskKickPlayerMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AskKickDeniedMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AskKickDeniedMessage) */ {
 public:
  AskKickDeniedMessage();
  virtual ~AskKickDeniedMessage();

  AskKickDeniedMessage(const AskKickDeniedMessage& from);

  inline AskKickDeniedMessage& operator=(const AskKickDeniedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AskKickDeniedMessage(AskKickDeniedMessage&& from) noexcept
    : AskKickDeniedMessage() {
    *this = ::std::move(from);
  }

  inline AskKickDeniedMessage& operator=(AskKickDeniedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AskKickDeniedMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AskKickDeniedMessage* internal_default_instance() {
    return reinterpret_cast<const AskKickDeniedMessage*>(
               &_AskKickDeniedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  void Swap(AskKickDeniedMessage* other);
  friend void swap(AskKickDeniedMessage& a, AskKickDeniedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AskKickDeniedMessage* New() const final {
    return CreateMaybeMessage<AskKickDeniedMessage>(nullptr);
  }

  AskKickDeniedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AskKickDeniedMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AskKickDeniedMessage& from);
  void MergeFrom(const AskKickDeniedMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AskKickDeniedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AskKickDeniedMessage_KickDeniedReason KickDeniedReason;
  static const KickDeniedReason kickDeniedInvalidGameState =
    AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidGameState;
  static const KickDeniedReason kickDeniedNotPossible =
    AskKickDeniedMessage_KickDeniedReason_kickDeniedNotPossible;
  static const KickDeniedReason kickDeniedTryAgainLater =
    AskKickDeniedMessage_KickDeniedReason_kickDeniedTryAgainLater;
  static const KickDeniedReason kickDeniedAlreadyInProgress =
    AskKickDeniedMessage_KickDeniedReason_kickDeniedAlreadyInProgress;
  static const KickDeniedReason kickDeniedInvalidPlayerId =
    AskKickDeniedMessage_KickDeniedReason_kickDeniedInvalidPlayerId;
  static inline bool KickDeniedReason_IsValid(int value) {
    return AskKickDeniedMessage_KickDeniedReason_IsValid(value);
  }
  static const KickDeniedReason KickDeniedReason_MIN =
    AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MIN;
  static const KickDeniedReason KickDeniedReason_MAX =
    AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_MAX;
  static const int KickDeniedReason_ARRAYSIZE =
    AskKickDeniedMessage_KickDeniedReason_KickDeniedReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required .AskKickDeniedMessage.KickDeniedReason kickDeniedReason = 3;
  bool has_kickdeniedreason() const;
  void clear_kickdeniedreason();
  static const int kKickDeniedReasonFieldNumber = 3;
  ::AskKickDeniedMessage_KickDeniedReason kickdeniedreason() const;
  void set_kickdeniedreason(::AskKickDeniedMessage_KickDeniedReason value);

  // @@protoc_insertion_point(class_scope:AskKickDeniedMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int kickdeniedreason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class StartKickPetitionMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:StartKickPetitionMessage) */ {
 public:
  StartKickPetitionMessage();
  virtual ~StartKickPetitionMessage();

  StartKickPetitionMessage(const StartKickPetitionMessage& from);

  inline StartKickPetitionMessage& operator=(const StartKickPetitionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartKickPetitionMessage(StartKickPetitionMessage&& from) noexcept
    : StartKickPetitionMessage() {
    *this = ::std::move(from);
  }

  inline StartKickPetitionMessage& operator=(StartKickPetitionMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const StartKickPetitionMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartKickPetitionMessage* internal_default_instance() {
    return reinterpret_cast<const StartKickPetitionMessage*>(
               &_StartKickPetitionMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  void Swap(StartKickPetitionMessage* other);
  friend void swap(StartKickPetitionMessage& a, StartKickPetitionMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartKickPetitionMessage* New() const final {
    return CreateMaybeMessage<StartKickPetitionMessage>(nullptr);
  }

  StartKickPetitionMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StartKickPetitionMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const StartKickPetitionMessage& from);
  void MergeFrom(const StartKickPetitionMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartKickPetitionMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 petitionId = 2;
  bool has_petitionid() const;
  void clear_petitionid();
  static const int kPetitionIdFieldNumber = 2;
  ::google::protobuf::uint32 petitionid() const;
  void set_petitionid(::google::protobuf::uint32 value);

  // required uint32 proposingPlayerId = 3;
  bool has_proposingplayerid() const;
  void clear_proposingplayerid();
  static const int kProposingPlayerIdFieldNumber = 3;
  ::google::protobuf::uint32 proposingplayerid() const;
  void set_proposingplayerid(::google::protobuf::uint32 value);

  // required uint32 kickPlayerId = 4;
  bool has_kickplayerid() const;
  void clear_kickplayerid();
  static const int kKickPlayerIdFieldNumber = 4;
  ::google::protobuf::uint32 kickplayerid() const;
  void set_kickplayerid(::google::protobuf::uint32 value);

  // required uint32 kickTimeoutSec = 5;
  bool has_kicktimeoutsec() const;
  void clear_kicktimeoutsec();
  static const int kKickTimeoutSecFieldNumber = 5;
  ::google::protobuf::uint32 kicktimeoutsec() const;
  void set_kicktimeoutsec(::google::protobuf::uint32 value);

  // required uint32 numVotesNeededToKick = 6;
  bool has_numvotesneededtokick() const;
  void clear_numvotesneededtokick();
  static const int kNumVotesNeededToKickFieldNumber = 6;
  ::google::protobuf::uint32 numvotesneededtokick() const;
  void set_numvotesneededtokick(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:StartKickPetitionMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 petitionid_;
  ::google::protobuf::uint32 proposingplayerid_;
  ::google::protobuf::uint32 kickplayerid_;
  ::google::protobuf::uint32 kicktimeoutsec_;
  ::google::protobuf::uint32 numvotesneededtokick_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class VoteKickRequestMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:VoteKickRequestMessage) */ {
 public:
  VoteKickRequestMessage();
  virtual ~VoteKickRequestMessage();

  VoteKickRequestMessage(const VoteKickRequestMessage& from);

  inline VoteKickRequestMessage& operator=(const VoteKickRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VoteKickRequestMessage(VoteKickRequestMessage&& from) noexcept
    : VoteKickRequestMessage() {
    *this = ::std::move(from);
  }

  inline VoteKickRequestMessage& operator=(VoteKickRequestMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VoteKickRequestMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VoteKickRequestMessage* internal_default_instance() {
    return reinterpret_cast<const VoteKickRequestMessage*>(
               &_VoteKickRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  void Swap(VoteKickRequestMessage* other);
  friend void swap(VoteKickRequestMessage& a, VoteKickRequestMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VoteKickRequestMessage* New() const final {
    return CreateMaybeMessage<VoteKickRequestMessage>(nullptr);
  }

  VoteKickRequestMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VoteKickRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const VoteKickRequestMessage& from);
  void MergeFrom(const VoteKickRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VoteKickRequestMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 petitionId = 2;
  bool has_petitionid() const;
  void clear_petitionid();
  static const int kPetitionIdFieldNumber = 2;
  ::google::protobuf::uint32 petitionid() const;
  void set_petitionid(::google::protobuf::uint32 value);

  // required bool voteKick = 3;
  bool has_votekick() const;
  void clear_votekick();
  static const int kVoteKickFieldNumber = 3;
  bool votekick() const;
  void set_votekick(bool value);

  // @@protoc_insertion_point(class_scope:VoteKickRequestMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 petitionid_;
  bool votekick_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class VoteKickReplyMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:VoteKickReplyMessage) */ {
 public:
  VoteKickReplyMessage();
  virtual ~VoteKickReplyMessage();

  VoteKickReplyMessage(const VoteKickReplyMessage& from);

  inline VoteKickReplyMessage& operator=(const VoteKickReplyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VoteKickReplyMessage(VoteKickReplyMessage&& from) noexcept
    : VoteKickReplyMessage() {
    *this = ::std::move(from);
  }

  inline VoteKickReplyMessage& operator=(VoteKickReplyMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VoteKickReplyMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VoteKickReplyMessage* internal_default_instance() {
    return reinterpret_cast<const VoteKickReplyMessage*>(
               &_VoteKickReplyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  void Swap(VoteKickReplyMessage* other);
  friend void swap(VoteKickReplyMessage& a, VoteKickReplyMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VoteKickReplyMessage* New() const final {
    return CreateMaybeMessage<VoteKickReplyMessage>(nullptr);
  }

  VoteKickReplyMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VoteKickReplyMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const VoteKickReplyMessage& from);
  void MergeFrom(const VoteKickReplyMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VoteKickReplyMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef VoteKickReplyMessage_VoteKickReplyType VoteKickReplyType;
  static const VoteKickReplyType voteKickAck =
    VoteKickReplyMessage_VoteKickReplyType_voteKickAck;
  static const VoteKickReplyType voteKickDeniedInvalid =
    VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedInvalid;
  static const VoteKickReplyType voteKickDeniedAlreadyVoted =
    VoteKickReplyMessage_VoteKickReplyType_voteKickDeniedAlreadyVoted;
  static inline bool VoteKickReplyType_IsValid(int value) {
    return VoteKickReplyMessage_VoteKickReplyType_IsValid(value);
  }
  static const VoteKickReplyType VoteKickReplyType_MIN =
    VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MIN;
  static const VoteKickReplyType VoteKickReplyType_MAX =
    VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_MAX;
  static const int VoteKickReplyType_ARRAYSIZE =
    VoteKickReplyMessage_VoteKickReplyType_VoteKickReplyType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 petitionId = 2;
  bool has_petitionid() const;
  void clear_petitionid();
  static const int kPetitionIdFieldNumber = 2;
  ::google::protobuf::uint32 petitionid() const;
  void set_petitionid(::google::protobuf::uint32 value);

  // required .VoteKickReplyMessage.VoteKickReplyType voteKickReplyType = 3;
  bool has_votekickreplytype() const;
  void clear_votekickreplytype();
  static const int kVoteKickReplyTypeFieldNumber = 3;
  ::VoteKickReplyMessage_VoteKickReplyType votekickreplytype() const;
  void set_votekickreplytype(::VoteKickReplyMessage_VoteKickReplyType value);

  // @@protoc_insertion_point(class_scope:VoteKickReplyMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 petitionid_;
  int votekickreplytype_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class KickPetitionUpdateMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:KickPetitionUpdateMessage) */ {
 public:
  KickPetitionUpdateMessage();
  virtual ~KickPetitionUpdateMessage();

  KickPetitionUpdateMessage(const KickPetitionUpdateMessage& from);

  inline KickPetitionUpdateMessage& operator=(const KickPetitionUpdateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KickPetitionUpdateMessage(KickPetitionUpdateMessage&& from) noexcept
    : KickPetitionUpdateMessage() {
    *this = ::std::move(from);
  }

  inline KickPetitionUpdateMessage& operator=(KickPetitionUpdateMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const KickPetitionUpdateMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KickPetitionUpdateMessage* internal_default_instance() {
    return reinterpret_cast<const KickPetitionUpdateMessage*>(
               &_KickPetitionUpdateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  void Swap(KickPetitionUpdateMessage* other);
  friend void swap(KickPetitionUpdateMessage& a, KickPetitionUpdateMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KickPetitionUpdateMessage* New() const final {
    return CreateMaybeMessage<KickPetitionUpdateMessage>(nullptr);
  }

  KickPetitionUpdateMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KickPetitionUpdateMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const KickPetitionUpdateMessage& from);
  void MergeFrom(const KickPetitionUpdateMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KickPetitionUpdateMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 petitionId = 2;
  bool has_petitionid() const;
  void clear_petitionid();
  static const int kPetitionIdFieldNumber = 2;
  ::google::protobuf::uint32 petitionid() const;
  void set_petitionid(::google::protobuf::uint32 value);

  // required uint32 numVotesAgainstKicking = 3;
  bool has_numvotesagainstkicking() const;
  void clear_numvotesagainstkicking();
  static const int kNumVotesAgainstKickingFieldNumber = 3;
  ::google::protobuf::uint32 numvotesagainstkicking() const;
  void set_numvotesagainstkicking(::google::protobuf::uint32 value);

  // required uint32 numVotesInFavourOfKicking = 4;
  bool has_numvotesinfavourofkicking() const;
  void clear_numvotesinfavourofkicking();
  static const int kNumVotesInFavourOfKickingFieldNumber = 4;
  ::google::protobuf::uint32 numvotesinfavourofkicking() const;
  void set_numvotesinfavourofkicking(::google::protobuf::uint32 value);

  // required uint32 numVotesNeededToKick = 5;
  bool has_numvotesneededtokick() const;
  void clear_numvotesneededtokick();
  static const int kNumVotesNeededToKickFieldNumber = 5;
  ::google::protobuf::uint32 numvotesneededtokick() const;
  void set_numvotesneededtokick(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:KickPetitionUpdateMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 petitionid_;
  ::google::protobuf::uint32 numvotesagainstkicking_;
  ::google::protobuf::uint32 numvotesinfavourofkicking_;
  ::google::protobuf::uint32 numvotesneededtokick_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class EndKickPetitionMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:EndKickPetitionMessage) */ {
 public:
  EndKickPetitionMessage();
  virtual ~EndKickPetitionMessage();

  EndKickPetitionMessage(const EndKickPetitionMessage& from);

  inline EndKickPetitionMessage& operator=(const EndKickPetitionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EndKickPetitionMessage(EndKickPetitionMessage&& from) noexcept
    : EndKickPetitionMessage() {
    *this = ::std::move(from);
  }

  inline EndKickPetitionMessage& operator=(EndKickPetitionMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const EndKickPetitionMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EndKickPetitionMessage* internal_default_instance() {
    return reinterpret_cast<const EndKickPetitionMessage*>(
               &_EndKickPetitionMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  void Swap(EndKickPetitionMessage* other);
  friend void swap(EndKickPetitionMessage& a, EndKickPetitionMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EndKickPetitionMessage* New() const final {
    return CreateMaybeMessage<EndKickPetitionMessage>(nullptr);
  }

  EndKickPetitionMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EndKickPetitionMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const EndKickPetitionMessage& from);
  void MergeFrom(const EndKickPetitionMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EndKickPetitionMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef EndKickPetitionMessage_PetitionEndReason PetitionEndReason;
  static const PetitionEndReason petitionEndEnoughVotes =
    EndKickPetitionMessage_PetitionEndReason_petitionEndEnoughVotes;
  static const PetitionEndReason petitionEndTooFewPlayers =
    EndKickPetitionMessage_PetitionEndReason_petitionEndTooFewPlayers;
  static const PetitionEndReason petitionEndPlayerLeft =
    EndKickPetitionMessage_PetitionEndReason_petitionEndPlayerLeft;
  static const PetitionEndReason petitionEndTimeout =
    EndKickPetitionMessage_PetitionEndReason_petitionEndTimeout;
  static inline bool PetitionEndReason_IsValid(int value) {
    return EndKickPetitionMessage_PetitionEndReason_IsValid(value);
  }
  static const PetitionEndReason PetitionEndReason_MIN =
    EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MIN;
  static const PetitionEndReason PetitionEndReason_MAX =
    EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_MAX;
  static const int PetitionEndReason_ARRAYSIZE =
    EndKickPetitionMessage_PetitionEndReason_PetitionEndReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // required uint32 petitionId = 2;
  bool has_petitionid() const;
  void clear_petitionid();
  static const int kPetitionIdFieldNumber = 2;
  ::google::protobuf::uint32 petitionid() const;
  void set_petitionid(::google::protobuf::uint32 value);

  // required uint32 numVotesAgainstKicking = 3;
  bool has_numvotesagainstkicking() const;
  void clear_numvotesagainstkicking();
  static const int kNumVotesAgainstKickingFieldNumber = 3;
  ::google::protobuf::uint32 numvotesagainstkicking() const;
  void set_numvotesagainstkicking(::google::protobuf::uint32 value);

  // required uint32 numVotesInFavourOfKicking = 4;
  bool has_numvotesinfavourofkicking() const;
  void clear_numvotesinfavourofkicking();
  static const int kNumVotesInFavourOfKickingFieldNumber = 4;
  ::google::protobuf::uint32 numvotesinfavourofkicking() const;
  void set_numvotesinfavourofkicking(::google::protobuf::uint32 value);

  // required uint32 resultPlayerKicked = 5;
  bool has_resultplayerkicked() const;
  void clear_resultplayerkicked();
  static const int kResultPlayerKickedFieldNumber = 5;
  ::google::protobuf::uint32 resultplayerkicked() const;
  void set_resultplayerkicked(::google::protobuf::uint32 value);

  // required .EndKickPetitionMessage.PetitionEndReason petitionEndReason = 6;
  bool has_petitionendreason() const;
  void clear_petitionendreason();
  static const int kPetitionEndReasonFieldNumber = 6;
  ::EndKickPetitionMessage_PetitionEndReason petitionendreason() const;
  void set_petitionendreason(::EndKickPetitionMessage_PetitionEndReason value);

  // @@protoc_insertion_point(class_scope:EndKickPetitionMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 petitionid_;
  ::google::protobuf::uint32 numvotesagainstkicking_;
  ::google::protobuf::uint32 numvotesinfavourofkicking_;
  ::google::protobuf::uint32 resultplayerkicked_;
  int petitionendreason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class StatisticsMessage_StatisticsData :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:StatisticsMessage.StatisticsData) */ {
 public:
  StatisticsMessage_StatisticsData();
  virtual ~StatisticsMessage_StatisticsData();

  StatisticsMessage_StatisticsData(const StatisticsMessage_StatisticsData& from);

  inline StatisticsMessage_StatisticsData& operator=(const StatisticsMessage_StatisticsData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatisticsMessage_StatisticsData(StatisticsMessage_StatisticsData&& from) noexcept
    : StatisticsMessage_StatisticsData() {
    *this = ::std::move(from);
  }

  inline StatisticsMessage_StatisticsData& operator=(StatisticsMessage_StatisticsData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const StatisticsMessage_StatisticsData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatisticsMessage_StatisticsData* internal_default_instance() {
    return reinterpret_cast<const StatisticsMessage_StatisticsData*>(
               &_StatisticsMessage_StatisticsData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  void Swap(StatisticsMessage_StatisticsData* other);
  friend void swap(StatisticsMessage_StatisticsData& a, StatisticsMessage_StatisticsData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatisticsMessage_StatisticsData* New() const final {
    return CreateMaybeMessage<StatisticsMessage_StatisticsData>(nullptr);
  }

  StatisticsMessage_StatisticsData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatisticsMessage_StatisticsData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const StatisticsMessage_StatisticsData& from);
  void MergeFrom(const StatisticsMessage_StatisticsData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StatisticsMessage_StatisticsData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef StatisticsMessage_StatisticsData_StatisticsType StatisticsType;
  static const StatisticsType statNumberOfPlayers =
    StatisticsMessage_StatisticsData_StatisticsType_statNumberOfPlayers;
  static inline bool StatisticsType_IsValid(int value) {
    return StatisticsMessage_StatisticsData_StatisticsType_IsValid(value);
  }
  static const StatisticsType StatisticsType_MIN =
    StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MIN;
  static const StatisticsType StatisticsType_MAX =
    StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_MAX;
  static const int StatisticsType_ARRAYSIZE =
    StatisticsMessage_StatisticsData_StatisticsType_StatisticsType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 statisticsValue = 2;
  bool has_statisticsvalue() const;
  void clear_statisticsvalue();
  static const int kStatisticsValueFieldNumber = 2;
  ::google::protobuf::uint32 statisticsvalue() const;
  void set_statisticsvalue(::google::protobuf::uint32 value);

  // required .StatisticsMessage.StatisticsData.StatisticsType statisticsType = 1;
  bool has_statisticstype() const;
  void clear_statisticstype();
  static const int kStatisticsTypeFieldNumber = 1;
  ::StatisticsMessage_StatisticsData_StatisticsType statisticstype() const;
  void set_statisticstype(::StatisticsMessage_StatisticsData_StatisticsType value);

  // @@protoc_insertion_point(class_scope:StatisticsMessage.StatisticsData)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 statisticsvalue_;
  int statisticstype_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class StatisticsMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:StatisticsMessage) */ {
 public:
  StatisticsMessage();
  virtual ~StatisticsMessage();

  StatisticsMessage(const StatisticsMessage& from);

  inline StatisticsMessage& operator=(const StatisticsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatisticsMessage(StatisticsMessage&& from) noexcept
    : StatisticsMessage() {
    *this = ::std::move(from);
  }

  inline StatisticsMessage& operator=(StatisticsMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const StatisticsMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatisticsMessage* internal_default_instance() {
    return reinterpret_cast<const StatisticsMessage*>(
               &_StatisticsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  void Swap(StatisticsMessage* other);
  friend void swap(StatisticsMessage& a, StatisticsMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatisticsMessage* New() const final {
    return CreateMaybeMessage<StatisticsMessage>(nullptr);
  }

  StatisticsMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatisticsMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const StatisticsMessage& from);
  void MergeFrom(const StatisticsMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StatisticsMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef StatisticsMessage_StatisticsData StatisticsData;

  // accessors -------------------------------------------------------

  // repeated .StatisticsMessage.StatisticsData statisticsData = 1;
  int statisticsdata_size() const;
  void clear_statisticsdata();
  static const int kStatisticsDataFieldNumber = 1;
  ::StatisticsMessage_StatisticsData* mutable_statisticsdata(int index);
  ::google::protobuf::RepeatedPtrField< ::StatisticsMessage_StatisticsData >*
      mutable_statisticsdata();
  const ::StatisticsMessage_StatisticsData& statisticsdata(int index) const;
  ::StatisticsMessage_StatisticsData* add_statisticsdata();
  const ::google::protobuf::RepeatedPtrField< ::StatisticsMessage_StatisticsData >&
      statisticsdata() const;

  // @@protoc_insertion_point(class_scope:StatisticsMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::StatisticsMessage_StatisticsData > statisticsdata_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ChatRequestMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ChatRequestMessage) */ {
 public:
  ChatRequestMessage();
  virtual ~ChatRequestMessage();

  ChatRequestMessage(const ChatRequestMessage& from);

  inline ChatRequestMessage& operator=(const ChatRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChatRequestMessage(ChatRequestMessage&& from) noexcept
    : ChatRequestMessage() {
    *this = ::std::move(from);
  }

  inline ChatRequestMessage& operator=(ChatRequestMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ChatRequestMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChatRequestMessage* internal_default_instance() {
    return reinterpret_cast<const ChatRequestMessage*>(
               &_ChatRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  void Swap(ChatRequestMessage* other);
  friend void swap(ChatRequestMessage& a, ChatRequestMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChatRequestMessage* New() const final {
    return CreateMaybeMessage<ChatRequestMessage>(nullptr);
  }

  ChatRequestMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChatRequestMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ChatRequestMessage& from);
  void MergeFrom(const ChatRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChatRequestMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string chatText = 3;
  bool has_chattext() const;
  void clear_chattext();
  static const int kChatTextFieldNumber = 3;
  const ::std::string& chattext() const;
  void set_chattext(const ::std::string& value);
  #if LANG_CXX11
  void set_chattext(::std::string&& value);
  #endif
  void set_chattext(const char* value);
  void set_chattext(const char* value, size_t size);
  ::std::string* mutable_chattext();
  ::std::string* release_chattext();
  void set_allocated_chattext(::std::string* chattext);

  // optional uint32 targetGameId = 1;
  bool has_targetgameid() const;
  void clear_targetgameid();
  static const int kTargetGameIdFieldNumber = 1;
  ::google::protobuf::uint32 targetgameid() const;
  void set_targetgameid(::google::protobuf::uint32 value);

  // optional uint32 targetPlayerId = 2;
  bool has_targetplayerid() const;
  void clear_targetplayerid();
  static const int kTargetPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 targetplayerid() const;
  void set_targetplayerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ChatRequestMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr chattext_;
  ::google::protobuf::uint32 targetgameid_;
  ::google::protobuf::uint32 targetplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ChatMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ChatMessage) */ {
 public:
  ChatMessage();
  virtual ~ChatMessage();

  ChatMessage(const ChatMessage& from);

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChatMessage(ChatMessage&& from) noexcept
    : ChatMessage() {
    *this = ::std::move(from);
  }

  inline ChatMessage& operator=(ChatMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ChatMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChatMessage* internal_default_instance() {
    return reinterpret_cast<const ChatMessage*>(
               &_ChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  void Swap(ChatMessage* other);
  friend void swap(ChatMessage& a, ChatMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChatMessage* New() const final {
    return CreateMaybeMessage<ChatMessage>(nullptr);
  }

  ChatMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChatMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ChatMessage& from);
  void MergeFrom(const ChatMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChatMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ChatMessage_ChatType ChatType;
  static const ChatType chatTypeLobby =
    ChatMessage_ChatType_chatTypeLobby;
  static const ChatType chatTypeGame =
    ChatMessage_ChatType_chatTypeGame;
  static const ChatType chatTypeBot =
    ChatMessage_ChatType_chatTypeBot;
  static const ChatType chatTypeBroadcast =
    ChatMessage_ChatType_chatTypeBroadcast;
  static const ChatType chatTypePrivate =
    ChatMessage_ChatType_chatTypePrivate;
  static inline bool ChatType_IsValid(int value) {
    return ChatMessage_ChatType_IsValid(value);
  }
  static const ChatType ChatType_MIN =
    ChatMessage_ChatType_ChatType_MIN;
  static const ChatType ChatType_MAX =
    ChatMessage_ChatType_ChatType_MAX;
  static const int ChatType_ARRAYSIZE =
    ChatMessage_ChatType_ChatType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required string chatText = 4;
  bool has_chattext() const;
  void clear_chattext();
  static const int kChatTextFieldNumber = 4;
  const ::std::string& chattext() const;
  void set_chattext(const ::std::string& value);
  #if LANG_CXX11
  void set_chattext(::std::string&& value);
  #endif
  void set_chattext(const char* value);
  void set_chattext(const char* value, size_t size);
  ::std::string* mutable_chattext();
  ::std::string* release_chattext();
  void set_allocated_chattext(::std::string* chattext);

  // optional uint32 gameId = 1;
  bool has_gameid() const;
  void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  ::google::protobuf::uint32 gameid() const;
  void set_gameid(::google::protobuf::uint32 value);

  // optional uint32 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 playerid() const;
  void set_playerid(::google::protobuf::uint32 value);

  // required .ChatMessage.ChatType chatType = 3;
  bool has_chattype() const;
  void clear_chattype();
  static const int kChatTypeFieldNumber = 3;
  ::ChatMessage_ChatType chattype() const;
  void set_chattype(::ChatMessage_ChatType value);

  // @@protoc_insertion_point(class_scope:ChatMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr chattext_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 playerid_;
  int chattype_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ChatRejectMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ChatRejectMessage) */ {
 public:
  ChatRejectMessage();
  virtual ~ChatRejectMessage();

  ChatRejectMessage(const ChatRejectMessage& from);

  inline ChatRejectMessage& operator=(const ChatRejectMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChatRejectMessage(ChatRejectMessage&& from) noexcept
    : ChatRejectMessage() {
    *this = ::std::move(from);
  }

  inline ChatRejectMessage& operator=(ChatRejectMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ChatRejectMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChatRejectMessage* internal_default_instance() {
    return reinterpret_cast<const ChatRejectMessage*>(
               &_ChatRejectMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  void Swap(ChatRejectMessage* other);
  friend void swap(ChatRejectMessage& a, ChatRejectMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChatRejectMessage* New() const final {
    return CreateMaybeMessage<ChatRejectMessage>(nullptr);
  }

  ChatRejectMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChatRejectMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ChatRejectMessage& from);
  void MergeFrom(const ChatRejectMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChatRejectMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string chatText = 1;
  bool has_chattext() const;
  void clear_chattext();
  static const int kChatTextFieldNumber = 1;
  const ::std::string& chattext() const;
  void set_chattext(const ::std::string& value);
  #if LANG_CXX11
  void set_chattext(::std::string&& value);
  #endif
  void set_chattext(const char* value);
  void set_chattext(const char* value, size_t size);
  ::std::string* mutable_chattext();
  ::std::string* release_chattext();
  void set_allocated_chattext(::std::string* chattext);

  // @@protoc_insertion_point(class_scope:ChatRejectMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr chattext_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class DialogMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:DialogMessage) */ {
 public:
  DialogMessage();
  virtual ~DialogMessage();

  DialogMessage(const DialogMessage& from);

  inline DialogMessage& operator=(const DialogMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DialogMessage(DialogMessage&& from) noexcept
    : DialogMessage() {
    *this = ::std::move(from);
  }

  inline DialogMessage& operator=(DialogMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DialogMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DialogMessage* internal_default_instance() {
    return reinterpret_cast<const DialogMessage*>(
               &_DialogMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  void Swap(DialogMessage* other);
  friend void swap(DialogMessage& a, DialogMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DialogMessage* New() const final {
    return CreateMaybeMessage<DialogMessage>(nullptr);
  }

  DialogMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DialogMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DialogMessage& from);
  void MergeFrom(const DialogMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DialogMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string notificationText = 1;
  bool has_notificationtext() const;
  void clear_notificationtext();
  static const int kNotificationTextFieldNumber = 1;
  const ::std::string& notificationtext() const;
  void set_notificationtext(const ::std::string& value);
  #if LANG_CXX11
  void set_notificationtext(::std::string&& value);
  #endif
  void set_notificationtext(const char* value);
  void set_notificationtext(const char* value, size_t size);
  ::std::string* mutable_notificationtext();
  ::std::string* release_notificationtext();
  void set_allocated_notificationtext(::std::string* notificationtext);

  // @@protoc_insertion_point(class_scope:DialogMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr notificationtext_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class TimeoutWarningMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:TimeoutWarningMessage) */ {
 public:
  TimeoutWarningMessage();
  virtual ~TimeoutWarningMessage();

  TimeoutWarningMessage(const TimeoutWarningMessage& from);

  inline TimeoutWarningMessage& operator=(const TimeoutWarningMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeoutWarningMessage(TimeoutWarningMessage&& from) noexcept
    : TimeoutWarningMessage() {
    *this = ::std::move(from);
  }

  inline TimeoutWarningMessage& operator=(TimeoutWarningMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const TimeoutWarningMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeoutWarningMessage* internal_default_instance() {
    return reinterpret_cast<const TimeoutWarningMessage*>(
               &_TimeoutWarningMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  void Swap(TimeoutWarningMessage* other);
  friend void swap(TimeoutWarningMessage& a, TimeoutWarningMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeoutWarningMessage* New() const final {
    return CreateMaybeMessage<TimeoutWarningMessage>(nullptr);
  }

  TimeoutWarningMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TimeoutWarningMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const TimeoutWarningMessage& from);
  void MergeFrom(const TimeoutWarningMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TimeoutWarningMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TimeoutWarningMessage_TimeoutReason TimeoutReason;
  static const TimeoutReason timeoutNoDataReceived =
    TimeoutWarningMessage_TimeoutReason_timeoutNoDataReceived;
  static const TimeoutReason timeoutInactiveGame =
    TimeoutWarningMessage_TimeoutReason_timeoutInactiveGame;
  static const TimeoutReason timeoutKickAfterAutofold =
    TimeoutWarningMessage_TimeoutReason_timeoutKickAfterAutofold;
  static inline bool TimeoutReason_IsValid(int value) {
    return TimeoutWarningMessage_TimeoutReason_IsValid(value);
  }
  static const TimeoutReason TimeoutReason_MIN =
    TimeoutWarningMessage_TimeoutReason_TimeoutReason_MIN;
  static const TimeoutReason TimeoutReason_MAX =
    TimeoutWarningMessage_TimeoutReason_TimeoutReason_MAX;
  static const int TimeoutReason_ARRAYSIZE =
    TimeoutWarningMessage_TimeoutReason_TimeoutReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .TimeoutWarningMessage.TimeoutReason timeoutReason = 1;
  bool has_timeoutreason() const;
  void clear_timeoutreason();
  static const int kTimeoutReasonFieldNumber = 1;
  ::TimeoutWarningMessage_TimeoutReason timeoutreason() const;
  void set_timeoutreason(::TimeoutWarningMessage_TimeoutReason value);

  // required uint32 remainingSeconds = 2;
  bool has_remainingseconds() const;
  void clear_remainingseconds();
  static const int kRemainingSecondsFieldNumber = 2;
  ::google::protobuf::uint32 remainingseconds() const;
  void set_remainingseconds(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TimeoutWarningMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int timeoutreason_;
  ::google::protobuf::uint32 remainingseconds_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ResetTimeoutMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ResetTimeoutMessage) */ {
 public:
  ResetTimeoutMessage();
  virtual ~ResetTimeoutMessage();

  ResetTimeoutMessage(const ResetTimeoutMessage& from);

  inline ResetTimeoutMessage& operator=(const ResetTimeoutMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResetTimeoutMessage(ResetTimeoutMessage&& from) noexcept
    : ResetTimeoutMessage() {
    *this = ::std::move(from);
  }

  inline ResetTimeoutMessage& operator=(ResetTimeoutMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ResetTimeoutMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetTimeoutMessage* internal_default_instance() {
    return reinterpret_cast<const ResetTimeoutMessage*>(
               &_ResetTimeoutMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  void Swap(ResetTimeoutMessage* other);
  friend void swap(ResetTimeoutMessage& a, ResetTimeoutMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResetTimeoutMessage* New() const final {
    return CreateMaybeMessage<ResetTimeoutMessage>(nullptr);
  }

  ResetTimeoutMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResetTimeoutMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ResetTimeoutMessage& from);
  void MergeFrom(const ResetTimeoutMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResetTimeoutMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ResetTimeoutMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ReportAvatarMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ReportAvatarMessage) */ {
 public:
  ReportAvatarMessage();
  virtual ~ReportAvatarMessage();

  ReportAvatarMessage(const ReportAvatarMessage& from);

  inline ReportAvatarMessage& operator=(const ReportAvatarMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportAvatarMessage(ReportAvatarMessage&& from) noexcept
    : ReportAvatarMessage() {
    *this = ::std::move(from);
  }

  inline ReportAvatarMessage& operator=(ReportAvatarMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ReportAvatarMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportAvatarMessage* internal_default_instance() {
    return reinterpret_cast<const ReportAvatarMessage*>(
               &_ReportAvatarMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  void Swap(ReportAvatarMessage* other);
  friend void swap(ReportAvatarMessage& a, ReportAvatarMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportAvatarMessage* New() const final {
    return CreateMaybeMessage<ReportAvatarMessage>(nullptr);
  }

  ReportAvatarMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReportAvatarMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ReportAvatarMessage& from);
  void MergeFrom(const ReportAvatarMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReportAvatarMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes reportedAvatarHash = 2;
  bool has_reportedavatarhash() const;
  void clear_reportedavatarhash();
  static const int kReportedAvatarHashFieldNumber = 2;
  const ::std::string& reportedavatarhash() const;
  void set_reportedavatarhash(const ::std::string& value);
  #if LANG_CXX11
  void set_reportedavatarhash(::std::string&& value);
  #endif
  void set_reportedavatarhash(const char* value);
  void set_reportedavatarhash(const void* value, size_t size);
  ::std::string* mutable_reportedavatarhash();
  ::std::string* release_reportedavatarhash();
  void set_allocated_reportedavatarhash(::std::string* reportedavatarhash);

  // required uint32 reportedPlayerId = 1;
  bool has_reportedplayerid() const;
  void clear_reportedplayerid();
  static const int kReportedPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 reportedplayerid() const;
  void set_reportedplayerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ReportAvatarMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr reportedavatarhash_;
  ::google::protobuf::uint32 reportedplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ReportAvatarAckMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ReportAvatarAckMessage) */ {
 public:
  ReportAvatarAckMessage();
  virtual ~ReportAvatarAckMessage();

  ReportAvatarAckMessage(const ReportAvatarAckMessage& from);

  inline ReportAvatarAckMessage& operator=(const ReportAvatarAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportAvatarAckMessage(ReportAvatarAckMessage&& from) noexcept
    : ReportAvatarAckMessage() {
    *this = ::std::move(from);
  }

  inline ReportAvatarAckMessage& operator=(ReportAvatarAckMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ReportAvatarAckMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportAvatarAckMessage* internal_default_instance() {
    return reinterpret_cast<const ReportAvatarAckMessage*>(
               &_ReportAvatarAckMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  void Swap(ReportAvatarAckMessage* other);
  friend void swap(ReportAvatarAckMessage& a, ReportAvatarAckMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportAvatarAckMessage* New() const final {
    return CreateMaybeMessage<ReportAvatarAckMessage>(nullptr);
  }

  ReportAvatarAckMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReportAvatarAckMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ReportAvatarAckMessage& from);
  void MergeFrom(const ReportAvatarAckMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReportAvatarAckMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ReportAvatarAckMessage_ReportAvatarResult ReportAvatarResult;
  static const ReportAvatarResult avatarReportAccepted =
    ReportAvatarAckMessage_ReportAvatarResult_avatarReportAccepted;
  static const ReportAvatarResult avatarReportDuplicate =
    ReportAvatarAckMessage_ReportAvatarResult_avatarReportDuplicate;
  static const ReportAvatarResult avatarReportInvalid =
    ReportAvatarAckMessage_ReportAvatarResult_avatarReportInvalid;
  static inline bool ReportAvatarResult_IsValid(int value) {
    return ReportAvatarAckMessage_ReportAvatarResult_IsValid(value);
  }
  static const ReportAvatarResult ReportAvatarResult_MIN =
    ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MIN;
  static const ReportAvatarResult ReportAvatarResult_MAX =
    ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_MAX;
  static const int ReportAvatarResult_ARRAYSIZE =
    ReportAvatarAckMessage_ReportAvatarResult_ReportAvatarResult_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 reportedPlayerId = 1;
  bool has_reportedplayerid() const;
  void clear_reportedplayerid();
  static const int kReportedPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 reportedplayerid() const;
  void set_reportedplayerid(::google::protobuf::uint32 value);

  // required .ReportAvatarAckMessage.ReportAvatarResult reportAvatarResult = 2;
  bool has_reportavatarresult() const;
  void clear_reportavatarresult();
  static const int kReportAvatarResultFieldNumber = 2;
  ::ReportAvatarAckMessage_ReportAvatarResult reportavatarresult() const;
  void set_reportavatarresult(::ReportAvatarAckMessage_ReportAvatarResult value);

  // @@protoc_insertion_point(class_scope:ReportAvatarAckMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 reportedplayerid_;
  int reportavatarresult_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ReportGameMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ReportGameMessage) */ {
 public:
  ReportGameMessage();
  virtual ~ReportGameMessage();

  ReportGameMessage(const ReportGameMessage& from);

  inline ReportGameMessage& operator=(const ReportGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportGameMessage(ReportGameMessage&& from) noexcept
    : ReportGameMessage() {
    *this = ::std::move(from);
  }

  inline ReportGameMessage& operator=(ReportGameMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ReportGameMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportGameMessage* internal_default_instance() {
    return reinterpret_cast<const ReportGameMessage*>(
               &_ReportGameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  void Swap(ReportGameMessage* other);
  friend void swap(ReportGameMessage& a, ReportGameMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportGameMessage* New() const final {
    return CreateMaybeMessage<ReportGameMessage>(nullptr);
  }

  ReportGameMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReportGameMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ReportGameMessage& from);
  void MergeFrom(const ReportGameMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReportGameMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 reportedGameId = 1;
  bool has_reportedgameid() const;
  void clear_reportedgameid();
  static const int kReportedGameIdFieldNumber = 1;
  ::google::protobuf::uint32 reportedgameid() const;
  void set_reportedgameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ReportGameMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 reportedgameid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ReportGameAckMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ReportGameAckMessage) */ {
 public:
  ReportGameAckMessage();
  virtual ~ReportGameAckMessage();

  ReportGameAckMessage(const ReportGameAckMessage& from);

  inline ReportGameAckMessage& operator=(const ReportGameAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportGameAckMessage(ReportGameAckMessage&& from) noexcept
    : ReportGameAckMessage() {
    *this = ::std::move(from);
  }

  inline ReportGameAckMessage& operator=(ReportGameAckMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ReportGameAckMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportGameAckMessage* internal_default_instance() {
    return reinterpret_cast<const ReportGameAckMessage*>(
               &_ReportGameAckMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  void Swap(ReportGameAckMessage* other);
  friend void swap(ReportGameAckMessage& a, ReportGameAckMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportGameAckMessage* New() const final {
    return CreateMaybeMessage<ReportGameAckMessage>(nullptr);
  }

  ReportGameAckMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReportGameAckMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ReportGameAckMessage& from);
  void MergeFrom(const ReportGameAckMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReportGameAckMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ReportGameAckMessage_ReportGameResult ReportGameResult;
  static const ReportGameResult gameReportAccepted =
    ReportGameAckMessage_ReportGameResult_gameReportAccepted;
  static const ReportGameResult gameReportDuplicate =
    ReportGameAckMessage_ReportGameResult_gameReportDuplicate;
  static const ReportGameResult gameReportInvalid =
    ReportGameAckMessage_ReportGameResult_gameReportInvalid;
  static inline bool ReportGameResult_IsValid(int value) {
    return ReportGameAckMessage_ReportGameResult_IsValid(value);
  }
  static const ReportGameResult ReportGameResult_MIN =
    ReportGameAckMessage_ReportGameResult_ReportGameResult_MIN;
  static const ReportGameResult ReportGameResult_MAX =
    ReportGameAckMessage_ReportGameResult_ReportGameResult_MAX;
  static const int ReportGameResult_ARRAYSIZE =
    ReportGameAckMessage_ReportGameResult_ReportGameResult_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 reportedGameId = 1;
  bool has_reportedgameid() const;
  void clear_reportedgameid();
  static const int kReportedGameIdFieldNumber = 1;
  ::google::protobuf::uint32 reportedgameid() const;
  void set_reportedgameid(::google::protobuf::uint32 value);

  // required .ReportGameAckMessage.ReportGameResult reportGameResult = 2;
  bool has_reportgameresult() const;
  void clear_reportgameresult();
  static const int kReportGameResultFieldNumber = 2;
  ::ReportGameAckMessage_ReportGameResult reportgameresult() const;
  void set_reportgameresult(::ReportGameAckMessage_ReportGameResult value);

  // @@protoc_insertion_point(class_scope:ReportGameAckMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 reportedgameid_;
  int reportgameresult_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class ErrorMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ErrorMessage) */ {
 public:
  ErrorMessage();
  virtual ~ErrorMessage();

  ErrorMessage(const ErrorMessage& from);

  inline ErrorMessage& operator=(const ErrorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ErrorMessage(ErrorMessage&& from) noexcept
    : ErrorMessage() {
    *this = ::std::move(from);
  }

  inline ErrorMessage& operator=(ErrorMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ErrorMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErrorMessage* internal_default_instance() {
    return reinterpret_cast<const ErrorMessage*>(
               &_ErrorMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  void Swap(ErrorMessage* other);
  friend void swap(ErrorMessage& a, ErrorMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ErrorMessage* New() const final {
    return CreateMaybeMessage<ErrorMessage>(nullptr);
  }

  ErrorMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ErrorMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ErrorMessage& from);
  void MergeFrom(const ErrorMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ErrorMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ErrorMessage_ErrorReason ErrorReason;
  static const ErrorReason custReserved =
    ErrorMessage_ErrorReason_custReserved;
  static const ErrorReason initVersionNotSupported =
    ErrorMessage_ErrorReason_initVersionNotSupported;
  static const ErrorReason initServerFull =
    ErrorMessage_ErrorReason_initServerFull;
  static const ErrorReason initAuthFailure =
    ErrorMessage_ErrorReason_initAuthFailure;
  static const ErrorReason initPlayerNameInUse =
    ErrorMessage_ErrorReason_initPlayerNameInUse;
  static const ErrorReason initInvalidPlayerName =
    ErrorMessage_ErrorReason_initInvalidPlayerName;
  static const ErrorReason initServerMaintenance =
    ErrorMessage_ErrorReason_initServerMaintenance;
  static const ErrorReason initBlocked =
    ErrorMessage_ErrorReason_initBlocked;
  static const ErrorReason avatarTooLarge =
    ErrorMessage_ErrorReason_avatarTooLarge;
  static const ErrorReason invalidPacket =
    ErrorMessage_ErrorReason_invalidPacket;
  static const ErrorReason invalidState =
    ErrorMessage_ErrorReason_invalidState;
  static const ErrorReason kickedFromServer =
    ErrorMessage_ErrorReason_kickedFromServer;
  static const ErrorReason bannedFromServer =
    ErrorMessage_ErrorReason_bannedFromServer;
  static const ErrorReason blockedByServer =
    ErrorMessage_ErrorReason_blockedByServer;
  static const ErrorReason sessionTimeout =
    ErrorMessage_ErrorReason_sessionTimeout;
  static inline bool ErrorReason_IsValid(int value) {
    return ErrorMessage_ErrorReason_IsValid(value);
  }
  static const ErrorReason ErrorReason_MIN =
    ErrorMessage_ErrorReason_ErrorReason_MIN;
  static const ErrorReason ErrorReason_MAX =
    ErrorMessage_ErrorReason_ErrorReason_MAX;
  static const int ErrorReason_ARRAYSIZE =
    ErrorMessage_ErrorReason_ErrorReason_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .ErrorMessage.ErrorReason errorReason = 1;
  bool has_errorreason() const;
  void clear_errorreason();
  static const int kErrorReasonFieldNumber = 1;
  ::ErrorMessage_ErrorReason errorreason() const;
  void set_errorreason(::ErrorMessage_ErrorReason value);

  // @@protoc_insertion_point(class_scope:ErrorMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int errorreason_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AdminRemoveGameMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AdminRemoveGameMessage) */ {
 public:
  AdminRemoveGameMessage();
  virtual ~AdminRemoveGameMessage();

  AdminRemoveGameMessage(const AdminRemoveGameMessage& from);

  inline AdminRemoveGameMessage& operator=(const AdminRemoveGameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdminRemoveGameMessage(AdminRemoveGameMessage&& from) noexcept
    : AdminRemoveGameMessage() {
    *this = ::std::move(from);
  }

  inline AdminRemoveGameMessage& operator=(AdminRemoveGameMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AdminRemoveGameMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminRemoveGameMessage* internal_default_instance() {
    return reinterpret_cast<const AdminRemoveGameMessage*>(
               &_AdminRemoveGameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  void Swap(AdminRemoveGameMessage* other);
  friend void swap(AdminRemoveGameMessage& a, AdminRemoveGameMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdminRemoveGameMessage* New() const final {
    return CreateMaybeMessage<AdminRemoveGameMessage>(nullptr);
  }

  AdminRemoveGameMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AdminRemoveGameMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AdminRemoveGameMessage& from);
  void MergeFrom(const AdminRemoveGameMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminRemoveGameMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 removeGameId = 1;
  bool has_removegameid() const;
  void clear_removegameid();
  static const int kRemoveGameIdFieldNumber = 1;
  ::google::protobuf::uint32 removegameid() const;
  void set_removegameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AdminRemoveGameMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 removegameid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AdminRemoveGameAckMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AdminRemoveGameAckMessage) */ {
 public:
  AdminRemoveGameAckMessage();
  virtual ~AdminRemoveGameAckMessage();

  AdminRemoveGameAckMessage(const AdminRemoveGameAckMessage& from);

  inline AdminRemoveGameAckMessage& operator=(const AdminRemoveGameAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdminRemoveGameAckMessage(AdminRemoveGameAckMessage&& from) noexcept
    : AdminRemoveGameAckMessage() {
    *this = ::std::move(from);
  }

  inline AdminRemoveGameAckMessage& operator=(AdminRemoveGameAckMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AdminRemoveGameAckMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminRemoveGameAckMessage* internal_default_instance() {
    return reinterpret_cast<const AdminRemoveGameAckMessage*>(
               &_AdminRemoveGameAckMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  void Swap(AdminRemoveGameAckMessage* other);
  friend void swap(AdminRemoveGameAckMessage& a, AdminRemoveGameAckMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdminRemoveGameAckMessage* New() const final {
    return CreateMaybeMessage<AdminRemoveGameAckMessage>(nullptr);
  }

  AdminRemoveGameAckMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AdminRemoveGameAckMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AdminRemoveGameAckMessage& from);
  void MergeFrom(const AdminRemoveGameAckMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminRemoveGameAckMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AdminRemoveGameAckMessage_AdminRemoveGameResult AdminRemoveGameResult;
  static const AdminRemoveGameResult gameRemoveAccepted =
    AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveAccepted;
  static const AdminRemoveGameResult gameRemoveInvalid =
    AdminRemoveGameAckMessage_AdminRemoveGameResult_gameRemoveInvalid;
  static inline bool AdminRemoveGameResult_IsValid(int value) {
    return AdminRemoveGameAckMessage_AdminRemoveGameResult_IsValid(value);
  }
  static const AdminRemoveGameResult AdminRemoveGameResult_MIN =
    AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_MIN;
  static const AdminRemoveGameResult AdminRemoveGameResult_MAX =
    AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_MAX;
  static const int AdminRemoveGameResult_ARRAYSIZE =
    AdminRemoveGameAckMessage_AdminRemoveGameResult_AdminRemoveGameResult_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 removeGameId = 1;
  bool has_removegameid() const;
  void clear_removegameid();
  static const int kRemoveGameIdFieldNumber = 1;
  ::google::protobuf::uint32 removegameid() const;
  void set_removegameid(::google::protobuf::uint32 value);

  // required .AdminRemoveGameAckMessage.AdminRemoveGameResult removeGameResult = 2;
  bool has_removegameresult() const;
  void clear_removegameresult();
  static const int kRemoveGameResultFieldNumber = 2;
  ::AdminRemoveGameAckMessage_AdminRemoveGameResult removegameresult() const;
  void set_removegameresult(::AdminRemoveGameAckMessage_AdminRemoveGameResult value);

  // @@protoc_insertion_point(class_scope:AdminRemoveGameAckMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 removegameid_;
  int removegameresult_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AdminBanPlayerMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AdminBanPlayerMessage) */ {
 public:
  AdminBanPlayerMessage();
  virtual ~AdminBanPlayerMessage();

  AdminBanPlayerMessage(const AdminBanPlayerMessage& from);

  inline AdminBanPlayerMessage& operator=(const AdminBanPlayerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdminBanPlayerMessage(AdminBanPlayerMessage&& from) noexcept
    : AdminBanPlayerMessage() {
    *this = ::std::move(from);
  }

  inline AdminBanPlayerMessage& operator=(AdminBanPlayerMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AdminBanPlayerMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminBanPlayerMessage* internal_default_instance() {
    return reinterpret_cast<const AdminBanPlayerMessage*>(
               &_AdminBanPlayerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  void Swap(AdminBanPlayerMessage* other);
  friend void swap(AdminBanPlayerMessage& a, AdminBanPlayerMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdminBanPlayerMessage* New() const final {
    return CreateMaybeMessage<AdminBanPlayerMessage>(nullptr);
  }

  AdminBanPlayerMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AdminBanPlayerMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AdminBanPlayerMessage& from);
  void MergeFrom(const AdminBanPlayerMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminBanPlayerMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 banPlayerId = 1;
  bool has_banplayerid() const;
  void clear_banplayerid();
  static const int kBanPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 banplayerid() const;
  void set_banplayerid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AdminBanPlayerMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 banplayerid_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class AdminBanPlayerAckMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:AdminBanPlayerAckMessage) */ {
 public:
  AdminBanPlayerAckMessage();
  virtual ~AdminBanPlayerAckMessage();

  AdminBanPlayerAckMessage(const AdminBanPlayerAckMessage& from);

  inline AdminBanPlayerAckMessage& operator=(const AdminBanPlayerAckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdminBanPlayerAckMessage(AdminBanPlayerAckMessage&& from) noexcept
    : AdminBanPlayerAckMessage() {
    *this = ::std::move(from);
  }

  inline AdminBanPlayerAckMessage& operator=(AdminBanPlayerAckMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AdminBanPlayerAckMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminBanPlayerAckMessage* internal_default_instance() {
    return reinterpret_cast<const AdminBanPlayerAckMessage*>(
               &_AdminBanPlayerAckMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  void Swap(AdminBanPlayerAckMessage* other);
  friend void swap(AdminBanPlayerAckMessage& a, AdminBanPlayerAckMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdminBanPlayerAckMessage* New() const final {
    return CreateMaybeMessage<AdminBanPlayerAckMessage>(nullptr);
  }

  AdminBanPlayerAckMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AdminBanPlayerAckMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const AdminBanPlayerAckMessage& from);
  void MergeFrom(const AdminBanPlayerAckMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminBanPlayerAckMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerResult;
  static const AdminBanPlayerResult banPlayerAccepted =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerAccepted;
  static const AdminBanPlayerResult banPlayerPending =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerPending;
  static const AdminBanPlayerResult banPlayerNoDB =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerNoDB;
  static const AdminBanPlayerResult banPlayerDBError =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerDBError;
  static const AdminBanPlayerResult banPlayerInvalid =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_banPlayerInvalid;
  static inline bool AdminBanPlayerResult_IsValid(int value) {
    return AdminBanPlayerAckMessage_AdminBanPlayerResult_IsValid(value);
  }
  static const AdminBanPlayerResult AdminBanPlayerResult_MIN =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_MIN;
  static const AdminBanPlayerResult AdminBanPlayerResult_MAX =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_MAX;
  static const int AdminBanPlayerResult_ARRAYSIZE =
    AdminBanPlayerAckMessage_AdminBanPlayerResult_AdminBanPlayerResult_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 banPlayerId = 1;
  bool has_banplayerid() const;
  void clear_banplayerid();
  static const int kBanPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 banplayerid() const;
  void set_banplayerid(::google::protobuf::uint32 value);

  // required .AdminBanPlayerAckMessage.AdminBanPlayerResult banPlayerResult = 2;
  bool has_banplayerresult() const;
  void clear_banplayerresult();
  static const int kBanPlayerResultFieldNumber = 2;
  ::AdminBanPlayerAckMessage_AdminBanPlayerResult banplayerresult() const;
  void set_banplayerresult(::AdminBanPlayerAckMessage_AdminBanPlayerResult value);

  // @@protoc_insertion_point(class_scope:AdminBanPlayerAckMessage)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 banplayerid_;
  int banplayerresult_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// -------------------------------------------------------------------

class PokerTHMessage :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PokerTHMessage) */ {
 public:
  PokerTHMessage();
  virtual ~PokerTHMessage();

  PokerTHMessage(const PokerTHMessage& from);

  inline PokerTHMessage& operator=(const PokerTHMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PokerTHMessage(PokerTHMessage&& from) noexcept
    : PokerTHMessage() {
    *this = ::std::move(from);
  }

  inline PokerTHMessage& operator=(PokerTHMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PokerTHMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PokerTHMessage* internal_default_instance() {
    return reinterpret_cast<const PokerTHMessage*>(
               &_PokerTHMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  void Swap(PokerTHMessage* other);
  friend void swap(PokerTHMessage& a, PokerTHMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PokerTHMessage* New() const final {
    return CreateMaybeMessage<PokerTHMessage>(nullptr);
  }

  PokerTHMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PokerTHMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PokerTHMessage& from);
  void MergeFrom(const PokerTHMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PokerTHMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PokerTHMessage_PokerTHMessageType PokerTHMessageType;
  static const PokerTHMessageType Type_AnnounceMessage =
    PokerTHMessage_PokerTHMessageType_Type_AnnounceMessage;
  static const PokerTHMessageType Type_InitMessage =
    PokerTHMessage_PokerTHMessageType_Type_InitMessage;
  static const PokerTHMessageType Type_AuthServerChallengeMessage =
    PokerTHMessage_PokerTHMessageType_Type_AuthServerChallengeMessage;
  static const PokerTHMessageType Type_AuthClientResponseMessage =
    PokerTHMessage_PokerTHMessageType_Type_AuthClientResponseMessage;
  static const PokerTHMessageType Type_AuthServerVerificationMessage =
    PokerTHMessage_PokerTHMessageType_Type_AuthServerVerificationMessage;
  static const PokerTHMessageType Type_InitAckMessage =
    PokerTHMessage_PokerTHMessageType_Type_InitAckMessage;
  static const PokerTHMessageType Type_AvatarRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_AvatarRequestMessage;
  static const PokerTHMessageType Type_AvatarHeaderMessage =
    PokerTHMessage_PokerTHMessageType_Type_AvatarHeaderMessage;
  static const PokerTHMessageType Type_AvatarDataMessage =
    PokerTHMessage_PokerTHMessageType_Type_AvatarDataMessage;
  static const PokerTHMessageType Type_AvatarEndMessage =
    PokerTHMessage_PokerTHMessageType_Type_AvatarEndMessage;
  static const PokerTHMessageType Type_UnknownAvatarMessage =
    PokerTHMessage_PokerTHMessageType_Type_UnknownAvatarMessage;
  static const PokerTHMessageType Type_PlayerListMessage =
    PokerTHMessage_PokerTHMessageType_Type_PlayerListMessage;
  static const PokerTHMessageType Type_GameListNewMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameListNewMessage;
  static const PokerTHMessageType Type_GameListUpdateMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameListUpdateMessage;
  static const PokerTHMessageType Type_GameListPlayerJoinedMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameListPlayerJoinedMessage;
  static const PokerTHMessageType Type_GameListPlayerLeftMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameListPlayerLeftMessage;
  static const PokerTHMessageType Type_GameListAdminChangedMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameListAdminChangedMessage;
  static const PokerTHMessageType Type_PlayerInfoRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_PlayerInfoRequestMessage;
  static const PokerTHMessageType Type_PlayerInfoReplyMessage =
    PokerTHMessage_PokerTHMessageType_Type_PlayerInfoReplyMessage;
  static const PokerTHMessageType Type_SubscriptionRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_SubscriptionRequestMessage;
  static const PokerTHMessageType Type_JoinExistingGameMessage =
    PokerTHMessage_PokerTHMessageType_Type_JoinExistingGameMessage;
  static const PokerTHMessageType Type_JoinNewGameMessage =
    PokerTHMessage_PokerTHMessageType_Type_JoinNewGameMessage;
  static const PokerTHMessageType Type_RejoinExistingGameMessage =
    PokerTHMessage_PokerTHMessageType_Type_RejoinExistingGameMessage;
  static const PokerTHMessageType Type_JoinGameAckMessage =
    PokerTHMessage_PokerTHMessageType_Type_JoinGameAckMessage;
  static const PokerTHMessageType Type_JoinGameFailedMessage =
    PokerTHMessage_PokerTHMessageType_Type_JoinGameFailedMessage;
  static const PokerTHMessageType Type_GamePlayerJoinedMessage =
    PokerTHMessage_PokerTHMessageType_Type_GamePlayerJoinedMessage;
  static const PokerTHMessageType Type_GamePlayerLeftMessage =
    PokerTHMessage_PokerTHMessageType_Type_GamePlayerLeftMessage;
  static const PokerTHMessageType Type_GameAdminChangedMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameAdminChangedMessage;
  static const PokerTHMessageType Type_RemovedFromGameMessage =
    PokerTHMessage_PokerTHMessageType_Type_RemovedFromGameMessage;
  static const PokerTHMessageType Type_KickPlayerRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_KickPlayerRequestMessage;
  static const PokerTHMessageType Type_LeaveGameRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_LeaveGameRequestMessage;
  static const PokerTHMessageType Type_InvitePlayerToGameMessage =
    PokerTHMessage_PokerTHMessageType_Type_InvitePlayerToGameMessage;
  static const PokerTHMessageType Type_InviteNotifyMessage =
    PokerTHMessage_PokerTHMessageType_Type_InviteNotifyMessage;
  static const PokerTHMessageType Type_RejectGameInvitationMessage =
    PokerTHMessage_PokerTHMessageType_Type_RejectGameInvitationMessage;
  static const PokerTHMessageType Type_RejectInvNotifyMessage =
    PokerTHMessage_PokerTHMessageType_Type_RejectInvNotifyMessage;
  static const PokerTHMessageType Type_StartEventMessage =
    PokerTHMessage_PokerTHMessageType_Type_StartEventMessage;
  static const PokerTHMessageType Type_StartEventAckMessage =
    PokerTHMessage_PokerTHMessageType_Type_StartEventAckMessage;
  static const PokerTHMessageType Type_GameStartInitialMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameStartInitialMessage;
  static const PokerTHMessageType Type_GameStartRejoinMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameStartRejoinMessage;
  static const PokerTHMessageType Type_HandStartMessage =
    PokerTHMessage_PokerTHMessageType_Type_HandStartMessage;
  static const PokerTHMessageType Type_PlayersTurnMessage =
    PokerTHMessage_PokerTHMessageType_Type_PlayersTurnMessage;
  static const PokerTHMessageType Type_MyActionRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_MyActionRequestMessage;
  static const PokerTHMessageType Type_YourActionRejectedMessage =
    PokerTHMessage_PokerTHMessageType_Type_YourActionRejectedMessage;
  static const PokerTHMessageType Type_PlayersActionDoneMessage =
    PokerTHMessage_PokerTHMessageType_Type_PlayersActionDoneMessage;
  static const PokerTHMessageType Type_DealFlopCardsMessage =
    PokerTHMessage_PokerTHMessageType_Type_DealFlopCardsMessage;
  static const PokerTHMessageType Type_DealTurnCardMessage =
    PokerTHMessage_PokerTHMessageType_Type_DealTurnCardMessage;
  static const PokerTHMessageType Type_DealRiverCardMessage =
    PokerTHMessage_PokerTHMessageType_Type_DealRiverCardMessage;
  static const PokerTHMessageType Type_AllInShowCardsMessage =
    PokerTHMessage_PokerTHMessageType_Type_AllInShowCardsMessage;
  static const PokerTHMessageType Type_EndOfHandShowCardsMessage =
    PokerTHMessage_PokerTHMessageType_Type_EndOfHandShowCardsMessage;
  static const PokerTHMessageType Type_EndOfHandHideCardsMessage =
    PokerTHMessage_PokerTHMessageType_Type_EndOfHandHideCardsMessage;
  static const PokerTHMessageType Type_ShowMyCardsRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_ShowMyCardsRequestMessage;
  static const PokerTHMessageType Type_AfterHandShowCardsMessage =
    PokerTHMessage_PokerTHMessageType_Type_AfterHandShowCardsMessage;
  static const PokerTHMessageType Type_EndOfGameMessage =
    PokerTHMessage_PokerTHMessageType_Type_EndOfGameMessage;
  static const PokerTHMessageType Type_PlayerIdChangedMessage =
    PokerTHMessage_PokerTHMessageType_Type_PlayerIdChangedMessage;
  static const PokerTHMessageType Type_AskKickPlayerMessage =
    PokerTHMessage_PokerTHMessageType_Type_AskKickPlayerMessage;
  static const PokerTHMessageType Type_AskKickDeniedMessage =
    PokerTHMessage_PokerTHMessageType_Type_AskKickDeniedMessage;
  static const PokerTHMessageType Type_StartKickPetitionMessage =
    PokerTHMessage_PokerTHMessageType_Type_StartKickPetitionMessage;
  static const PokerTHMessageType Type_VoteKickRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_VoteKickRequestMessage;
  static const PokerTHMessageType Type_VoteKickReplyMessage =
    PokerTHMessage_PokerTHMessageType_Type_VoteKickReplyMessage;
  static const PokerTHMessageType Type_KickPetitionUpdateMessage =
    PokerTHMessage_PokerTHMessageType_Type_KickPetitionUpdateMessage;
  static const PokerTHMessageType Type_EndKickPetitionMessage =
    PokerTHMessage_PokerTHMessageType_Type_EndKickPetitionMessage;
  static const PokerTHMessageType Type_StatisticsMessage =
    PokerTHMessage_PokerTHMessageType_Type_StatisticsMessage;
  static const PokerTHMessageType Type_ChatRequestMessage =
    PokerTHMessage_PokerTHMessageType_Type_ChatRequestMessage;
  static const PokerTHMessageType Type_ChatMessage =
    PokerTHMessage_PokerTHMessageType_Type_ChatMessage;
  static const PokerTHMessageType Type_ChatRejectMessage =
    PokerTHMessage_PokerTHMessageType_Type_ChatRejectMessage;
  static const PokerTHMessageType Type_DialogMessage =
    PokerTHMessage_PokerTHMessageType_Type_DialogMessage;
  static const PokerTHMessageType Type_TimeoutWarningMessage =
    PokerTHMessage_PokerTHMessageType_Type_TimeoutWarningMessage;
  static const PokerTHMessageType Type_ResetTimeoutMessage =
    PokerTHMessage_PokerTHMessageType_Type_ResetTimeoutMessage;
  static const PokerTHMessageType Type_ReportAvatarMessage =
    PokerTHMessage_PokerTHMessageType_Type_ReportAvatarMessage;
  static const PokerTHMessageType Type_ReportAvatarAckMessage =
    PokerTHMessage_PokerTHMessageType_Type_ReportAvatarAckMessage;
  static const PokerTHMessageType Type_ReportGameMessage =
    PokerTHMessage_PokerTHMessageType_Type_ReportGameMessage;
  static const PokerTHMessageType Type_ReportGameAckMessage =
    PokerTHMessage_PokerTHMessageType_Type_ReportGameAckMessage;
  static const PokerTHMessageType Type_ErrorMessage =
    PokerTHMessage_PokerTHMessageType_Type_ErrorMessage;
  static const PokerTHMessageType Type_AdminRemoveGameMessage =
    PokerTHMessage_PokerTHMessageType_Type_AdminRemoveGameMessage;
  static const PokerTHMessageType Type_AdminRemoveGameAckMessage =
    PokerTHMessage_PokerTHMessageType_Type_AdminRemoveGameAckMessage;
  static const PokerTHMessageType Type_AdminBanPlayerMessage =
    PokerTHMessage_PokerTHMessageType_Type_AdminBanPlayerMessage;
  static const PokerTHMessageType Type_AdminBanPlayerAckMessage =
    PokerTHMessage_PokerTHMessageType_Type_AdminBanPlayerAckMessage;
  static const PokerTHMessageType Type_GameListSpectatorJoinedMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameListSpectatorJoinedMessage;
  static const PokerTHMessageType Type_GameListSpectatorLeftMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameListSpectatorLeftMessage;
  static const PokerTHMessageType Type_GameSpectatorJoinedMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameSpectatorJoinedMessage;
  static const PokerTHMessageType Type_GameSpectatorLeftMessage =
    PokerTHMessage_PokerTHMessageType_Type_GameSpectatorLeftMessage;
  static inline bool PokerTHMessageType_IsValid(int value) {
    return PokerTHMessage_PokerTHMessageType_IsValid(value);
  }
  static const PokerTHMessageType PokerTHMessageType_MIN =
    PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MIN;
  static const PokerTHMessageType PokerTHMessageType_MAX =
    PokerTHMessage_PokerTHMessageType_PokerTHMessageType_MAX;
  static const int PokerTHMessageType_ARRAYSIZE =
    PokerTHMessage_PokerTHMessageType_PokerTHMessageType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .AnnounceMessage announceMessage = 2;
  bool has_announcemessage() const;
  void clear_announcemessage();
  static const int kAnnounceMessageFieldNumber = 2;
  const ::AnnounceMessage& announcemessage() const;
  ::AnnounceMessage* release_announcemessage();
  ::AnnounceMessage* mutable_announcemessage();
  void set_allocated_announcemessage(::AnnounceMessage* announcemessage);

  // optional .InitMessage initMessage = 3;
  bool has_initmessage() const;
  void clear_initmessage();
  static const int kInitMessageFieldNumber = 3;
  const ::InitMessage& initmessage() const;
  ::InitMessage* release_initmessage();
  ::InitMessage* mutable_initmessage();
  void set_allocated_initmessage(::InitMessage* initmessage);

  // optional .AuthServerChallengeMessage authServerChallengeMessage = 4;
  bool has_authserverchallengemessage() const;
  void clear_authserverchallengemessage();
  static const int kAuthServerChallengeMessageFieldNumber = 4;
  const ::AuthServerChallengeMessage& authserverchallengemessage() const;
  ::AuthServerChallengeMessage* release_authserverchallengemessage();
  ::AuthServerChallengeMessage* mutable_authserverchallengemessage();
  void set_allocated_authserverchallengemessage(::AuthServerChallengeMessage* authserverchallengemessage);

  // optional .AuthClientResponseMessage authClientResponseMessage = 5;
  bool has_authclientresponsemessage() const;
  void clear_authclientresponsemessage();
  static const int kAuthClientResponseMessageFieldNumber = 5;
  const ::AuthClientResponseMessage& authclientresponsemessage() const;
  ::AuthClientResponseMessage* release_authclientresponsemessage();
  ::AuthClientResponseMessage* mutable_authclientresponsemessage();
  void set_allocated_authclientresponsemessage(::AuthClientResponseMessage* authclientresponsemessage);

  // optional .AuthServerVerificationMessage authServerVerificationMessage = 6;
  bool has_authserververificationmessage() const;
  void clear_authserververificationmessage();
  static const int kAuthServerVerificationMessageFieldNumber = 6;
  const ::AuthServerVerificationMessage& authserververificationmessage() const;
  ::AuthServerVerificationMessage* release_authserververificationmessage();
  ::AuthServerVerificationMessage* mutable_authserververificationmessage();
  void set_allocated_authserververificationmessage(::AuthServerVerificationMessage* authserververificationmessage);

  // optional .InitAckMessage initAckMessage = 7;
  bool has_initackmessage() const;
  void clear_initackmessage();
  static const int kInitAckMessageFieldNumber = 7;
  const ::InitAckMessage& initackmessage() const;
  ::InitAckMessage* release_initackmessage();
  ::InitAckMessage* mutable_initackmessage();
  void set_allocated_initackmessage(::InitAckMessage* initackmessage);

  // optional .AvatarRequestMessage avatarRequestMessage = 8;
  bool has_avatarrequestmessage() const;
  void clear_avatarrequestmessage();
  static const int kAvatarRequestMessageFieldNumber = 8;
  const ::AvatarRequestMessage& avatarrequestmessage() const;
  ::AvatarRequestMessage* release_avatarrequestmessage();
  ::AvatarRequestMessage* mutable_avatarrequestmessage();
  void set_allocated_avatarrequestmessage(::AvatarRequestMessage* avatarrequestmessage);

  // optional .AvatarHeaderMessage avatarHeaderMessage = 9;
  bool has_avatarheadermessage() const;
  void clear_avatarheadermessage();
  static const int kAvatarHeaderMessageFieldNumber = 9;
  const ::AvatarHeaderMessage& avatarheadermessage() const;
  ::AvatarHeaderMessage* release_avatarheadermessage();
  ::AvatarHeaderMessage* mutable_avatarheadermessage();
  void set_allocated_avatarheadermessage(::AvatarHeaderMessage* avatarheadermessage);

  // optional .AvatarDataMessage avatarDataMessage = 10;
  bool has_avatardatamessage() const;
  void clear_avatardatamessage();
  static const int kAvatarDataMessageFieldNumber = 10;
  const ::AvatarDataMessage& avatardatamessage() const;
  ::AvatarDataMessage* release_avatardatamessage();
  ::AvatarDataMessage* mutable_avatardatamessage();
  void set_allocated_avatardatamessage(::AvatarDataMessage* avatardatamessage);

  // optional .AvatarEndMessage avatarEndMessage = 11;
  bool has_avatarendmessage() const;
  void clear_avatarendmessage();
  static const int kAvatarEndMessageFieldNumber = 11;
  const ::AvatarEndMessage& avatarendmessage() const;
  ::AvatarEndMessage* release_avatarendmessage();
  ::AvatarEndMessage* mutable_avatarendmessage();
  void set_allocated_avatarendmessage(::AvatarEndMessage* avatarendmessage);

  // optional .UnknownAvatarMessage unknownAvatarMessage = 12;
  bool has_unknownavatarmessage() const;
  void clear_unknownavatarmessage();
  static const int kUnknownAvatarMessageFieldNumber = 12;
  const ::UnknownAvatarMessage& unknownavatarmessage() const;
  ::UnknownAvatarMessage* release_unknownavatarmessage();
  ::UnknownAvatarMessage* mutable_unknownavatarmessage();
  void set_allocated_unknownavatarmessage(::UnknownAvatarMessage* unknownavatarmessage);

  // optional .PlayerListMessage playerListMessage = 13;
  bool has_playerlistmessage() const;
  void clear_playerlistmessage();
  static const int kPlayerListMessageFieldNumber = 13;
  const ::PlayerListMessage& playerlistmessage() const;
  ::PlayerListMessage* release_playerlistmessage();
  ::PlayerListMessage* mutable_playerlistmessage();
  void set_allocated_playerlistmessage(::PlayerListMessage* playerlistmessage);

  // optional .GameListNewMessage gameListNewMessage = 14;
  bool has_gamelistnewmessage() const;
  void clear_gamelistnewmessage();
  static const int kGameListNewMessageFieldNumber = 14;
  const ::GameListNewMessage& gamelistnewmessage() const;
  ::GameListNewMessage* release_gamelistnewmessage();
  ::GameListNewMessage* mutable_gamelistnewmessage();
  void set_allocated_gamelistnewmessage(::GameListNewMessage* gamelistnewmessage);

  // optional .GameListUpdateMessage gameListUpdateMessage = 15;
  bool has_gamelistupdatemessage() const;
  void clear_gamelistupdatemessage();
  static const int kGameListUpdateMessageFieldNumber = 15;
  const ::GameListUpdateMessage& gamelistupdatemessage() const;
  ::GameListUpdateMessage* release_gamelistupdatemessage();
  ::GameListUpdateMessage* mutable_gamelistupdatemessage();
  void set_allocated_gamelistupdatemessage(::GameListUpdateMessage* gamelistupdatemessage);

  // optional .GameListPlayerJoinedMessage gameListPlayerJoinedMessage = 16;
  bool has_gamelistplayerjoinedmessage() const;
  void clear_gamelistplayerjoinedmessage();
  static const int kGameListPlayerJoinedMessageFieldNumber = 16;
  const ::GameListPlayerJoinedMessage& gamelistplayerjoinedmessage() const;
  ::GameListPlayerJoinedMessage* release_gamelistplayerjoinedmessage();
  ::GameListPlayerJoinedMessage* mutable_gamelistplayerjoinedmessage();
  void set_allocated_gamelistplayerjoinedmessage(::GameListPlayerJoinedMessage* gamelistplayerjoinedmessage);

  // optional .GameListPlayerLeftMessage gameListPlayerLeftMessage = 17;
  bool has_gamelistplayerleftmessage() const;
  void clear_gamelistplayerleftmessage();
  static const int kGameListPlayerLeftMessageFieldNumber = 17;
  const ::GameListPlayerLeftMessage& gamelistplayerleftmessage() const;
  ::GameListPlayerLeftMessage* release_gamelistplayerleftmessage();
  ::GameListPlayerLeftMessage* mutable_gamelistplayerleftmessage();
  void set_allocated_gamelistplayerleftmessage(::GameListPlayerLeftMessage* gamelistplayerleftmessage);

  // optional .GameListAdminChangedMessage gameListAdminChangedMessage = 18;
  bool has_gamelistadminchangedmessage() const;
  void clear_gamelistadminchangedmessage();
  static const int kGameListAdminChangedMessageFieldNumber = 18;
  const ::GameListAdminChangedMessage& gamelistadminchangedmessage() const;
  ::GameListAdminChangedMessage* release_gamelistadminchangedmessage();
  ::GameListAdminChangedMessage* mutable_gamelistadminchangedmessage();
  void set_allocated_gamelistadminchangedmessage(::GameListAdminChangedMessage* gamelistadminchangedmessage);

  // optional .PlayerInfoRequestMessage playerInfoRequestMessage = 19;
  bool has_playerinforequestmessage() const;
  void clear_playerinforequestmessage();
  static const int kPlayerInfoRequestMessageFieldNumber = 19;
  const ::PlayerInfoRequestMessage& playerinforequestmessage() const;
  ::PlayerInfoRequestMessage* release_playerinforequestmessage();
  ::PlayerInfoRequestMessage* mutable_playerinforequestmessage();
  void set_allocated_playerinforequestmessage(::PlayerInfoRequestMessage* playerinforequestmessage);

  // optional .PlayerInfoReplyMessage playerInfoReplyMessage = 20;
  bool has_playerinforeplymessage() const;
  void clear_playerinforeplymessage();
  static const int kPlayerInfoReplyMessageFieldNumber = 20;
  const ::PlayerInfoReplyMessage& playerinforeplymessage() const;
  ::PlayerInfoReplyMessage* release_playerinforeplymessage();
  ::PlayerInfoReplyMessage* mutable_playerinforeplymessage();
  void set_allocated_playerinforeplymessage(::PlayerInfoReplyMessage* playerinforeplymessage);

  // optional .SubscriptionRequestMessage subscriptionRequestMessage = 21;
  bool has_subscriptionrequestmessage() const;
  void clear_subscriptionrequestmessage();
  static const int kSubscriptionRequestMessageFieldNumber = 21;
  const ::SubscriptionRequestMessage& subscriptionrequestmessage() const;
  ::SubscriptionRequestMessage* release_subscriptionrequestmessage();
  ::SubscriptionRequestMessage* mutable_subscriptionrequestmessage();
  void set_allocated_subscriptionrequestmessage(::SubscriptionRequestMessage* subscriptionrequestmessage);

  // optional .JoinExistingGameMessage joinExistingGameMessage = 22;
  bool has_joinexistinggamemessage() const;
  void clear_joinexistinggamemessage();
  static const int kJoinExistingGameMessageFieldNumber = 22;
  const ::JoinExistingGameMessage& joinexistinggamemessage() const;
  ::JoinExistingGameMessage* release_joinexistinggamemessage();
  ::JoinExistingGameMessage* mutable_joinexistinggamemessage();
  void set_allocated_joinexistinggamemessage(::JoinExistingGameMessage* joinexistinggamemessage);

  // optional .JoinNewGameMessage joinNewGameMessage = 23;
  bool has_joinnewgamemessage() const;
  void clear_joinnewgamemessage();
  static const int kJoinNewGameMessageFieldNumber = 23;
  const ::JoinNewGameMessage& joinnewgamemessage() const;
  ::JoinNewGameMessage* release_joinnewgamemessage();
  ::JoinNewGameMessage* mutable_joinnewgamemessage();
  void set_allocated_joinnewgamemessage(::JoinNewGameMessage* joinnewgamemessage);

  // optional .RejoinExistingGameMessage rejoinExistingGameMessage = 24;
  bool has_rejoinexistinggamemessage() const;
  void clear_rejoinexistinggamemessage();
  static const int kRejoinExistingGameMessageFieldNumber = 24;
  const ::RejoinExistingGameMessage& rejoinexistinggamemessage() const;
  ::RejoinExistingGameMessage* release_rejoinexistinggamemessage();
  ::RejoinExistingGameMessage* mutable_rejoinexistinggamemessage();
  void set_allocated_rejoinexistinggamemessage(::RejoinExistingGameMessage* rejoinexistinggamemessage);

  // optional .JoinGameAckMessage joinGameAckMessage = 25;
  bool has_joingameackmessage() const;
  void clear_joingameackmessage();
  static const int kJoinGameAckMessageFieldNumber = 25;
  const ::JoinGameAckMessage& joingameackmessage() const;
  ::JoinGameAckMessage* release_joingameackmessage();
  ::JoinGameAckMessage* mutable_joingameackmessage();
  void set_allocated_joingameackmessage(::JoinGameAckMessage* joingameackmessage);

  // optional .JoinGameFailedMessage joinGameFailedMessage = 26;
  bool has_joingamefailedmessage() const;
  void clear_joingamefailedmessage();
  static const int kJoinGameFailedMessageFieldNumber = 26;
  const ::JoinGameFailedMessage& joingamefailedmessage() const;
  ::JoinGameFailedMessage* release_joingamefailedmessage();
  ::JoinGameFailedMessage* mutable_joingamefailedmessage();
  void set_allocated_joingamefailedmessage(::JoinGameFailedMessage* joingamefailedmessage);

  // optional .GamePlayerJoinedMessage gamePlayerJoinedMessage = 27;
  bool has_gameplayerjoinedmessage() const;
  void clear_gameplayerjoinedmessage();
  static const int kGamePlayerJoinedMessageFieldNumber = 27;
  const ::GamePlayerJoinedMessage& gameplayerjoinedmessage() const;
  ::GamePlayerJoinedMessage* release_gameplayerjoinedmessage();
  ::GamePlayerJoinedMessage* mutable_gameplayerjoinedmessage();
  void set_allocated_gameplayerjoinedmessage(::GamePlayerJoinedMessage* gameplayerjoinedmessage);

  // optional .GamePlayerLeftMessage gamePlayerLeftMessage = 28;
  bool has_gameplayerleftmessage() const;
  void clear_gameplayerleftmessage();
  static const int kGamePlayerLeftMessageFieldNumber = 28;
  const ::GamePlayerLeftMessage& gameplayerleftmessage() const;
  ::GamePlayerLeftMessage* release_gameplayerleftmessage();
  ::GamePlayerLeftMessage* mutable_gameplayerleftmessage();
  void set_allocated_gameplayerleftmessage(::GamePlayerLeftMessage* gameplayerleftmessage);

  // optional .GameAdminChangedMessage gameAdminChangedMessage = 29;
  bool has_gameadminchangedmessage() const;
  void clear_gameadminchangedmessage();
  static const int kGameAdminChangedMessageFieldNumber = 29;
  const ::GameAdminChangedMessage& gameadminchangedmessage() const;
  ::GameAdminChangedMessage* release_gameadminchangedmessage();
  ::GameAdminChangedMessage* mutable_gameadminchangedmessage();
  void set_allocated_gameadminchangedmessage(::GameAdminChangedMessage* gameadminchangedmessage);

  // optional .RemovedFromGameMessage removedFromGameMessage = 30;
  bool has_removedfromgamemessage() const;
  void clear_removedfromgamemessage();
  static const int kRemovedFromGameMessageFieldNumber = 30;
  const ::RemovedFromGameMessage& removedfromgamemessage() const;
  ::RemovedFromGameMessage* release_removedfromgamemessage();
  ::RemovedFromGameMessage* mutable_removedfromgamemessage();
  void set_allocated_removedfromgamemessage(::RemovedFromGameMessage* removedfromgamemessage);

  // optional .KickPlayerRequestMessage kickPlayerRequestMessage = 31;
  bool has_kickplayerrequestmessage() const;
  void clear_kickplayerrequestmessage();
  static const int kKickPlayerRequestMessageFieldNumber = 31;
  const ::KickPlayerRequestMessage& kickplayerrequestmessage() const;
  ::KickPlayerRequestMessage* release_kickplayerrequestmessage();
  ::KickPlayerRequestMessage* mutable_kickplayerrequestmessage();
  void set_allocated_kickplayerrequestmessage(::KickPlayerRequestMessage* kickplayerrequestmessage);

  // optional .LeaveGameRequestMessage leaveGameRequestMessage = 32;
  bool has_leavegamerequestmessage() const;
  void clear_leavegamerequestmessage();
  static const int kLeaveGameRequestMessageFieldNumber = 32;
  const ::LeaveGameRequestMessage& leavegamerequestmessage() const;
  ::LeaveGameRequestMessage* release_leavegamerequestmessage();
  ::LeaveGameRequestMessage* mutable_leavegamerequestmessage();
  void set_allocated_leavegamerequestmessage(::LeaveGameRequestMessage* leavegamerequestmessage);

  // optional .InvitePlayerToGameMessage invitePlayerToGameMessage = 33;
  bool has_inviteplayertogamemessage() const;
  void clear_inviteplayertogamemessage();
  static const int kInvitePlayerToGameMessageFieldNumber = 33;
  const ::InvitePlayerToGameMessage& inviteplayertogamemessage() const;
  ::InvitePlayerToGameMessage* release_inviteplayertogamemessage();
  ::InvitePlayerToGameMessage* mutable_inviteplayertogamemessage();
  void set_allocated_inviteplayertogamemessage(::InvitePlayerToGameMessage* inviteplayertogamemessage);

  // optional .InviteNotifyMessage inviteNotifyMessage = 34;
  bool has_invitenotifymessage() const;
  void clear_invitenotifymessage();
  static const int kInviteNotifyMessageFieldNumber = 34;
  const ::InviteNotifyMessage& invitenotifymessage() const;
  ::InviteNotifyMessage* release_invitenotifymessage();
  ::InviteNotifyMessage* mutable_invitenotifymessage();
  void set_allocated_invitenotifymessage(::InviteNotifyMessage* invitenotifymessage);

  // optional .RejectGameInvitationMessage rejectGameInvitationMessage = 35;
  bool has_rejectgameinvitationmessage() const;
  void clear_rejectgameinvitationmessage();
  static const int kRejectGameInvitationMessageFieldNumber = 35;
  const ::RejectGameInvitationMessage& rejectgameinvitationmessage() const;
  ::RejectGameInvitationMessage* release_rejectgameinvitationmessage();
  ::RejectGameInvitationMessage* mutable_rejectgameinvitationmessage();
  void set_allocated_rejectgameinvitationmessage(::RejectGameInvitationMessage* rejectgameinvitationmessage);

  // optional .RejectInvNotifyMessage rejectInvNotifyMessage = 36;
  bool has_rejectinvnotifymessage() const;
  void clear_rejectinvnotifymessage();
  static const int kRejectInvNotifyMessageFieldNumber = 36;
  const ::RejectInvNotifyMessage& rejectinvnotifymessage() const;
  ::RejectInvNotifyMessage* release_rejectinvnotifymessage();
  ::RejectInvNotifyMessage* mutable_rejectinvnotifymessage();
  void set_allocated_rejectinvnotifymessage(::RejectInvNotifyMessage* rejectinvnotifymessage);

  // optional .StartEventMessage startEventMessage = 37;
  bool has_starteventmessage() const;
  void clear_starteventmessage();
  static const int kStartEventMessageFieldNumber = 37;
  const ::StartEventMessage& starteventmessage() const;
  ::StartEventMessage* release_starteventmessage();
  ::StartEventMessage* mutable_starteventmessage();
  void set_allocated_starteventmessage(::StartEventMessage* starteventmessage);

  // optional .StartEventAckMessage startEventAckMessage = 38;
  bool has_starteventackmessage() const;
  void clear_starteventackmessage();
  static const int kStartEventAckMessageFieldNumber = 38;
  const ::StartEventAckMessage& starteventackmessage() const;
  ::StartEventAckMessage* release_starteventackmessage();
  ::StartEventAckMessage* mutable_starteventackmessage();
  void set_allocated_starteventackmessage(::StartEventAckMessage* starteventackmessage);

  // optional .GameStartInitialMessage gameStartInitialMessage = 39;
  bool has_gamestartinitialmessage() const;
  void clear_gamestartinitialmessage();
  static const int kGameStartInitialMessageFieldNumber = 39;
  const ::GameStartInitialMessage& gamestartinitialmessage() const;
  ::GameStartInitialMessage* release_gamestartinitialmessage();
  ::GameStartInitialMessage* mutable_gamestartinitialmessage();
  void set_allocated_gamestartinitialmessage(::GameStartInitialMessage* gamestartinitialmessage);

  // optional .GameStartRejoinMessage gameStartRejoinMessage = 40;
  bool has_gamestartrejoinmessage() const;
  void clear_gamestartrejoinmessage();
  static const int kGameStartRejoinMessageFieldNumber = 40;
  const ::GameStartRejoinMessage& gamestartrejoinmessage() const;
  ::GameStartRejoinMessage* release_gamestartrejoinmessage();
  ::GameStartRejoinMessage* mutable_gamestartrejoinmessage();
  void set_allocated_gamestartrejoinmessage(::GameStartRejoinMessage* gamestartrejoinmessage);

  // optional .HandStartMessage handStartMessage = 41;
  bool has_handstartmessage() const;
  void clear_handstartmessage();
  static const int kHandStartMessageFieldNumber = 41;
  const ::HandStartMessage& handstartmessage() const;
  ::HandStartMessage* release_handstartmessage();
  ::HandStartMessage* mutable_handstartmessage();
  void set_allocated_handstartmessage(::HandStartMessage* handstartmessage);

  // optional .PlayersTurnMessage playersTurnMessage = 42;
  bool has_playersturnmessage() const;
  void clear_playersturnmessage();
  static const int kPlayersTurnMessageFieldNumber = 42;
  const ::PlayersTurnMessage& playersturnmessage() const;
  ::PlayersTurnMessage* release_playersturnmessage();
  ::PlayersTurnMessage* mutable_playersturnmessage();
  void set_allocated_playersturnmessage(::PlayersTurnMessage* playersturnmessage);

  // optional .MyActionRequestMessage myActionRequestMessage = 43;
  bool has_myactionrequestmessage() const;
  void clear_myactionrequestmessage();
  static const int kMyActionRequestMessageFieldNumber = 43;
  const ::MyActionRequestMessage& myactionrequestmessage() const;
  ::MyActionRequestMessage* release_myactionrequestmessage();
  ::MyActionRequestMessage* mutable_myactionrequestmessage();
  void set_allocated_myactionrequestmessage(::MyActionRequestMessage* myactionrequestmessage);

  // optional .YourActionRejectedMessage yourActionRejectedMessage = 44;
  bool has_youractionrejectedmessage() const;
  void clear_youractionrejectedmessage();
  static const int kYourActionRejectedMessageFieldNumber = 44;
  const ::YourActionRejectedMessage& youractionrejectedmessage() const;
  ::YourActionRejectedMessage* release_youractionrejectedmessage();
  ::YourActionRejectedMessage* mutable_youractionrejectedmessage();
  void set_allocated_youractionrejectedmessage(::YourActionRejectedMessage* youractionrejectedmessage);

  // optional .PlayersActionDoneMessage playersActionDoneMessage = 45;
  bool has_playersactiondonemessage() const;
  void clear_playersactiondonemessage();
  static const int kPlayersActionDoneMessageFieldNumber = 45;
  const ::PlayersActionDoneMessage& playersactiondonemessage() const;
  ::PlayersActionDoneMessage* release_playersactiondonemessage();
  ::PlayersActionDoneMessage* mutable_playersactiondonemessage();
  void set_allocated_playersactiondonemessage(::PlayersActionDoneMessage* playersactiondonemessage);

  // optional .DealFlopCardsMessage dealFlopCardsMessage = 46;
  bool has_dealflopcardsmessage() const;
  void clear_dealflopcardsmessage();
  static const int kDealFlopCardsMessageFieldNumber = 46;
  const ::DealFlopCardsMessage& dealflopcardsmessage() const;
  ::DealFlopCardsMessage* release_dealflopcardsmessage();
  ::DealFlopCardsMessage* mutable_dealflopcardsmessage();
  void set_allocated_dealflopcardsmessage(::DealFlopCardsMessage* dealflopcardsmessage);

  // optional .DealTurnCardMessage dealTurnCardMessage = 47;
  bool has_dealturncardmessage() const;
  void clear_dealturncardmessage();
  static const int kDealTurnCardMessageFieldNumber = 47;
  const ::DealTurnCardMessage& dealturncardmessage() const;
  ::DealTurnCardMessage* release_dealturncardmessage();
  ::DealTurnCardMessage* mutable_dealturncardmessage();
  void set_allocated_dealturncardmessage(::DealTurnCardMessage* dealturncardmessage);

  // optional .DealRiverCardMessage dealRiverCardMessage = 48;
  bool has_dealrivercardmessage() const;
  void clear_dealrivercardmessage();
  static const int kDealRiverCardMessageFieldNumber = 48;
  const ::DealRiverCardMessage& dealrivercardmessage() const;
  ::DealRiverCardMessage* release_dealrivercardmessage();
  ::DealRiverCardMessage* mutable_dealrivercardmessage();
  void set_allocated_dealrivercardmessage(::DealRiverCardMessage* dealrivercardmessage);

  // optional .AllInShowCardsMessage allInShowCardsMessage = 49;
  bool has_allinshowcardsmessage() const;
  void clear_allinshowcardsmessage();
  static const int kAllInShowCardsMessageFieldNumber = 49;
  const ::AllInShowCardsMessage& allinshowcardsmessage() const;
  ::AllInShowCardsMessage* release_allinshowcardsmessage();
  ::AllInShowCardsMessage* mutable_allinshowcardsmessage();
  void set_allocated_allinshowcardsmessage(::AllInShowCardsMessage* allinshowcardsmessage);

  // optional .EndOfHandShowCardsMessage endOfHandShowCardsMessage = 50;
  bool has_endofhandshowcardsmessage() const;
  void clear_endofhandshowcardsmessage();
  static const int kEndOfHandShowCardsMessageFieldNumber = 50;
  const ::EndOfHandShowCardsMessage& endofhandshowcardsmessage() const;
  ::EndOfHandShowCardsMessage* release_endofhandshowcardsmessage();
  ::EndOfHandShowCardsMessage* mutable_endofhandshowcardsmessage();
  void set_allocated_endofhandshowcardsmessage(::EndOfHandShowCardsMessage* endofhandshowcardsmessage);

  // optional .EndOfHandHideCardsMessage endOfHandHideCardsMessage = 51;
  bool has_endofhandhidecardsmessage() const;
  void clear_endofhandhidecardsmessage();
  static const int kEndOfHandHideCardsMessageFieldNumber = 51;
  const ::EndOfHandHideCardsMessage& endofhandhidecardsmessage() const;
  ::EndOfHandHideCardsMessage* release_endofhandhidecardsmessage();
  ::EndOfHandHideCardsMessage* mutable_endofhandhidecardsmessage();
  void set_allocated_endofhandhidecardsmessage(::EndOfHandHideCardsMessage* endofhandhidecardsmessage);

  // optional .ShowMyCardsRequestMessage showMyCardsRequestMessage = 52;
  bool has_showmycardsrequestmessage() const;
  void clear_showmycardsrequestmessage();
  static const int kShowMyCardsRequestMessageFieldNumber = 52;
  const ::ShowMyCardsRequestMessage& showmycardsrequestmessage() const;
  ::ShowMyCardsRequestMessage* release_showmycardsrequestmessage();
  ::ShowMyCardsRequestMessage* mutable_showmycardsrequestmessage();
  void set_allocated_showmycardsrequestmessage(::ShowMyCardsRequestMessage* showmycardsrequestmessage);

  // optional .AfterHandShowCardsMessage afterHandShowCardsMessage = 53;
  bool has_afterhandshowcardsmessage() const;
  void clear_afterhandshowcardsmessage();
  static const int kAfterHandShowCardsMessageFieldNumber = 53;
  const ::AfterHandShowCardsMessage& afterhandshowcardsmessage() const;
  ::AfterHandShowCardsMessage* release_afterhandshowcardsmessage();
  ::AfterHandShowCardsMessage* mutable_afterhandshowcardsmessage();
  void set_allocated_afterhandshowcardsmessage(::AfterHandShowCardsMessage* afterhandshowcardsmessage);

  // optional .EndOfGameMessage endOfGameMessage = 54;
  bool has_endofgamemessage() const;
  void clear_endofgamemessage();
  static const int kEndOfGameMessageFieldNumber = 54;
  const ::EndOfGameMessage& endofgamemessage() const;
  ::EndOfGameMessage* release_endofgamemessage();
  ::EndOfGameMessage* mutable_endofgamemessage();
  void set_allocated_endofgamemessage(::EndOfGameMessage* endofgamemessage);

  // optional .PlayerIdChangedMessage playerIdChangedMessage = 55;
  bool has_playeridchangedmessage() const;
  void clear_playeridchangedmessage();
  static const int kPlayerIdChangedMessageFieldNumber = 55;
  const ::PlayerIdChangedMessage& playeridchangedmessage() const;
  ::PlayerIdChangedMessage* release_playeridchangedmessage();
  ::PlayerIdChangedMessage* mutable_playeridchangedmessage();
  void set_allocated_playeridchangedmessage(::PlayerIdChangedMessage* playeridchangedmessage);

  // optional .AskKickPlayerMessage askKickPlayerMessage = 56;
  bool has_askkickplayermessage() const;
  void clear_askkickplayermessage();
  static const int kAskKickPlayerMessageFieldNumber = 56;
  const ::AskKickPlayerMessage& askkickplayermessage() const;
  ::AskKickPlayerMessage* release_askkickplayermessage();
  ::AskKickPlayerMessage* mutable_askkickplayermessage();
  void set_allocated_askkickplayermessage(::AskKickPlayerMessage* askkickplayermessage);

  // optional .AskKickDeniedMessage askKickDeniedMessage = 57;
  bool has_askkickdeniedmessage() const;
  void clear_askkickdeniedmessage();
  static const int kAskKickDeniedMessageFieldNumber = 57;
  const ::AskKickDeniedMessage& askkickdeniedmessage() const;
  ::AskKickDeniedMessage* release_askkickdeniedmessage();
  ::AskKickDeniedMessage* mutable_askkickdeniedmessage();
  void set_allocated_askkickdeniedmessage(::AskKickDeniedMessage* askkickdeniedmessage);

  // optional .StartKickPetitionMessage startKickPetitionMessage = 58;
  bool has_startkickpetitionmessage() const;
  void clear_startkickpetitionmessage();
  static const int kStartKickPetitionMessageFieldNumber = 58;
  const ::StartKickPetitionMessage& startkickpetitionmessage() const;
  ::StartKickPetitionMessage* release_startkickpetitionmessage();
  ::StartKickPetitionMessage* mutable_startkickpetitionmessage();
  void set_allocated_startkickpetitionmessage(::StartKickPetitionMessage* startkickpetitionmessage);

  // optional .VoteKickRequestMessage voteKickRequestMessage = 59;
  bool has_votekickrequestmessage() const;
  void clear_votekickrequestmessage();
  static const int kVoteKickRequestMessageFieldNumber = 59;
  const ::VoteKickRequestMessage& votekickrequestmessage() const;
  ::VoteKickRequestMessage* release_votekickrequestmessage();
  ::VoteKickRequestMessage* mutable_votekickrequestmessage();
  void set_allocated_votekickrequestmessage(::VoteKickRequestMessage* votekickrequestmessage);

  // optional .VoteKickReplyMessage voteKickReplyMessage = 60;
  bool has_votekickreplymessage() const;
  void clear_votekickreplymessage();
  static const int kVoteKickReplyMessageFieldNumber = 60;
  const ::VoteKickReplyMessage& votekickreplymessage() const;
  ::VoteKickReplyMessage* release_votekickreplymessage();
  ::VoteKickReplyMessage* mutable_votekickreplymessage();
  void set_allocated_votekickreplymessage(::VoteKickReplyMessage* votekickreplymessage);

  // optional .KickPetitionUpdateMessage kickPetitionUpdateMessage = 61;
  bool has_kickpetitionupdatemessage() const;
  void clear_kickpetitionupdatemessage();
  static const int kKickPetitionUpdateMessageFieldNumber = 61;
  const ::KickPetitionUpdateMessage& kickpetitionupdatemessage() const;
  ::KickPetitionUpdateMessage* release_kickpetitionupdatemessage();
  ::KickPetitionUpdateMessage* mutable_kickpetitionupdatemessage();
  void set_allocated_kickpetitionupdatemessage(::KickPetitionUpdateMessage* kickpetitionupdatemessage);

  // optional .EndKickPetitionMessage endKickPetitionMessage = 62;
  bool has_endkickpetitionmessage() const;
  void clear_endkickpetitionmessage();
  static const int kEndKickPetitionMessageFieldNumber = 62;
  const ::EndKickPetitionMessage& endkickpetitionmessage() const;
  ::EndKickPetitionMessage* release_endkickpetitionmessage();
  ::EndKickPetitionMessage* mutable_endkickpetitionmessage();
  void set_allocated_endkickpetitionmessage(::EndKickPetitionMessage* endkickpetitionmessage);

  // optional .StatisticsMessage statisticsMessage = 63;
  bool has_statisticsmessage() const;
  void clear_statisticsmessage();
  static const int kStatisticsMessageFieldNumber = 63;
  const ::StatisticsMessage& statisticsmessage() const;
  ::StatisticsMessage* release_statisticsmessage();
  ::StatisticsMessage* mutable_statisticsmessage();
  void set_allocated_statisticsmessage(::StatisticsMessage* statisticsmessage);

  // optional .ChatRequestMessage chatRequestMessage = 64;
  bool has_chatrequestmessage() const;
  void clear_chatrequestmessage();
  static const int kChatRequestMessageFieldNumber = 64;
  const ::ChatRequestMessage& chatrequestmessage() const;
  ::ChatRequestMessage* release_chatrequestmessage();
  ::ChatRequestMessage* mutable_chatrequestmessage();
  void set_allocated_chatrequestmessage(::ChatRequestMessage* chatrequestmessage);

  // optional .ChatMessage chatMessage = 65;
  bool has_chatmessage() const;
  void clear_chatmessage();
  static const int kChatMessageFieldNumber = 65;
  const ::ChatMessage& chatmessage() const;
  ::ChatMessage* release_chatmessage();
  ::ChatMessage* mutable_chatmessage();
  void set_allocated_chatmessage(::ChatMessage* chatmessage);

  // optional .ChatRejectMessage chatRejectMessage = 66;
  bool has_chatrejectmessage() const;
  void clear_chatrejectmessage();
  static const int kChatRejectMessageFieldNumber = 66;
  const ::ChatRejectMessage& chatrejectmessage() const;
  ::ChatRejectMessage* release_chatrejectmessage();
  ::ChatRejectMessage* mutable_chatrejectmessage();
  void set_allocated_chatrejectmessage(::ChatRejectMessage* chatrejectmessage);

  // optional .DialogMessage dialogMessage = 67;
  bool has_dialogmessage() const;
  void clear_dialogmessage();
  static const int kDialogMessageFieldNumber = 67;
  const ::DialogMessage& dialogmessage() const;
  ::DialogMessage* release_dialogmessage();
  ::DialogMessage* mutable_dialogmessage();
  void set_allocated_dialogmessage(::DialogMessage* dialogmessage);

  // optional .TimeoutWarningMessage timeoutWarningMessage = 68;
  bool has_timeoutwarningmessage() const;
  void clear_timeoutwarningmessage();
  static const int kTimeoutWarningMessageFieldNumber = 68;
  const ::TimeoutWarningMessage& timeoutwarningmessage() const;
  ::TimeoutWarningMessage* release_timeoutwarningmessage();
  ::TimeoutWarningMessage* mutable_timeoutwarningmessage();
  void set_allocated_timeoutwarningmessage(::TimeoutWarningMessage* timeoutwarningmessage);

  // optional .ResetTimeoutMessage resetTimeoutMessage = 69;
  bool has_resettimeoutmessage() const;
  void clear_resettimeoutmessage();
  static const int kResetTimeoutMessageFieldNumber = 69;
  const ::ResetTimeoutMessage& resettimeoutmessage() const;
  ::ResetTimeoutMessage* release_resettimeoutmessage();
  ::ResetTimeoutMessage* mutable_resettimeoutmessage();
  void set_allocated_resettimeoutmessage(::ResetTimeoutMessage* resettimeoutmessage);

  // optional .ReportAvatarMessage reportAvatarMessage = 70;
  bool has_reportavatarmessage() const;
  void clear_reportavatarmessage();
  static const int kReportAvatarMessageFieldNumber = 70;
  const ::ReportAvatarMessage& reportavatarmessage() const;
  ::ReportAvatarMessage* release_reportavatarmessage();
  ::ReportAvatarMessage* mutable_reportavatarmessage();
  void set_allocated_reportavatarmessage(::ReportAvatarMessage* reportavatarmessage);

  // optional .ReportAvatarAckMessage reportAvatarAckMessage = 71;
  bool has_reportavatarackmessage() const;
  void clear_reportavatarackmessage();
  static const int kReportAvatarAckMessageFieldNumber = 71;
  const ::ReportAvatarAckMessage& reportavatarackmessage() const;
  ::ReportAvatarAckMessage* release_reportavatarackmessage();
  ::ReportAvatarAckMessage* mutable_reportavatarackmessage();
  void set_allocated_reportavatarackmessage(::ReportAvatarAckMessage* reportavatarackmessage);

  // optional .ReportGameMessage reportGameMessage = 72;
  bool has_reportgamemessage() const;
  void clear_reportgamemessage();
  static const int kReportGameMessageFieldNumber = 72;
  const ::ReportGameMessage& reportgamemessage() const;
  ::ReportGameMessage* release_reportgamemessage();
  ::ReportGameMessage* mutable_reportgamemessage();
  void set_allocated_reportgamemessage(::ReportGameMessage* reportgamemessage);

  // optional .ReportGameAckMessage reportGameAckMessage = 73;
  bool has_reportgameackmessage() const;
  void clear_reportgameackmessage();
  static const int kReportGameAckMessageFieldNumber = 73;
  const ::ReportGameAckMessage& reportgameackmessage() const;
  ::ReportGameAckMessage* release_reportgameackmessage();
  ::ReportGameAckMessage* mutable_reportgameackmessage();
  void set_allocated_reportgameackmessage(::ReportGameAckMessage* reportgameackmessage);

  // optional .ErrorMessage errorMessage = 74;
  bool has_errormessage() const;
  void clear_errormessage();
  static const int kErrorMessageFieldNumber = 74;
  const ::ErrorMessage& errormessage() const;
  ::ErrorMessage* release_errormessage();
  ::ErrorMessage* mutable_errormessage();
  void set_allocated_errormessage(::ErrorMessage* errormessage);

  // optional .AdminRemoveGameMessage adminRemoveGameMessage = 75;
  bool has_adminremovegamemessage() const;
  void clear_adminremovegamemessage();
  static const int kAdminRemoveGameMessageFieldNumber = 75;
  const ::AdminRemoveGameMessage& adminremovegamemessage() const;
  ::AdminRemoveGameMessage* release_adminremovegamemessage();
  ::AdminRemoveGameMessage* mutable_adminremovegamemessage();
  void set_allocated_adminremovegamemessage(::AdminRemoveGameMessage* adminremovegamemessage);

  // optional .AdminRemoveGameAckMessage adminRemoveGameAckMessage = 76;
  bool has_adminremovegameackmessage() const;
  void clear_adminremovegameackmessage();
  static const int kAdminRemoveGameAckMessageFieldNumber = 76;
  const ::AdminRemoveGameAckMessage& adminremovegameackmessage() const;
  ::AdminRemoveGameAckMessage* release_adminremovegameackmessage();
  ::AdminRemoveGameAckMessage* mutable_adminremovegameackmessage();
  void set_allocated_adminremovegameackmessage(::AdminRemoveGameAckMessage* adminremovegameackmessage);

  // optional .AdminBanPlayerMessage adminBanPlayerMessage = 77;
  bool has_adminbanplayermessage() const;
  void clear_adminbanplayermessage();
  static const int kAdminBanPlayerMessageFieldNumber = 77;
  const ::AdminBanPlayerMessage& adminbanplayermessage() const;
  ::AdminBanPlayerMessage* release_adminbanplayermessage();
  ::AdminBanPlayerMessage* mutable_adminbanplayermessage();
  void set_allocated_adminbanplayermessage(::AdminBanPlayerMessage* adminbanplayermessage);

  // optional .AdminBanPlayerAckMessage adminBanPlayerAckMessage = 78;
  bool has_adminbanplayerackmessage() const;
  void clear_adminbanplayerackmessage();
  static const int kAdminBanPlayerAckMessageFieldNumber = 78;
  const ::AdminBanPlayerAckMessage& adminbanplayerackmessage() const;
  ::AdminBanPlayerAckMessage* release_adminbanplayerackmessage();
  ::AdminBanPlayerAckMessage* mutable_adminbanplayerackmessage();
  void set_allocated_adminbanplayerackmessage(::AdminBanPlayerAckMessage* adminbanplayerackmessage);

  // optional .GameListSpectatorJoinedMessage gameListSpectatorJoinedMessage = 79;
  bool has_gamelistspectatorjoinedmessage() const;
  void clear_gamelistspectatorjoinedmessage();
  static const int kGameListSpectatorJoinedMessageFieldNumber = 79;
  const ::GameListSpectatorJoinedMessage& gamelistspectatorjoinedmessage() const;
  ::GameListSpectatorJoinedMessage* release_gamelistspectatorjoinedmessage();
  ::GameListSpectatorJoinedMessage* mutable_gamelistspectatorjoinedmessage();
  void set_allocated_gamelistspectatorjoinedmessage(::GameListSpectatorJoinedMessage* gamelistspectatorjoinedmessage);

  // optional .GameListSpectatorLeftMessage gameListSpectatorLeftMessage = 80;
  bool has_gamelistspectatorleftmessage() const;
  void clear_gamelistspectatorleftmessage();
  static const int kGameListSpectatorLeftMessageFieldNumber = 80;
  const ::GameListSpectatorLeftMessage& gamelistspectatorleftmessage() const;
  ::GameListSpectatorLeftMessage* release_gamelistspectatorleftmessage();
  ::GameListSpectatorLeftMessage* mutable_gamelistspectatorleftmessage();
  void set_allocated_gamelistspectatorleftmessage(::GameListSpectatorLeftMessage* gamelistspectatorleftmessage);

  // optional .GameSpectatorJoinedMessage gameSpectatorJoinedMessage = 81;
  bool has_gamespectatorjoinedmessage() const;
  void clear_gamespectatorjoinedmessage();
  static const int kGameSpectatorJoinedMessageFieldNumber = 81;
  const ::GameSpectatorJoinedMessage& gamespectatorjoinedmessage() const;
  ::GameSpectatorJoinedMessage* release_gamespectatorjoinedmessage();
  ::GameSpectatorJoinedMessage* mutable_gamespectatorjoinedmessage();
  void set_allocated_gamespectatorjoinedmessage(::GameSpectatorJoinedMessage* gamespectatorjoinedmessage);

  // optional .GameSpectatorLeftMessage gameSpectatorLeftMessage = 82;
  bool has_gamespectatorleftmessage() const;
  void clear_gamespectatorleftmessage();
  static const int kGameSpectatorLeftMessageFieldNumber = 82;
  const ::GameSpectatorLeftMessage& gamespectatorleftmessage() const;
  ::GameSpectatorLeftMessage* release_gamespectatorleftmessage();
  ::GameSpectatorLeftMessage* mutable_gamespectatorleftmessage();
  void set_allocated_gamespectatorleftmessage(::GameSpectatorLeftMessage* gamespectatorleftmessage);

  // required .PokerTHMessage.PokerTHMessageType messageType = 1;
  bool has_messagetype() const;
  void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  ::PokerTHMessage_PokerTHMessageType messagetype() const;
  void set_messagetype(::PokerTHMessage_PokerTHMessageType value);

  // @@protoc_insertion_point(class_scope:PokerTHMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<3> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::AnnounceMessage* announcemessage_;
  ::InitMessage* initmessage_;
  ::AuthServerChallengeMessage* authserverchallengemessage_;
  ::AuthClientResponseMessage* authclientresponsemessage_;
  ::AuthServerVerificationMessage* authserververificationmessage_;
  ::InitAckMessage* initackmessage_;
  ::AvatarRequestMessage* avatarrequestmessage_;
  ::AvatarHeaderMessage* avatarheadermessage_;
  ::AvatarDataMessage* avatardatamessage_;
  ::AvatarEndMessage* avatarendmessage_;
  ::UnknownAvatarMessage* unknownavatarmessage_;
  ::PlayerListMessage* playerlistmessage_;
  ::GameListNewMessage* gamelistnewmessage_;
  ::GameListUpdateMessage* gamelistupdatemessage_;
  ::GameListPlayerJoinedMessage* gamelistplayerjoinedmessage_;
  ::GameListPlayerLeftMessage* gamelistplayerleftmessage_;
  ::GameListAdminChangedMessage* gamelistadminchangedmessage_;
  ::PlayerInfoRequestMessage* playerinforequestmessage_;
  ::PlayerInfoReplyMessage* playerinforeplymessage_;
  ::SubscriptionRequestMessage* subscriptionrequestmessage_;
  ::JoinExistingGameMessage* joinexistinggamemessage_;
  ::JoinNewGameMessage* joinnewgamemessage_;
  ::RejoinExistingGameMessage* rejoinexistinggamemessage_;
  ::JoinGameAckMessage* joingameackmessage_;
  ::JoinGameFailedMessage* joingamefailedmessage_;
  ::GamePlayerJoinedMessage* gameplayerjoinedmessage_;
  ::GamePlayerLeftMessage* gameplayerleftmessage_;
  ::GameAdminChangedMessage* gameadminchangedmessage_;
  ::RemovedFromGameMessage* removedfromgamemessage_;
  ::KickPlayerRequestMessage* kickplayerrequestmessage_;
  ::LeaveGameRequestMessage* leavegamerequestmessage_;
  ::InvitePlayerToGameMessage* inviteplayertogamemessage_;
  ::InviteNotifyMessage* invitenotifymessage_;
  ::RejectGameInvitationMessage* rejectgameinvitationmessage_;
  ::RejectInvNotifyMessage* rejectinvnotifymessage_;
  ::StartEventMessage* starteventmessage_;
  ::StartEventAckMessage* starteventackmessage_;
  ::GameStartInitialMessage* gamestartinitialmessage_;
  ::GameStartRejoinMessage* gamestartrejoinmessage_;
  ::HandStartMessage* handstartmessage_;
  ::PlayersTurnMessage* playersturnmessage_;
  ::MyActionRequestMessage* myactionrequestmessage_;
  ::YourActionRejectedMessage* youractionrejectedmessage_;
  ::PlayersActionDoneMessage* playersactiondonemessage_;
  ::DealFlopCardsMessage* dealflopcardsmessage_;
  ::DealTurnCardMessage* dealturncardmessage_;
  ::DealRiverCardMessage* dealrivercardmessage_;
  ::AllInShowCardsMessage* allinshowcardsmessage_;
  ::EndOfHandShowCardsMessage* endofhandshowcardsmessage_;
  ::EndOfHandHideCardsMessage* endofhandhidecardsmessage_;
  ::ShowMyCardsRequestMessage* showmycardsrequestmessage_;
  ::AfterHandShowCardsMessage* afterhandshowcardsmessage_;
  ::EndOfGameMessage* endofgamemessage_;
  ::PlayerIdChangedMessage* playeridchangedmessage_;
  ::AskKickPlayerMessage* askkickplayermessage_;
  ::AskKickDeniedMessage* askkickdeniedmessage_;
  ::StartKickPetitionMessage* startkickpetitionmessage_;
  ::VoteKickRequestMessage* votekickrequestmessage_;
  ::VoteKickReplyMessage* votekickreplymessage_;
  ::KickPetitionUpdateMessage* kickpetitionupdatemessage_;
  ::EndKickPetitionMessage* endkickpetitionmessage_;
  ::StatisticsMessage* statisticsmessage_;
  ::ChatRequestMessage* chatrequestmessage_;
  ::ChatMessage* chatmessage_;
  ::ChatRejectMessage* chatrejectmessage_;
  ::DialogMessage* dialogmessage_;
  ::TimeoutWarningMessage* timeoutwarningmessage_;
  ::ResetTimeoutMessage* resettimeoutmessage_;
  ::ReportAvatarMessage* reportavatarmessage_;
  ::ReportAvatarAckMessage* reportavatarackmessage_;
  ::ReportGameMessage* reportgamemessage_;
  ::ReportGameAckMessage* reportgameackmessage_;
  ::ErrorMessage* errormessage_;
  ::AdminRemoveGameMessage* adminremovegamemessage_;
  ::AdminRemoveGameAckMessage* adminremovegameackmessage_;
  ::AdminBanPlayerMessage* adminbanplayermessage_;
  ::AdminBanPlayerAckMessage* adminbanplayerackmessage_;
  ::GameListSpectatorJoinedMessage* gamelistspectatorjoinedmessage_;
  ::GameListSpectatorLeftMessage* gamelistspectatorleftmessage_;
  ::GameSpectatorJoinedMessage* gamespectatorjoinedmessage_;
  ::GameSpectatorLeftMessage* gamespectatorleftmessage_;
  int messagetype_;
  friend struct ::TableStruct_pokerth_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NetGameInfo

// required string gameName = 1;
inline bool NetGameInfo::has_gamename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetGameInfo::clear_gamename() {
  gamename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& NetGameInfo::gamename() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.gameName)
  return gamename_.GetNoArena();
}
inline void NetGameInfo::set_gamename(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  gamename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetGameInfo.gameName)
}
#if LANG_CXX11
inline void NetGameInfo::set_gamename(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  gamename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NetGameInfo.gameName)
}
#endif
inline void NetGameInfo::set_gamename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  gamename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetGameInfo.gameName)
}
inline void NetGameInfo::set_gamename(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  gamename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetGameInfo.gameName)
}
inline ::std::string* NetGameInfo::mutable_gamename() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:NetGameInfo.gameName)
  return gamename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetGameInfo::release_gamename() {
  // @@protoc_insertion_point(field_release:NetGameInfo.gameName)
  if (!has_gamename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return gamename_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetGameInfo::set_allocated_gamename(::std::string* gamename) {
  if (gamename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gamename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gamename);
  // @@protoc_insertion_point(field_set_allocated:NetGameInfo.gameName)
}

// required .NetGameInfo.NetGameType netGameType = 2;
inline bool NetGameInfo::has_netgametype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NetGameInfo::clear_netgametype() {
  netgametype_ = 1;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::NetGameInfo_NetGameType NetGameInfo::netgametype() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.netGameType)
  return static_cast< ::NetGameInfo_NetGameType >(netgametype_);
}
inline void NetGameInfo::set_netgametype(::NetGameInfo_NetGameType value) {
  assert(::NetGameInfo_NetGameType_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  netgametype_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.netGameType)
}

// required uint32 maxNumPlayers = 3;
inline bool NetGameInfo::has_maxnumplayers() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetGameInfo::clear_maxnumplayers() {
  maxnumplayers_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 NetGameInfo::maxnumplayers() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.maxNumPlayers)
  return maxnumplayers_;
}
inline void NetGameInfo::set_maxnumplayers(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  maxnumplayers_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.maxNumPlayers)
}

// required .NetGameInfo.RaiseIntervalMode raiseIntervalMode = 4;
inline bool NetGameInfo::has_raiseintervalmode() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NetGameInfo::clear_raiseintervalmode() {
  raiseintervalmode_ = 1;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::NetGameInfo_RaiseIntervalMode NetGameInfo::raiseintervalmode() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.raiseIntervalMode)
  return static_cast< ::NetGameInfo_RaiseIntervalMode >(raiseintervalmode_);
}
inline void NetGameInfo::set_raiseintervalmode(::NetGameInfo_RaiseIntervalMode value) {
  assert(::NetGameInfo_RaiseIntervalMode_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  raiseintervalmode_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.raiseIntervalMode)
}

// optional uint32 raiseEveryHands = 5;
inline bool NetGameInfo::has_raiseeveryhands() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetGameInfo::clear_raiseeveryhands() {
  raiseeveryhands_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 NetGameInfo::raiseeveryhands() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.raiseEveryHands)
  return raiseeveryhands_;
}
inline void NetGameInfo::set_raiseeveryhands(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  raiseeveryhands_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.raiseEveryHands)
}

// optional uint32 raiseEveryMinutes = 6;
inline bool NetGameInfo::has_raiseeveryminutes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetGameInfo::clear_raiseeveryminutes() {
  raiseeveryminutes_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 NetGameInfo::raiseeveryminutes() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.raiseEveryMinutes)
  return raiseeveryminutes_;
}
inline void NetGameInfo::set_raiseeveryminutes(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  raiseeveryminutes_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.raiseEveryMinutes)
}

// required .NetGameInfo.EndRaiseMode endRaiseMode = 7;
inline bool NetGameInfo::has_endraisemode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NetGameInfo::clear_endraisemode() {
  endraisemode_ = 1;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::NetGameInfo_EndRaiseMode NetGameInfo::endraisemode() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.endRaiseMode)
  return static_cast< ::NetGameInfo_EndRaiseMode >(endraisemode_);
}
inline void NetGameInfo::set_endraisemode(::NetGameInfo_EndRaiseMode value) {
  assert(::NetGameInfo_EndRaiseMode_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  endraisemode_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.endRaiseMode)
}

// optional uint32 endRaiseSmallBlindValue = 8;
inline bool NetGameInfo::has_endraisesmallblindvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetGameInfo::clear_endraisesmallblindvalue() {
  endraisesmallblindvalue_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 NetGameInfo::endraisesmallblindvalue() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.endRaiseSmallBlindValue)
  return endraisesmallblindvalue_;
}
inline void NetGameInfo::set_endraisesmallblindvalue(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  endraisesmallblindvalue_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.endRaiseSmallBlindValue)
}

// required uint32 proposedGuiSpeed = 9;
inline bool NetGameInfo::has_proposedguispeed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NetGameInfo::clear_proposedguispeed() {
  proposedguispeed_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 NetGameInfo::proposedguispeed() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.proposedGuiSpeed)
  return proposedguispeed_;
}
inline void NetGameInfo::set_proposedguispeed(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  proposedguispeed_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.proposedGuiSpeed)
}

// required uint32 delayBetweenHands = 10;
inline bool NetGameInfo::has_delaybetweenhands() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NetGameInfo::clear_delaybetweenhands() {
  delaybetweenhands_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 NetGameInfo::delaybetweenhands() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.delayBetweenHands)
  return delaybetweenhands_;
}
inline void NetGameInfo::set_delaybetweenhands(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  delaybetweenhands_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.delayBetweenHands)
}

// required uint32 playerActionTimeout = 11;
inline bool NetGameInfo::has_playeractiontimeout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NetGameInfo::clear_playeractiontimeout() {
  playeractiontimeout_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 NetGameInfo::playeractiontimeout() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.playerActionTimeout)
  return playeractiontimeout_;
}
inline void NetGameInfo::set_playeractiontimeout(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  playeractiontimeout_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.playerActionTimeout)
}

// required uint32 firstSmallBlind = 12;
inline bool NetGameInfo::has_firstsmallblind() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NetGameInfo::clear_firstsmallblind() {
  firstsmallblind_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 NetGameInfo::firstsmallblind() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.firstSmallBlind)
  return firstsmallblind_;
}
inline void NetGameInfo::set_firstsmallblind(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  firstsmallblind_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.firstSmallBlind)
}

// required uint32 startMoney = 13;
inline bool NetGameInfo::has_startmoney() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NetGameInfo::clear_startmoney() {
  startmoney_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 NetGameInfo::startmoney() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.startMoney)
  return startmoney_;
}
inline void NetGameInfo::set_startmoney(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  startmoney_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.startMoney)
}

// repeated uint32 manualBlinds = 14 [packed = true];
inline int NetGameInfo::manualblinds_size() const {
  return manualblinds_.size();
}
inline void NetGameInfo::clear_manualblinds() {
  manualblinds_.Clear();
}
inline ::google::protobuf::uint32 NetGameInfo::manualblinds(int index) const {
  // @@protoc_insertion_point(field_get:NetGameInfo.manualBlinds)
  return manualblinds_.Get(index);
}
inline void NetGameInfo::set_manualblinds(int index, ::google::protobuf::uint32 value) {
  manualblinds_.Set(index, value);
  // @@protoc_insertion_point(field_set:NetGameInfo.manualBlinds)
}
inline void NetGameInfo::add_manualblinds(::google::protobuf::uint32 value) {
  manualblinds_.Add(value);
  // @@protoc_insertion_point(field_add:NetGameInfo.manualBlinds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
NetGameInfo::manualblinds() const {
  // @@protoc_insertion_point(field_list:NetGameInfo.manualBlinds)
  return manualblinds_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
NetGameInfo::mutable_manualblinds() {
  // @@protoc_insertion_point(field_mutable_list:NetGameInfo.manualBlinds)
  return &manualblinds_;
}

// optional bool allowSpectators = 15 [default = true];
inline bool NetGameInfo::has_allowspectators() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NetGameInfo::clear_allowspectators() {
  allowspectators_ = true;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool NetGameInfo::allowspectators() const {
  // @@protoc_insertion_point(field_get:NetGameInfo.allowSpectators)
  return allowspectators_;
}
inline void NetGameInfo::set_allowspectators(bool value) {
  _has_bits_[0] |= 0x00002000u;
  allowspectators_ = value;
  // @@protoc_insertion_point(field_set:NetGameInfo.allowSpectators)
}

// -------------------------------------------------------------------

// PlayerResult

// required uint32 playerId = 1;
inline bool PlayerResult::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerResult::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 PlayerResult::playerid() const {
  // @@protoc_insertion_point(field_get:PlayerResult.playerId)
  return playerid_;
}
inline void PlayerResult::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:PlayerResult.playerId)
}

// required uint32 resultCard1 = 2;
inline bool PlayerResult::has_resultcard1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerResult::clear_resultcard1() {
  resultcard1_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 PlayerResult::resultcard1() const {
  // @@protoc_insertion_point(field_get:PlayerResult.resultCard1)
  return resultcard1_;
}
inline void PlayerResult::set_resultcard1(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  resultcard1_ = value;
  // @@protoc_insertion_point(field_set:PlayerResult.resultCard1)
}

// required uint32 resultCard2 = 3;
inline bool PlayerResult::has_resultcard2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerResult::clear_resultcard2() {
  resultcard2_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 PlayerResult::resultcard2() const {
  // @@protoc_insertion_point(field_get:PlayerResult.resultCard2)
  return resultcard2_;
}
inline void PlayerResult::set_resultcard2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  resultcard2_ = value;
  // @@protoc_insertion_point(field_set:PlayerResult.resultCard2)
}

// repeated uint32 bestHandPosition = 4 [packed = true];
inline int PlayerResult::besthandposition_size() const {
  return besthandposition_.size();
}
inline void PlayerResult::clear_besthandposition() {
  besthandposition_.Clear();
}
inline ::google::protobuf::uint32 PlayerResult::besthandposition(int index) const {
  // @@protoc_insertion_point(field_get:PlayerResult.bestHandPosition)
  return besthandposition_.Get(index);
}
inline void PlayerResult::set_besthandposition(int index, ::google::protobuf::uint32 value) {
  besthandposition_.Set(index, value);
  // @@protoc_insertion_point(field_set:PlayerResult.bestHandPosition)
}
inline void PlayerResult::add_besthandposition(::google::protobuf::uint32 value) {
  besthandposition_.Add(value);
  // @@protoc_insertion_point(field_add:PlayerResult.bestHandPosition)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
PlayerResult::besthandposition() const {
  // @@protoc_insertion_point(field_list:PlayerResult.bestHandPosition)
  return besthandposition_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
PlayerResult::mutable_besthandposition() {
  // @@protoc_insertion_point(field_mutable_list:PlayerResult.bestHandPosition)
  return &besthandposition_;
}

// required uint32 moneyWon = 5;
inline bool PlayerResult::has_moneywon() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerResult::clear_moneywon() {
  moneywon_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 PlayerResult::moneywon() const {
  // @@protoc_insertion_point(field_get:PlayerResult.moneyWon)
  return moneywon_;
}
inline void PlayerResult::set_moneywon(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  moneywon_ = value;
  // @@protoc_insertion_point(field_set:PlayerResult.moneyWon)
}

// required uint32 playerMoney = 6;
inline bool PlayerResult::has_playermoney() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerResult::clear_playermoney() {
  playermoney_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 PlayerResult::playermoney() const {
  // @@protoc_insertion_point(field_get:PlayerResult.playerMoney)
  return playermoney_;
}
inline void PlayerResult::set_playermoney(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  playermoney_ = value;
  // @@protoc_insertion_point(field_set:PlayerResult.playerMoney)
}

// optional uint32 cardsValue = 7;
inline bool PlayerResult::has_cardsvalue() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerResult::clear_cardsvalue() {
  cardsvalue_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 PlayerResult::cardsvalue() const {
  // @@protoc_insertion_point(field_get:PlayerResult.cardsValue)
  return cardsvalue_;
}
inline void PlayerResult::set_cardsvalue(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  cardsvalue_ = value;
  // @@protoc_insertion_point(field_set:PlayerResult.cardsValue)
}

// -------------------------------------------------------------------

// AnnounceMessage_Version

// required uint32 majorVersion = 1;
inline bool AnnounceMessage_Version::has_majorversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnnounceMessage_Version::clear_majorversion() {
  majorversion_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 AnnounceMessage_Version::majorversion() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.Version.majorVersion)
  return majorversion_;
}
inline void AnnounceMessage_Version::set_majorversion(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  majorversion_ = value;
  // @@protoc_insertion_point(field_set:AnnounceMessage.Version.majorVersion)
}

// required uint32 minorVersion = 2;
inline bool AnnounceMessage_Version::has_minorversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnnounceMessage_Version::clear_minorversion() {
  minorversion_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 AnnounceMessage_Version::minorversion() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.Version.minorVersion)
  return minorversion_;
}
inline void AnnounceMessage_Version::set_minorversion(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  minorversion_ = value;
  // @@protoc_insertion_point(field_set:AnnounceMessage.Version.minorVersion)
}

// -------------------------------------------------------------------

// AnnounceMessage

// required .AnnounceMessage.Version protocolVersion = 1;
inline bool AnnounceMessage::has_protocolversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnnounceMessage::clear_protocolversion() {
  if (protocolversion_ != nullptr) protocolversion_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::AnnounceMessage_Version& AnnounceMessage::protocolversion() const {
  const ::AnnounceMessage_Version* p = protocolversion_;
  // @@protoc_insertion_point(field_get:AnnounceMessage.protocolVersion)
  return p != nullptr ? *p : *reinterpret_cast<const ::AnnounceMessage_Version*>(
      &::_AnnounceMessage_Version_default_instance_);
}
inline ::AnnounceMessage_Version* AnnounceMessage::release_protocolversion() {
  // @@protoc_insertion_point(field_release:AnnounceMessage.protocolVersion)
  _has_bits_[0] &= ~0x00000001u;
  ::AnnounceMessage_Version* temp = protocolversion_;
  protocolversion_ = nullptr;
  return temp;
}
inline ::AnnounceMessage_Version* AnnounceMessage::mutable_protocolversion() {
  _has_bits_[0] |= 0x00000001u;
  if (protocolversion_ == nullptr) {
    auto* p = CreateMaybeMessage<::AnnounceMessage_Version>(GetArenaNoVirtual());
    protocolversion_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AnnounceMessage.protocolVersion)
  return protocolversion_;
}
inline void AnnounceMessage::set_allocated_protocolversion(::AnnounceMessage_Version* protocolversion) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete protocolversion_;
  }
  if (protocolversion) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      protocolversion = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, protocolversion, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  protocolversion_ = protocolversion;
  // @@protoc_insertion_point(field_set_allocated:AnnounceMessage.protocolVersion)
}

// required .AnnounceMessage.Version latestGameVersion = 2;
inline bool AnnounceMessage::has_latestgameversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnnounceMessage::clear_latestgameversion() {
  if (latestgameversion_ != nullptr) latestgameversion_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::AnnounceMessage_Version& AnnounceMessage::latestgameversion() const {
  const ::AnnounceMessage_Version* p = latestgameversion_;
  // @@protoc_insertion_point(field_get:AnnounceMessage.latestGameVersion)
  return p != nullptr ? *p : *reinterpret_cast<const ::AnnounceMessage_Version*>(
      &::_AnnounceMessage_Version_default_instance_);
}
inline ::AnnounceMessage_Version* AnnounceMessage::release_latestgameversion() {
  // @@protoc_insertion_point(field_release:AnnounceMessage.latestGameVersion)
  _has_bits_[0] &= ~0x00000002u;
  ::AnnounceMessage_Version* temp = latestgameversion_;
  latestgameversion_ = nullptr;
  return temp;
}
inline ::AnnounceMessage_Version* AnnounceMessage::mutable_latestgameversion() {
  _has_bits_[0] |= 0x00000002u;
  if (latestgameversion_ == nullptr) {
    auto* p = CreateMaybeMessage<::AnnounceMessage_Version>(GetArenaNoVirtual());
    latestgameversion_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AnnounceMessage.latestGameVersion)
  return latestgameversion_;
}
inline void AnnounceMessage::set_allocated_latestgameversion(::AnnounceMessage_Version* latestgameversion) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete latestgameversion_;
  }
  if (latestgameversion) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      latestgameversion = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, latestgameversion, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  latestgameversion_ = latestgameversion;
  // @@protoc_insertion_point(field_set_allocated:AnnounceMessage.latestGameVersion)
}

// required uint32 latestBetaRevision = 3;
inline bool AnnounceMessage::has_latestbetarevision() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnnounceMessage::clear_latestbetarevision() {
  latestbetarevision_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 AnnounceMessage::latestbetarevision() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.latestBetaRevision)
  return latestbetarevision_;
}
inline void AnnounceMessage::set_latestbetarevision(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  latestbetarevision_ = value;
  // @@protoc_insertion_point(field_set:AnnounceMessage.latestBetaRevision)
}

// required .AnnounceMessage.ServerType serverType = 4;
inline bool AnnounceMessage::has_servertype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnnounceMessage::clear_servertype() {
  servertype_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::AnnounceMessage_ServerType AnnounceMessage::servertype() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.serverType)
  return static_cast< ::AnnounceMessage_ServerType >(servertype_);
}
inline void AnnounceMessage::set_servertype(::AnnounceMessage_ServerType value) {
  assert(::AnnounceMessage_ServerType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  servertype_ = value;
  // @@protoc_insertion_point(field_set:AnnounceMessage.serverType)
}

// required uint32 numPlayersOnServer = 5;
inline bool AnnounceMessage::has_numplayersonserver() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnnounceMessage::clear_numplayersonserver() {
  numplayersonserver_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 AnnounceMessage::numplayersonserver() const {
  // @@protoc_insertion_point(field_get:AnnounceMessage.numPlayersOnServer)
  return numplayersonserver_;
}
inline void AnnounceMessage::set_numplayersonserver(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  numplayersonserver_ = value;
  // @@protoc_insertion_point(field_set:AnnounceMessage.numPlayersOnServer)
}

// -------------------------------------------------------------------

// InitMessage

// required .AnnounceMessage.Version requestedVersion = 1;
inline bool InitMessage::has_requestedversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InitMessage::clear_requestedversion() {
  if (requestedversion_ != nullptr) requestedversion_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::AnnounceMessage_Version& InitMessage::requestedversion() const {
  const ::AnnounceMessage_Version* p = requestedversion_;
  // @@protoc_insertion_point(field_get:InitMessage.requestedVersion)
  return p != nullptr ? *p : *reinterpret_cast<const ::AnnounceMessage_Version*>(
      &::_AnnounceMessage_Version_default_instance_);
}
inline ::AnnounceMessage_Version* InitMessage::release_requestedversion() {
  // @@protoc_insertion_point(field_release:InitMessage.requestedVersion)
  _has_bits_[0] &= ~0x00000020u;
  ::AnnounceMessage_Version* temp = requestedversion_;
  requestedversion_ = nullptr;
  return temp;
}
inline ::AnnounceMessage_Version* InitMessage::mutable_requestedversion() {
  _has_bits_[0] |= 0x00000020u;
  if (requestedversion_ == nullptr) {
    auto* p = CreateMaybeMessage<::AnnounceMessage_Version>(GetArenaNoVirtual());
    requestedversion_ = p;
  }
  // @@protoc_insertion_point(field_mutable:InitMessage.requestedVersion)
  return requestedversion_;
}
inline void InitMessage::set_allocated_requestedversion(::AnnounceMessage_Version* requestedversion) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete requestedversion_;
  }
  if (requestedversion) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      requestedversion = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, requestedversion, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  requestedversion_ = requestedversion;
  // @@protoc_insertion_point(field_set_allocated:InitMessage.requestedVersion)
}

// required uint32 buildId = 2;
inline bool InitMessage::has_buildid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InitMessage::clear_buildid() {
  buildid_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 InitMessage::buildid() const {
  // @@protoc_insertion_point(field_get:InitMessage.buildId)
  return buildid_;
}
inline void InitMessage::set_buildid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  buildid_ = value;
  // @@protoc_insertion_point(field_set:InitMessage.buildId)
}

// optional bytes myLastSessionId = 3;
inline bool InitMessage::has_mylastsessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitMessage::clear_mylastsessionid() {
  mylastsessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& InitMessage::mylastsessionid() const {
  // @@protoc_insertion_point(field_get:InitMessage.myLastSessionId)
  return mylastsessionid_.GetNoArena();
}
inline void InitMessage::set_mylastsessionid(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  mylastsessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InitMessage.myLastSessionId)
}
#if LANG_CXX11
inline void InitMessage::set_mylastsessionid(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  mylastsessionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InitMessage.myLastSessionId)
}
#endif
inline void InitMessage::set_mylastsessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  mylastsessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InitMessage.myLastSessionId)
}
inline void InitMessage::set_mylastsessionid(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  mylastsessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InitMessage.myLastSessionId)
}
inline ::std::string* InitMessage::mutable_mylastsessionid() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:InitMessage.myLastSessionId)
  return mylastsessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitMessage::release_mylastsessionid() {
  // @@protoc_insertion_point(field_release:InitMessage.myLastSessionId)
  if (!has_mylastsessionid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return mylastsessionid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitMessage::set_allocated_mylastsessionid(::std::string* mylastsessionid) {
  if (mylastsessionid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  mylastsessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mylastsessionid);
  // @@protoc_insertion_point(field_set_allocated:InitMessage.myLastSessionId)
}

// optional string authServerPassword = 4;
inline bool InitMessage::has_authserverpassword() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitMessage::clear_authserverpassword() {
  authserverpassword_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& InitMessage::authserverpassword() const {
  // @@protoc_insertion_point(field_get:InitMessage.authServerPassword)
  return authserverpassword_.GetNoArena();
}
inline void InitMessage::set_authserverpassword(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  authserverpassword_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InitMessage.authServerPassword)
}
#if LANG_CXX11
inline void InitMessage::set_authserverpassword(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  authserverpassword_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InitMessage.authServerPassword)
}
#endif
inline void InitMessage::set_authserverpassword(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  authserverpassword_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InitMessage.authServerPassword)
}
inline void InitMessage::set_authserverpassword(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  authserverpassword_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InitMessage.authServerPassword)
}
inline ::std::string* InitMessage::mutable_authserverpassword() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:InitMessage.authServerPassword)
  return authserverpassword_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitMessage::release_authserverpassword() {
  // @@protoc_insertion_point(field_release:InitMessage.authServerPassword)
  if (!has_authserverpassword()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return authserverpassword_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitMessage::set_allocated_authserverpassword(::std::string* authserverpassword) {
  if (authserverpassword != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  authserverpassword_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authserverpassword);
  // @@protoc_insertion_point(field_set_allocated:InitMessage.authServerPassword)
}

// required .InitMessage.LoginType login = 5;
inline bool InitMessage::has_login() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InitMessage::clear_login() {
  login_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::InitMessage_LoginType InitMessage::login() const {
  // @@protoc_insertion_point(field_get:InitMessage.login)
  return static_cast< ::InitMessage_LoginType >(login_);
}
inline void InitMessage::set_login(::InitMessage_LoginType value) {
  assert(::InitMessage_LoginType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  login_ = value;
  // @@protoc_insertion_point(field_set:InitMessage.login)
}

// optional string nickName = 6;
inline bool InitMessage::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitMessage::clear_nickname() {
  nickname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& InitMessage::nickname() const {
  // @@protoc_insertion_point(field_get:InitMessage.nickName)
  return nickname_.GetNoArena();
}
inline void InitMessage::set_nickname(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InitMessage.nickName)
}
#if LANG_CXX11
inline void InitMessage::set_nickname(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  nickname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InitMessage.nickName)
}
#endif
inline void InitMessage::set_nickname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InitMessage.nickName)
}
inline void InitMessage::set_nickname(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InitMessage.nickName)
}
inline ::std::string* InitMessage::mutable_nickname() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:InitMessage.nickName)
  return nickname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitMessage::release_nickname() {
  // @@protoc_insertion_point(field_release:InitMessage.nickName)
  if (!has_nickname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return nickname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitMessage::set_allocated_nickname(::std::string* nickname) {
  if (nickname != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  nickname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nickname);
  // @@protoc_insertion_point(field_set_allocated:InitMessage.nickName)
}

// optional bytes clientUserData = 7;
inline bool InitMessage::has_clientuserdata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InitMessage::clear_clientuserdata() {
  clientuserdata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& InitMessage::clientuserdata() const {
  // @@protoc_insertion_point(field_get:InitMessage.clientUserData)
  return clientuserdata_.GetNoArena();
}
inline void InitMessage::set_clientuserdata(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  clientuserdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InitMessage.clientUserData)
}
#if LANG_CXX11
inline void InitMessage::set_clientuserdata(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  clientuserdata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InitMessage.clientUserData)
}
#endif
inline void InitMessage::set_clientuserdata(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  clientuserdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InitMessage.clientUserData)
}
inline void InitMessage::set_clientuserdata(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  clientuserdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InitMessage.clientUserData)
}
inline ::std::string* InitMessage::mutable_clientuserdata() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:InitMessage.clientUserData)
  return clientuserdata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitMessage::release_clientuserdata() {
  // @@protoc_insertion_point(field_release:InitMessage.clientUserData)
  if (!has_clientuserdata()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return clientuserdata_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitMessage::set_allocated_clientuserdata(::std::string* clientuserdata) {
  if (clientuserdata != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  clientuserdata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientuserdata);
  // @@protoc_insertion_point(field_set_allocated:InitMessage.clientUserData)
}

// optional bytes avatarHash = 8;
inline bool InitMessage::has_avatarhash() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InitMessage::clear_avatarhash() {
  avatarhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& InitMessage::avatarhash() const {
  // @@protoc_insertion_point(field_get:InitMessage.avatarHash)
  return avatarhash_.GetNoArena();
}
inline void InitMessage::set_avatarhash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  avatarhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InitMessage.avatarHash)
}
#if LANG_CXX11
inline void InitMessage::set_avatarhash(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  avatarhash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InitMessage.avatarHash)
}
#endif
inline void InitMessage::set_avatarhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  avatarhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InitMessage.avatarHash)
}
inline void InitMessage::set_avatarhash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  avatarhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InitMessage.avatarHash)
}
inline ::std::string* InitMessage::mutable_avatarhash() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:InitMessage.avatarHash)
  return avatarhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitMessage::release_avatarhash() {
  // @@protoc_insertion_point(field_release:InitMessage.avatarHash)
  if (!has_avatarhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return avatarhash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitMessage::set_allocated_avatarhash(::std::string* avatarhash) {
  if (avatarhash != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  avatarhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), avatarhash);
  // @@protoc_insertion_point(field_set_allocated:InitMessage.avatarHash)
}

// -------------------------------------------------------------------

// AuthServerChallengeMessage

// required bytes serverChallenge = 1;
inline bool AuthServerChallengeMessage::has_serverchallenge() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthServerChallengeMessage::clear_serverchallenge() {
  serverchallenge_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& AuthServerChallengeMessage::serverchallenge() const {
  // @@protoc_insertion_point(field_get:AuthServerChallengeMessage.serverChallenge)
  return serverchallenge_.GetNoArena();
}
inline void AuthServerChallengeMessage::set_serverchallenge(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  serverchallenge_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AuthServerChallengeMessage.serverChallenge)
}
#if LANG_CXX11
inline void AuthServerChallengeMessage::set_serverchallenge(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  serverchallenge_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AuthServerChallengeMessage.serverChallenge)
}
#endif
inline void AuthServerChallengeMessage::set_serverchallenge(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  serverchallenge_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AuthServerChallengeMessage.serverChallenge)
}
inline void AuthServerChallengeMessage::set_serverchallenge(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  serverchallenge_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AuthServerChallengeMessage.serverChallenge)
}
inline ::std::string* AuthServerChallengeMessage::mutable_serverchallenge() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:AuthServerChallengeMessage.serverChallenge)
  return serverchallenge_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthServerChallengeMessage::release_serverchallenge() {
  // @@protoc_insertion_point(field_release:AuthServerChallengeMessage.serverChallenge)
  if (!has_serverchallenge()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return serverchallenge_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthServerChallengeMessage::set_allocated_serverchallenge(::std::string* serverchallenge) {
  if (serverchallenge != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  serverchallenge_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverchallenge);
  // @@protoc_insertion_point(field_set_allocated:AuthServerChallengeMessage.serverChallenge)
}

// -------------------------------------------------------------------

// AuthClientResponseMessage

// required bytes clientResponse = 1;
inline bool AuthClientResponseMessage::has_clientresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthClientResponseMessage::clear_clientresponse() {
  clientresponse_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& AuthClientResponseMessage::clientresponse() const {
  // @@protoc_insertion_point(field_get:AuthClientResponseMessage.clientResponse)
  return clientresponse_.GetNoArena();
}
inline void AuthClientResponseMessage::set_clientresponse(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  clientresponse_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AuthClientResponseMessage.clientResponse)
}
#if LANG_CXX11
inline void AuthClientResponseMessage::set_clientresponse(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  clientresponse_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AuthClientResponseMessage.clientResponse)
}
#endif
inline void AuthClientResponseMessage::set_clientresponse(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  clientresponse_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AuthClientResponseMessage.clientResponse)
}
inline void AuthClientResponseMessage::set_clientresponse(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  clientresponse_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AuthClientResponseMessage.clientResponse)
}
inline ::std::string* AuthClientResponseMessage::mutable_clientresponse() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:AuthClientResponseMessage.clientResponse)
  return clientresponse_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthClientResponseMessage::release_clientresponse() {
  // @@protoc_insertion_point(field_release:AuthClientResponseMessage.clientResponse)
  if (!has_clientresponse()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return clientresponse_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthClientResponseMessage::set_allocated_clientresponse(::std::string* clientresponse) {
  if (clientresponse != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  clientresponse_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientresponse);
  // @@protoc_insertion_point(field_set_allocated:AuthClientResponseMessage.clientResponse)
}

// -------------------------------------------------------------------

// AuthServerVerificationMessage

// required bytes serverVerification = 1;
inline bool AuthServerVerificationMessage::has_serververification() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthServerVerificationMessage::clear_serververification() {
  serververification_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& AuthServerVerificationMessage::serververification() const {
  // @@protoc_insertion_point(field_get:AuthServerVerificationMessage.serverVerification)
  return serververification_.GetNoArena();
}
inline void AuthServerVerificationMessage::set_serververification(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  serververification_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AuthServerVerificationMessage.serverVerification)
}
#if LANG_CXX11
inline void AuthServerVerificationMessage::set_serververification(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  serververification_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AuthServerVerificationMessage.serverVerification)
}
#endif
inline void AuthServerVerificationMessage::set_serververification(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  serververification_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AuthServerVerificationMessage.serverVerification)
}
inline void AuthServerVerificationMessage::set_serververification(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  serververification_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AuthServerVerificationMessage.serverVerification)
}
inline ::std::string* AuthServerVerificationMessage::mutable_serververification() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:AuthServerVerificationMessage.serverVerification)
  return serververification_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthServerVerificationMessage::release_serververification() {
  // @@protoc_insertion_point(field_release:AuthServerVerificationMessage.serverVerification)
  if (!has_serververification()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return serververification_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthServerVerificationMessage::set_allocated_serververification(::std::string* serververification) {
  if (serververification != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  serververification_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serververification);
  // @@protoc_insertion_point(field_set_allocated:AuthServerVerificationMessage.serverVerification)
}

// -------------------------------------------------------------------

// InitAckMessage

// required bytes yourSessionId = 1;
inline bool InitAckMessage::has_yoursessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitAckMessage::clear_yoursessionid() {
  yoursessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& InitAckMessage::yoursessionid() const {
  // @@protoc_insertion_point(field_get:InitAckMessage.yourSessionId)
  return yoursessionid_.GetNoArena();
}
inline void InitAckMessage::set_yoursessionid(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  yoursessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InitAckMessage.yourSessionId)
}
#if LANG_CXX11
inline void InitAckMessage::set_yoursessionid(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  yoursessionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InitAckMessage.yourSessionId)
}
#endif
inline void InitAckMessage::set_yoursessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  yoursessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InitAckMessage.yourSessionId)
}
inline void InitAckMessage::set_yoursessionid(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  yoursessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InitAckMessage.yourSessionId)
}
inline ::std::string* InitAckMessage::mutable_yoursessionid() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:InitAckMessage.yourSessionId)
  return yoursessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitAckMessage::release_yoursessionid() {
  // @@protoc_insertion_point(field_release:InitAckMessage.yourSessionId)
  if (!has_yoursessionid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return yoursessionid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitAckMessage::set_allocated_yoursessionid(::std::string* yoursessionid) {
  if (yoursessionid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  yoursessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), yoursessionid);
  // @@protoc_insertion_point(field_set_allocated:InitAckMessage.yourSessionId)
}

// required uint32 yourPlayerId = 2;
inline bool InitAckMessage::has_yourplayerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitAckMessage::clear_yourplayerid() {
  yourplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 InitAckMessage::yourplayerid() const {
  // @@protoc_insertion_point(field_get:InitAckMessage.yourPlayerId)
  return yourplayerid_;
}
inline void InitAckMessage::set_yourplayerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  yourplayerid_ = value;
  // @@protoc_insertion_point(field_set:InitAckMessage.yourPlayerId)
}

// optional bytes yourAvatarHash = 3;
inline bool InitAckMessage::has_youravatarhash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitAckMessage::clear_youravatarhash() {
  youravatarhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& InitAckMessage::youravatarhash() const {
  // @@protoc_insertion_point(field_get:InitAckMessage.yourAvatarHash)
  return youravatarhash_.GetNoArena();
}
inline void InitAckMessage::set_youravatarhash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  youravatarhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InitAckMessage.yourAvatarHash)
}
#if LANG_CXX11
inline void InitAckMessage::set_youravatarhash(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  youravatarhash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InitAckMessage.yourAvatarHash)
}
#endif
inline void InitAckMessage::set_youravatarhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  youravatarhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InitAckMessage.yourAvatarHash)
}
inline void InitAckMessage::set_youravatarhash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  youravatarhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InitAckMessage.yourAvatarHash)
}
inline ::std::string* InitAckMessage::mutable_youravatarhash() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:InitAckMessage.yourAvatarHash)
  return youravatarhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitAckMessage::release_youravatarhash() {
  // @@protoc_insertion_point(field_release:InitAckMessage.yourAvatarHash)
  if (!has_youravatarhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return youravatarhash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitAckMessage::set_allocated_youravatarhash(::std::string* youravatarhash) {
  if (youravatarhash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  youravatarhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), youravatarhash);
  // @@protoc_insertion_point(field_set_allocated:InitAckMessage.yourAvatarHash)
}

// optional uint32 rejoinGameId = 4;
inline bool InitAckMessage::has_rejoingameid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InitAckMessage::clear_rejoingameid() {
  rejoingameid_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 InitAckMessage::rejoingameid() const {
  // @@protoc_insertion_point(field_get:InitAckMessage.rejoinGameId)
  return rejoingameid_;
}
inline void InitAckMessage::set_rejoingameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  rejoingameid_ = value;
  // @@protoc_insertion_point(field_set:InitAckMessage.rejoinGameId)
}

// -------------------------------------------------------------------

// AvatarRequestMessage

// required uint32 requestId = 1;
inline bool AvatarRequestMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AvatarRequestMessage::clear_requestid() {
  requestid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 AvatarRequestMessage::requestid() const {
  // @@protoc_insertion_point(field_get:AvatarRequestMessage.requestId)
  return requestid_;
}
inline void AvatarRequestMessage::set_requestid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  requestid_ = value;
  // @@protoc_insertion_point(field_set:AvatarRequestMessage.requestId)
}

// required bytes avatarHash = 2;
inline bool AvatarRequestMessage::has_avatarhash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvatarRequestMessage::clear_avatarhash() {
  avatarhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& AvatarRequestMessage::avatarhash() const {
  // @@protoc_insertion_point(field_get:AvatarRequestMessage.avatarHash)
  return avatarhash_.GetNoArena();
}
inline void AvatarRequestMessage::set_avatarhash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  avatarhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AvatarRequestMessage.avatarHash)
}
#if LANG_CXX11
inline void AvatarRequestMessage::set_avatarhash(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  avatarhash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AvatarRequestMessage.avatarHash)
}
#endif
inline void AvatarRequestMessage::set_avatarhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  avatarhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AvatarRequestMessage.avatarHash)
}
inline void AvatarRequestMessage::set_avatarhash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  avatarhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AvatarRequestMessage.avatarHash)
}
inline ::std::string* AvatarRequestMessage::mutable_avatarhash() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:AvatarRequestMessage.avatarHash)
  return avatarhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AvatarRequestMessage::release_avatarhash() {
  // @@protoc_insertion_point(field_release:AvatarRequestMessage.avatarHash)
  if (!has_avatarhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return avatarhash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvatarRequestMessage::set_allocated_avatarhash(::std::string* avatarhash) {
  if (avatarhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  avatarhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), avatarhash);
  // @@protoc_insertion_point(field_set_allocated:AvatarRequestMessage.avatarHash)
}

// -------------------------------------------------------------------

// AvatarHeaderMessage

// required uint32 requestId = 1;
inline bool AvatarHeaderMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvatarHeaderMessage::clear_requestid() {
  requestid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 AvatarHeaderMessage::requestid() const {
  // @@protoc_insertion_point(field_get:AvatarHeaderMessage.requestId)
  return requestid_;
}
inline void AvatarHeaderMessage::set_requestid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  requestid_ = value;
  // @@protoc_insertion_point(field_set:AvatarHeaderMessage.requestId)
}

// required .NetAvatarType avatarType = 2;
inline bool AvatarHeaderMessage::has_avatartype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AvatarHeaderMessage::clear_avatartype() {
  avatartype_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::NetAvatarType AvatarHeaderMessage::avatartype() const {
  // @@protoc_insertion_point(field_get:AvatarHeaderMessage.avatarType)
  return static_cast< ::NetAvatarType >(avatartype_);
}
inline void AvatarHeaderMessage::set_avatartype(::NetAvatarType value) {
  assert(::NetAvatarType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  avatartype_ = value;
  // @@protoc_insertion_point(field_set:AvatarHeaderMessage.avatarType)
}

// required uint32 avatarSize = 3;
inline bool AvatarHeaderMessage::has_avatarsize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AvatarHeaderMessage::clear_avatarsize() {
  avatarsize_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 AvatarHeaderMessage::avatarsize() const {
  // @@protoc_insertion_point(field_get:AvatarHeaderMessage.avatarSize)
  return avatarsize_;
}
inline void AvatarHeaderMessage::set_avatarsize(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  avatarsize_ = value;
  // @@protoc_insertion_point(field_set:AvatarHeaderMessage.avatarSize)
}

// -------------------------------------------------------------------

// AvatarDataMessage

// required uint32 requestId = 1;
inline bool AvatarDataMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AvatarDataMessage::clear_requestid() {
  requestid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 AvatarDataMessage::requestid() const {
  // @@protoc_insertion_point(field_get:AvatarDataMessage.requestId)
  return requestid_;
}
inline void AvatarDataMessage::set_requestid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  requestid_ = value;
  // @@protoc_insertion_point(field_set:AvatarDataMessage.requestId)
}

// required bytes avatarBlock = 2;
inline bool AvatarDataMessage::has_avatarblock() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvatarDataMessage::clear_avatarblock() {
  avatarblock_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& AvatarDataMessage::avatarblock() const {
  // @@protoc_insertion_point(field_get:AvatarDataMessage.avatarBlock)
  return avatarblock_.GetNoArena();
}
inline void AvatarDataMessage::set_avatarblock(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  avatarblock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AvatarDataMessage.avatarBlock)
}
#if LANG_CXX11
inline void AvatarDataMessage::set_avatarblock(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  avatarblock_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AvatarDataMessage.avatarBlock)
}
#endif
inline void AvatarDataMessage::set_avatarblock(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  avatarblock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AvatarDataMessage.avatarBlock)
}
inline void AvatarDataMessage::set_avatarblock(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  avatarblock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AvatarDataMessage.avatarBlock)
}
inline ::std::string* AvatarDataMessage::mutable_avatarblock() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:AvatarDataMessage.avatarBlock)
  return avatarblock_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AvatarDataMessage::release_avatarblock() {
  // @@protoc_insertion_point(field_release:AvatarDataMessage.avatarBlock)
  if (!has_avatarblock()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return avatarblock_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AvatarDataMessage::set_allocated_avatarblock(::std::string* avatarblock) {
  if (avatarblock != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  avatarblock_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), avatarblock);
  // @@protoc_insertion_point(field_set_allocated:AvatarDataMessage.avatarBlock)
}

// -------------------------------------------------------------------

// AvatarEndMessage

// required uint32 requestId = 1;
inline bool AvatarEndMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvatarEndMessage::clear_requestid() {
  requestid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 AvatarEndMessage::requestid() const {
  // @@protoc_insertion_point(field_get:AvatarEndMessage.requestId)
  return requestid_;
}
inline void AvatarEndMessage::set_requestid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  requestid_ = value;
  // @@protoc_insertion_point(field_set:AvatarEndMessage.requestId)
}

// -------------------------------------------------------------------

// UnknownAvatarMessage

// required uint32 requestId = 1;
inline bool UnknownAvatarMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnknownAvatarMessage::clear_requestid() {
  requestid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 UnknownAvatarMessage::requestid() const {
  // @@protoc_insertion_point(field_get:UnknownAvatarMessage.requestId)
  return requestid_;
}
inline void UnknownAvatarMessage::set_requestid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  requestid_ = value;
  // @@protoc_insertion_point(field_set:UnknownAvatarMessage.requestId)
}

// -------------------------------------------------------------------

// PlayerListMessage

// required uint32 playerId = 1;
inline bool PlayerListMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerListMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 PlayerListMessage::playerid() const {
  // @@protoc_insertion_point(field_get:PlayerListMessage.playerId)
  return playerid_;
}
inline void PlayerListMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:PlayerListMessage.playerId)
}

// required .PlayerListMessage.PlayerListNotification playerListNotification = 2;
inline bool PlayerListMessage::has_playerlistnotification() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerListMessage::clear_playerlistnotification() {
  playerlistnotification_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PlayerListMessage_PlayerListNotification PlayerListMessage::playerlistnotification() const {
  // @@protoc_insertion_point(field_get:PlayerListMessage.playerListNotification)
  return static_cast< ::PlayerListMessage_PlayerListNotification >(playerlistnotification_);
}
inline void PlayerListMessage::set_playerlistnotification(::PlayerListMessage_PlayerListNotification value) {
  assert(::PlayerListMessage_PlayerListNotification_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  playerlistnotification_ = value;
  // @@protoc_insertion_point(field_set:PlayerListMessage.playerListNotification)
}

// -------------------------------------------------------------------

// GameListNewMessage

// required uint32 gameId = 1;
inline bool GameListNewMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListNewMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 GameListNewMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.gameId)
  return gameid_;
}
inline void GameListNewMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameListNewMessage.gameId)
}

// required .NetGameMode gameMode = 2;
inline bool GameListNewMessage::has_gamemode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameListNewMessage::clear_gamemode() {
  gamemode_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::NetGameMode GameListNewMessage::gamemode() const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.gameMode)
  return static_cast< ::NetGameMode >(gamemode_);
}
inline void GameListNewMessage::set_gamemode(::NetGameMode value) {
  assert(::NetGameMode_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  gamemode_ = value;
  // @@protoc_insertion_point(field_set:GameListNewMessage.gameMode)
}

// required bool isPrivate = 3;
inline bool GameListNewMessage::has_isprivate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameListNewMessage::clear_isprivate() {
  isprivate_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool GameListNewMessage::isprivate() const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.isPrivate)
  return isprivate_;
}
inline void GameListNewMessage::set_isprivate(bool value) {
  _has_bits_[0] |= 0x00000004u;
  isprivate_ = value;
  // @@protoc_insertion_point(field_set:GameListNewMessage.isPrivate)
}

// repeated uint32 playerIds = 4 [packed = true];
inline int GameListNewMessage::playerids_size() const {
  return playerids_.size();
}
inline void GameListNewMessage::clear_playerids() {
  playerids_.Clear();
}
inline ::google::protobuf::uint32 GameListNewMessage::playerids(int index) const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.playerIds)
  return playerids_.Get(index);
}
inline void GameListNewMessage::set_playerids(int index, ::google::protobuf::uint32 value) {
  playerids_.Set(index, value);
  // @@protoc_insertion_point(field_set:GameListNewMessage.playerIds)
}
inline void GameListNewMessage::add_playerids(::google::protobuf::uint32 value) {
  playerids_.Add(value);
  // @@protoc_insertion_point(field_add:GameListNewMessage.playerIds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GameListNewMessage::playerids() const {
  // @@protoc_insertion_point(field_list:GameListNewMessage.playerIds)
  return playerids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GameListNewMessage::mutable_playerids() {
  // @@protoc_insertion_point(field_mutable_list:GameListNewMessage.playerIds)
  return &playerids_;
}

// required uint32 adminPlayerId = 5;
inline bool GameListNewMessage::has_adminplayerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameListNewMessage::clear_adminplayerid() {
  adminplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 GameListNewMessage::adminplayerid() const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.adminPlayerId)
  return adminplayerid_;
}
inline void GameListNewMessage::set_adminplayerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  adminplayerid_ = value;
  // @@protoc_insertion_point(field_set:GameListNewMessage.adminPlayerId)
}

// required .NetGameInfo gameInfo = 6;
inline bool GameListNewMessage::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListNewMessage::clear_gameinfo() {
  if (gameinfo_ != nullptr) gameinfo_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::NetGameInfo& GameListNewMessage::gameinfo() const {
  const ::NetGameInfo* p = gameinfo_;
  // @@protoc_insertion_point(field_get:GameListNewMessage.gameInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::NetGameInfo*>(
      &::_NetGameInfo_default_instance_);
}
inline ::NetGameInfo* GameListNewMessage::release_gameinfo() {
  // @@protoc_insertion_point(field_release:GameListNewMessage.gameInfo)
  _has_bits_[0] &= ~0x00000001u;
  ::NetGameInfo* temp = gameinfo_;
  gameinfo_ = nullptr;
  return temp;
}
inline ::NetGameInfo* GameListNewMessage::mutable_gameinfo() {
  _has_bits_[0] |= 0x00000001u;
  if (gameinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::NetGameInfo>(GetArenaNoVirtual());
    gameinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:GameListNewMessage.gameInfo)
  return gameinfo_;
}
inline void GameListNewMessage::set_allocated_gameinfo(::NetGameInfo* gameinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gameinfo_;
  }
  if (gameinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gameinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gameinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gameinfo_ = gameinfo;
  // @@protoc_insertion_point(field_set_allocated:GameListNewMessage.gameInfo)
}

// repeated uint32 spectatorIds = 7 [packed = true];
inline int GameListNewMessage::spectatorids_size() const {
  return spectatorids_.size();
}
inline void GameListNewMessage::clear_spectatorids() {
  spectatorids_.Clear();
}
inline ::google::protobuf::uint32 GameListNewMessage::spectatorids(int index) const {
  // @@protoc_insertion_point(field_get:GameListNewMessage.spectatorIds)
  return spectatorids_.Get(index);
}
inline void GameListNewMessage::set_spectatorids(int index, ::google::protobuf::uint32 value) {
  spectatorids_.Set(index, value);
  // @@protoc_insertion_point(field_set:GameListNewMessage.spectatorIds)
}
inline void GameListNewMessage::add_spectatorids(::google::protobuf::uint32 value) {
  spectatorids_.Add(value);
  // @@protoc_insertion_point(field_add:GameListNewMessage.spectatorIds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GameListNewMessage::spectatorids() const {
  // @@protoc_insertion_point(field_list:GameListNewMessage.spectatorIds)
  return spectatorids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GameListNewMessage::mutable_spectatorids() {
  // @@protoc_insertion_point(field_mutable_list:GameListNewMessage.spectatorIds)
  return &spectatorids_;
}

// -------------------------------------------------------------------

// GameListUpdateMessage

// required uint32 gameId = 1;
inline bool GameListUpdateMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListUpdateMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 GameListUpdateMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListUpdateMessage.gameId)
  return gameid_;
}
inline void GameListUpdateMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameListUpdateMessage.gameId)
}

// required .NetGameMode gameMode = 2;
inline bool GameListUpdateMessage::has_gamemode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListUpdateMessage::clear_gamemode() {
  gamemode_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::NetGameMode GameListUpdateMessage::gamemode() const {
  // @@protoc_insertion_point(field_get:GameListUpdateMessage.gameMode)
  return static_cast< ::NetGameMode >(gamemode_);
}
inline void GameListUpdateMessage::set_gamemode(::NetGameMode value) {
  assert(::NetGameMode_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  gamemode_ = value;
  // @@protoc_insertion_point(field_set:GameListUpdateMessage.gameMode)
}

// -------------------------------------------------------------------

// GameListPlayerJoinedMessage

// required uint32 gameId = 1;
inline bool GameListPlayerJoinedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListPlayerJoinedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 GameListPlayerJoinedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListPlayerJoinedMessage.gameId)
  return gameid_;
}
inline void GameListPlayerJoinedMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameListPlayerJoinedMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameListPlayerJoinedMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListPlayerJoinedMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 GameListPlayerJoinedMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameListPlayerJoinedMessage.playerId)
  return playerid_;
}
inline void GameListPlayerJoinedMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GameListPlayerJoinedMessage.playerId)
}

// -------------------------------------------------------------------

// GameListPlayerLeftMessage

// required uint32 gameId = 1;
inline bool GameListPlayerLeftMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListPlayerLeftMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 GameListPlayerLeftMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListPlayerLeftMessage.gameId)
  return gameid_;
}
inline void GameListPlayerLeftMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameListPlayerLeftMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameListPlayerLeftMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListPlayerLeftMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 GameListPlayerLeftMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameListPlayerLeftMessage.playerId)
  return playerid_;
}
inline void GameListPlayerLeftMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GameListPlayerLeftMessage.playerId)
}

// -------------------------------------------------------------------

// GameListSpectatorJoinedMessage

// required uint32 gameId = 1;
inline bool GameListSpectatorJoinedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListSpectatorJoinedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 GameListSpectatorJoinedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListSpectatorJoinedMessage.gameId)
  return gameid_;
}
inline void GameListSpectatorJoinedMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameListSpectatorJoinedMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameListSpectatorJoinedMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListSpectatorJoinedMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 GameListSpectatorJoinedMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameListSpectatorJoinedMessage.playerId)
  return playerid_;
}
inline void GameListSpectatorJoinedMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GameListSpectatorJoinedMessage.playerId)
}

// -------------------------------------------------------------------

// GameListSpectatorLeftMessage

// required uint32 gameId = 1;
inline bool GameListSpectatorLeftMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListSpectatorLeftMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 GameListSpectatorLeftMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListSpectatorLeftMessage.gameId)
  return gameid_;
}
inline void GameListSpectatorLeftMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameListSpectatorLeftMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameListSpectatorLeftMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListSpectatorLeftMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 GameListSpectatorLeftMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameListSpectatorLeftMessage.playerId)
  return playerid_;
}
inline void GameListSpectatorLeftMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GameListSpectatorLeftMessage.playerId)
}

// -------------------------------------------------------------------

// GameListAdminChangedMessage

// required uint32 gameId = 1;
inline bool GameListAdminChangedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameListAdminChangedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 GameListAdminChangedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameListAdminChangedMessage.gameId)
  return gameid_;
}
inline void GameListAdminChangedMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameListAdminChangedMessage.gameId)
}

// required uint32 newAdminPlayerId = 2;
inline bool GameListAdminChangedMessage::has_newadminplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameListAdminChangedMessage::clear_newadminplayerid() {
  newadminplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 GameListAdminChangedMessage::newadminplayerid() const {
  // @@protoc_insertion_point(field_get:GameListAdminChangedMessage.newAdminPlayerId)
  return newadminplayerid_;
}
inline void GameListAdminChangedMessage::set_newadminplayerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  newadminplayerid_ = value;
  // @@protoc_insertion_point(field_set:GameListAdminChangedMessage.newAdminPlayerId)
}

// -------------------------------------------------------------------

// PlayerInfoRequestMessage

// repeated uint32 playerId = 1 [packed = true];
inline int PlayerInfoRequestMessage::playerid_size() const {
  return playerid_.size();
}
inline void PlayerInfoRequestMessage::clear_playerid() {
  playerid_.Clear();
}
inline ::google::protobuf::uint32 PlayerInfoRequestMessage::playerid(int index) const {
  // @@protoc_insertion_point(field_get:PlayerInfoRequestMessage.playerId)
  return playerid_.Get(index);
}
inline void PlayerInfoRequestMessage::set_playerid(int index, ::google::protobuf::uint32 value) {
  playerid_.Set(index, value);
  // @@protoc_insertion_point(field_set:PlayerInfoRequestMessage.playerId)
}
inline void PlayerInfoRequestMessage::add_playerid(::google::protobuf::uint32 value) {
  playerid_.Add(value);
  // @@protoc_insertion_point(field_add:PlayerInfoRequestMessage.playerId)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
PlayerInfoRequestMessage::playerid() const {
  // @@protoc_insertion_point(field_list:PlayerInfoRequestMessage.playerId)
  return playerid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
PlayerInfoRequestMessage::mutable_playerid() {
  // @@protoc_insertion_point(field_mutable_list:PlayerInfoRequestMessage.playerId)
  return &playerid_;
}

// -------------------------------------------------------------------

// PlayerInfoReplyMessage_PlayerInfoData_AvatarData

// required .NetAvatarType avatarType = 1;
inline bool PlayerInfoReplyMessage_PlayerInfoData_AvatarData::has_avatartype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::clear_avatartype() {
  avatartype_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::NetAvatarType PlayerInfoReplyMessage_PlayerInfoData_AvatarData::avatartype() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarType)
  return static_cast< ::NetAvatarType >(avatartype_);
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_avatartype(::NetAvatarType value) {
  assert(::NetAvatarType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  avatartype_ = value;
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarType)
}

// required bytes avatarHash = 2;
inline bool PlayerInfoReplyMessage_PlayerInfoData_AvatarData::has_avatarhash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::clear_avatarhash() {
  avatarhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& PlayerInfoReplyMessage_PlayerInfoData_AvatarData::avatarhash() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
  return avatarhash_.GetNoArena();
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_avatarhash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  avatarhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
}
#if LANG_CXX11
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_avatarhash(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  avatarhash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
}
#endif
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_avatarhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  avatarhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_avatarhash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  avatarhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData_AvatarData::mutable_avatarhash() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
  return avatarhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData_AvatarData::release_avatarhash() {
  // @@protoc_insertion_point(field_release:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
  if (!has_avatarhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return avatarhash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerInfoReplyMessage_PlayerInfoData_AvatarData::set_allocated_avatarhash(::std::string* avatarhash) {
  if (avatarhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  avatarhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), avatarhash);
  // @@protoc_insertion_point(field_set_allocated:PlayerInfoReplyMessage.PlayerInfoData.AvatarData.avatarHash)
}

// -------------------------------------------------------------------

// PlayerInfoReplyMessage_PlayerInfoData

// required string playerName = 1;
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_playername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_playername() {
  playername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& PlayerInfoReplyMessage_PlayerInfoData::playername() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.playerName)
  return playername_.GetNoArena();
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_playername(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  playername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.playerName)
}
#if LANG_CXX11
inline void PlayerInfoReplyMessage_PlayerInfoData::set_playername(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  playername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PlayerInfoReplyMessage.PlayerInfoData.playerName)
}
#endif
inline void PlayerInfoReplyMessage_PlayerInfoData::set_playername(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  playername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PlayerInfoReplyMessage.PlayerInfoData.playerName)
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_playername(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  playername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PlayerInfoReplyMessage.PlayerInfoData.playerName)
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData::mutable_playername() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:PlayerInfoReplyMessage.PlayerInfoData.playerName)
  return playername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData::release_playername() {
  // @@protoc_insertion_point(field_release:PlayerInfoReplyMessage.PlayerInfoData.playerName)
  if (!has_playername()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return playername_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_allocated_playername(::std::string* playername) {
  if (playername != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  playername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), playername);
  // @@protoc_insertion_point(field_set_allocated:PlayerInfoReplyMessage.PlayerInfoData.playerName)
}

// required bool isHuman = 2;
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_ishuman() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_ishuman() {
  ishuman_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool PlayerInfoReplyMessage_PlayerInfoData::ishuman() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.isHuman)
  return ishuman_;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_ishuman(bool value) {
  _has_bits_[0] |= 0x00000008u;
  ishuman_ = value;
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.isHuman)
}

// required .NetPlayerInfoRights playerRights = 3;
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_playerrights() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_playerrights() {
  playerrights_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::NetPlayerInfoRights PlayerInfoReplyMessage_PlayerInfoData::playerrights() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.playerRights)
  return static_cast< ::NetPlayerInfoRights >(playerrights_);
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_playerrights(::NetPlayerInfoRights value) {
  assert(::NetPlayerInfoRights_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  playerrights_ = value;
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.playerRights)
}

// optional string countryCode = 4;
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_countrycode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_countrycode() {
  countrycode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& PlayerInfoReplyMessage_PlayerInfoData::countrycode() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
  return countrycode_.GetNoArena();
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_countrycode(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  countrycode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
}
#if LANG_CXX11
inline void PlayerInfoReplyMessage_PlayerInfoData::set_countrycode(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  countrycode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
}
#endif
inline void PlayerInfoReplyMessage_PlayerInfoData::set_countrycode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  countrycode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_countrycode(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  countrycode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData::mutable_countrycode() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
  return countrycode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerInfoReplyMessage_PlayerInfoData::release_countrycode() {
  // @@protoc_insertion_point(field_release:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
  if (!has_countrycode()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return countrycode_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_allocated_countrycode(::std::string* countrycode) {
  if (countrycode != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  countrycode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), countrycode);
  // @@protoc_insertion_point(field_set_allocated:PlayerInfoReplyMessage.PlayerInfoData.countryCode)
}

// optional .PlayerInfoReplyMessage.PlayerInfoData.AvatarData avatarData = 5;
inline bool PlayerInfoReplyMessage_PlayerInfoData::has_avatardata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::clear_avatardata() {
  if (avatardata_ != nullptr) avatardata_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData& PlayerInfoReplyMessage_PlayerInfoData::avatardata() const {
  const ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* p = avatardata_;
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.PlayerInfoData.avatarData)
  return p != nullptr ? *p : *reinterpret_cast<const ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData*>(
      &::_PlayerInfoReplyMessage_PlayerInfoData_AvatarData_default_instance_);
}
inline ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* PlayerInfoReplyMessage_PlayerInfoData::release_avatardata() {
  // @@protoc_insertion_point(field_release:PlayerInfoReplyMessage.PlayerInfoData.avatarData)
  _has_bits_[0] &= ~0x00000004u;
  ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* temp = avatardata_;
  avatardata_ = nullptr;
  return temp;
}
inline ::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* PlayerInfoReplyMessage_PlayerInfoData::mutable_avatardata() {
  _has_bits_[0] |= 0x00000004u;
  if (avatardata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerInfoReplyMessage_PlayerInfoData_AvatarData>(GetArenaNoVirtual());
    avatardata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PlayerInfoReplyMessage.PlayerInfoData.avatarData)
  return avatardata_;
}
inline void PlayerInfoReplyMessage_PlayerInfoData::set_allocated_avatardata(::PlayerInfoReplyMessage_PlayerInfoData_AvatarData* avatardata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete avatardata_;
  }
  if (avatardata) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      avatardata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, avatardata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  avatardata_ = avatardata;
  // @@protoc_insertion_point(field_set_allocated:PlayerInfoReplyMessage.PlayerInfoData.avatarData)
}

// -------------------------------------------------------------------

// PlayerInfoReplyMessage

// required uint32 playerId = 1;
inline bool PlayerInfoReplyMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfoReplyMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 PlayerInfoReplyMessage::playerid() const {
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.playerId)
  return playerid_;
}
inline void PlayerInfoReplyMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:PlayerInfoReplyMessage.playerId)
}

// optional .PlayerInfoReplyMessage.PlayerInfoData playerInfoData = 2;
inline bool PlayerInfoReplyMessage::has_playerinfodata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfoReplyMessage::clear_playerinfodata() {
  if (playerinfodata_ != nullptr) playerinfodata_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PlayerInfoReplyMessage_PlayerInfoData& PlayerInfoReplyMessage::playerinfodata() const {
  const ::PlayerInfoReplyMessage_PlayerInfoData* p = playerinfodata_;
  // @@protoc_insertion_point(field_get:PlayerInfoReplyMessage.playerInfoData)
  return p != nullptr ? *p : *reinterpret_cast<const ::PlayerInfoReplyMessage_PlayerInfoData*>(
      &::_PlayerInfoReplyMessage_PlayerInfoData_default_instance_);
}
inline ::PlayerInfoReplyMessage_PlayerInfoData* PlayerInfoReplyMessage::release_playerinfodata() {
  // @@protoc_insertion_point(field_release:PlayerInfoReplyMessage.playerInfoData)
  _has_bits_[0] &= ~0x00000001u;
  ::PlayerInfoReplyMessage_PlayerInfoData* temp = playerinfodata_;
  playerinfodata_ = nullptr;
  return temp;
}
inline ::PlayerInfoReplyMessage_PlayerInfoData* PlayerInfoReplyMessage::mutable_playerinfodata() {
  _has_bits_[0] |= 0x00000001u;
  if (playerinfodata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerInfoReplyMessage_PlayerInfoData>(GetArenaNoVirtual());
    playerinfodata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PlayerInfoReplyMessage.playerInfoData)
  return playerinfodata_;
}
inline void PlayerInfoReplyMessage::set_allocated_playerinfodata(::PlayerInfoReplyMessage_PlayerInfoData* playerinfodata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete playerinfodata_;
  }
  if (playerinfodata) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      playerinfodata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, playerinfodata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  playerinfodata_ = playerinfodata;
  // @@protoc_insertion_point(field_set_allocated:PlayerInfoReplyMessage.playerInfoData)
}

// -------------------------------------------------------------------

// SubscriptionRequestMessage

// required .SubscriptionRequestMessage.SubscriptionAction subscriptionAction = 1;
inline bool SubscriptionRequestMessage::has_subscriptionaction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscriptionRequestMessage::clear_subscriptionaction() {
  subscriptionaction_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::SubscriptionRequestMessage_SubscriptionAction SubscriptionRequestMessage::subscriptionaction() const {
  // @@protoc_insertion_point(field_get:SubscriptionRequestMessage.subscriptionAction)
  return static_cast< ::SubscriptionRequestMessage_SubscriptionAction >(subscriptionaction_);
}
inline void SubscriptionRequestMessage::set_subscriptionaction(::SubscriptionRequestMessage_SubscriptionAction value) {
  assert(::SubscriptionRequestMessage_SubscriptionAction_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  subscriptionaction_ = value;
  // @@protoc_insertion_point(field_set:SubscriptionRequestMessage.subscriptionAction)
}

// -------------------------------------------------------------------

// JoinExistingGameMessage

// required uint32 gameId = 1;
inline bool JoinExistingGameMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinExistingGameMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 JoinExistingGameMessage::gameid() const {
  // @@protoc_insertion_point(field_get:JoinExistingGameMessage.gameId)
  return gameid_;
}
inline void JoinExistingGameMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:JoinExistingGameMessage.gameId)
}

// optional string password = 2;
inline bool JoinExistingGameMessage::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinExistingGameMessage::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& JoinExistingGameMessage::password() const {
  // @@protoc_insertion_point(field_get:JoinExistingGameMessage.password)
  return password_.GetNoArena();
}
inline void JoinExistingGameMessage::set_password(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:JoinExistingGameMessage.password)
}
#if LANG_CXX11
inline void JoinExistingGameMessage::set_password(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:JoinExistingGameMessage.password)
}
#endif
inline void JoinExistingGameMessage::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:JoinExistingGameMessage.password)
}
inline void JoinExistingGameMessage::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:JoinExistingGameMessage.password)
}
inline ::std::string* JoinExistingGameMessage::mutable_password() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:JoinExistingGameMessage.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinExistingGameMessage::release_password() {
  // @@protoc_insertion_point(field_release:JoinExistingGameMessage.password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return password_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinExistingGameMessage::set_allocated_password(::std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:JoinExistingGameMessage.password)
}

// optional bool autoLeave = 3 [default = false];
inline bool JoinExistingGameMessage::has_autoleave() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinExistingGameMessage::clear_autoleave() {
  autoleave_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool JoinExistingGameMessage::autoleave() const {
  // @@protoc_insertion_point(field_get:JoinExistingGameMessage.autoLeave)
  return autoleave_;
}
inline void JoinExistingGameMessage::set_autoleave(bool value) {
  _has_bits_[0] |= 0x00000004u;
  autoleave_ = value;
  // @@protoc_insertion_point(field_set:JoinExistingGameMessage.autoLeave)
}

// optional bool spectateOnly = 4 [default = false];
inline bool JoinExistingGameMessage::has_spectateonly() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JoinExistingGameMessage::clear_spectateonly() {
  spectateonly_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool JoinExistingGameMessage::spectateonly() const {
  // @@protoc_insertion_point(field_get:JoinExistingGameMessage.spectateOnly)
  return spectateonly_;
}
inline void JoinExistingGameMessage::set_spectateonly(bool value) {
  _has_bits_[0] |= 0x00000008u;
  spectateonly_ = value;
  // @@protoc_insertion_point(field_set:JoinExistingGameMessage.spectateOnly)
}

// -------------------------------------------------------------------

// JoinNewGameMessage

// required .NetGameInfo gameInfo = 1;
inline bool JoinNewGameMessage::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinNewGameMessage::clear_gameinfo() {
  if (gameinfo_ != nullptr) gameinfo_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::NetGameInfo& JoinNewGameMessage::gameinfo() const {
  const ::NetGameInfo* p = gameinfo_;
  // @@protoc_insertion_point(field_get:JoinNewGameMessage.gameInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::NetGameInfo*>(
      &::_NetGameInfo_default_instance_);
}
inline ::NetGameInfo* JoinNewGameMessage::release_gameinfo() {
  // @@protoc_insertion_point(field_release:JoinNewGameMessage.gameInfo)
  _has_bits_[0] &= ~0x00000002u;
  ::NetGameInfo* temp = gameinfo_;
  gameinfo_ = nullptr;
  return temp;
}
inline ::NetGameInfo* JoinNewGameMessage::mutable_gameinfo() {
  _has_bits_[0] |= 0x00000002u;
  if (gameinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::NetGameInfo>(GetArenaNoVirtual());
    gameinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:JoinNewGameMessage.gameInfo)
  return gameinfo_;
}
inline void JoinNewGameMessage::set_allocated_gameinfo(::NetGameInfo* gameinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gameinfo_;
  }
  if (gameinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gameinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gameinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  gameinfo_ = gameinfo;
  // @@protoc_insertion_point(field_set_allocated:JoinNewGameMessage.gameInfo)
}

// optional string password = 2;
inline bool JoinNewGameMessage::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinNewGameMessage::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& JoinNewGameMessage::password() const {
  // @@protoc_insertion_point(field_get:JoinNewGameMessage.password)
  return password_.GetNoArena();
}
inline void JoinNewGameMessage::set_password(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:JoinNewGameMessage.password)
}
#if LANG_CXX11
inline void JoinNewGameMessage::set_password(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:JoinNewGameMessage.password)
}
#endif
inline void JoinNewGameMessage::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:JoinNewGameMessage.password)
}
inline void JoinNewGameMessage::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:JoinNewGameMessage.password)
}
inline ::std::string* JoinNewGameMessage::mutable_password() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:JoinNewGameMessage.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinNewGameMessage::release_password() {
  // @@protoc_insertion_point(field_release:JoinNewGameMessage.password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return password_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinNewGameMessage::set_allocated_password(::std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:JoinNewGameMessage.password)
}

// optional bool autoLeave = 3;
inline bool JoinNewGameMessage::has_autoleave() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinNewGameMessage::clear_autoleave() {
  autoleave_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool JoinNewGameMessage::autoleave() const {
  // @@protoc_insertion_point(field_get:JoinNewGameMessage.autoLeave)
  return autoleave_;
}
inline void JoinNewGameMessage::set_autoleave(bool value) {
  _has_bits_[0] |= 0x00000004u;
  autoleave_ = value;
  // @@protoc_insertion_point(field_set:JoinNewGameMessage.autoLeave)
}

// -------------------------------------------------------------------

// RejoinExistingGameMessage

// required uint32 gameId = 1;
inline bool RejoinExistingGameMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RejoinExistingGameMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 RejoinExistingGameMessage::gameid() const {
  // @@protoc_insertion_point(field_get:RejoinExistingGameMessage.gameId)
  return gameid_;
}
inline void RejoinExistingGameMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:RejoinExistingGameMessage.gameId)
}

// optional bool autoLeave = 2;
inline bool RejoinExistingGameMessage::has_autoleave() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RejoinExistingGameMessage::clear_autoleave() {
  autoleave_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool RejoinExistingGameMessage::autoleave() const {
  // @@protoc_insertion_point(field_get:RejoinExistingGameMessage.autoLeave)
  return autoleave_;
}
inline void RejoinExistingGameMessage::set_autoleave(bool value) {
  _has_bits_[0] |= 0x00000002u;
  autoleave_ = value;
  // @@protoc_insertion_point(field_set:RejoinExistingGameMessage.autoLeave)
}

// -------------------------------------------------------------------

// JoinGameAckMessage

// required uint32 gameId = 1;
inline bool JoinGameAckMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinGameAckMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 JoinGameAckMessage::gameid() const {
  // @@protoc_insertion_point(field_get:JoinGameAckMessage.gameId)
  return gameid_;
}
inline void JoinGameAckMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:JoinGameAckMessage.gameId)
}

// required bool areYouGameAdmin = 2;
inline bool JoinGameAckMessage::has_areyougameadmin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinGameAckMessage::clear_areyougameadmin() {
  areyougameadmin_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool JoinGameAckMessage::areyougameadmin() const {
  // @@protoc_insertion_point(field_get:JoinGameAckMessage.areYouGameAdmin)
  return areyougameadmin_;
}
inline void JoinGameAckMessage::set_areyougameadmin(bool value) {
  _has_bits_[0] |= 0x00000004u;
  areyougameadmin_ = value;
  // @@protoc_insertion_point(field_set:JoinGameAckMessage.areYouGameAdmin)
}

// required .NetGameInfo gameInfo = 3;
inline bool JoinGameAckMessage::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinGameAckMessage::clear_gameinfo() {
  if (gameinfo_ != nullptr) gameinfo_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::NetGameInfo& JoinGameAckMessage::gameinfo() const {
  const ::NetGameInfo* p = gameinfo_;
  // @@protoc_insertion_point(field_get:JoinGameAckMessage.gameInfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::NetGameInfo*>(
      &::_NetGameInfo_default_instance_);
}
inline ::NetGameInfo* JoinGameAckMessage::release_gameinfo() {
  // @@protoc_insertion_point(field_release:JoinGameAckMessage.gameInfo)
  _has_bits_[0] &= ~0x00000001u;
  ::NetGameInfo* temp = gameinfo_;
  gameinfo_ = nullptr;
  return temp;
}
inline ::NetGameInfo* JoinGameAckMessage::mutable_gameinfo() {
  _has_bits_[0] |= 0x00000001u;
  if (gameinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::NetGameInfo>(GetArenaNoVirtual());
    gameinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:JoinGameAckMessage.gameInfo)
  return gameinfo_;
}
inline void JoinGameAckMessage::set_allocated_gameinfo(::NetGameInfo* gameinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gameinfo_;
  }
  if (gameinfo) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gameinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gameinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gameinfo_ = gameinfo;
  // @@protoc_insertion_point(field_set_allocated:JoinGameAckMessage.gameInfo)
}

// optional bool spectateOnly = 4;
inline bool JoinGameAckMessage::has_spectateonly() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JoinGameAckMessage::clear_spectateonly() {
  spectateonly_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool JoinGameAckMessage::spectateonly() const {
  // @@protoc_insertion_point(field_get:JoinGameAckMessage.spectateOnly)
  return spectateonly_;
}
inline void JoinGameAckMessage::set_spectateonly(bool value) {
  _has_bits_[0] |= 0x00000008u;
  spectateonly_ = value;
  // @@protoc_insertion_point(field_set:JoinGameAckMessage.spectateOnly)
}

// -------------------------------------------------------------------

// JoinGameFailedMessage

// required uint32 gameId = 1;
inline bool JoinGameFailedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinGameFailedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 JoinGameFailedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:JoinGameFailedMessage.gameId)
  return gameid_;
}
inline void JoinGameFailedMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:JoinGameFailedMessage.gameId)
}

// required .JoinGameFailedMessage.JoinGameFailureReason joinGameFailureReason = 2;
inline bool JoinGameFailedMessage::has_joingamefailurereason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinGameFailedMessage::clear_joingamefailurereason() {
  joingamefailurereason_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::JoinGameFailedMessage_JoinGameFailureReason JoinGameFailedMessage::joingamefailurereason() const {
  // @@protoc_insertion_point(field_get:JoinGameFailedMessage.joinGameFailureReason)
  return static_cast< ::JoinGameFailedMessage_JoinGameFailureReason >(joingamefailurereason_);
}
inline void JoinGameFailedMessage::set_joingamefailurereason(::JoinGameFailedMessage_JoinGameFailureReason value) {
  assert(::JoinGameFailedMessage_JoinGameFailureReason_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  joingamefailurereason_ = value;
  // @@protoc_insertion_point(field_set:JoinGameFailedMessage.joinGameFailureReason)
}

// -------------------------------------------------------------------

// GamePlayerJoinedMessage

// required uint32 gameId = 1;
inline bool GamePlayerJoinedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GamePlayerJoinedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 GamePlayerJoinedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GamePlayerJoinedMessage.gameId)
  return gameid_;
}
inline void GamePlayerJoinedMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GamePlayerJoinedMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GamePlayerJoinedMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GamePlayerJoinedMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 GamePlayerJoinedMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GamePlayerJoinedMessage.playerId)
  return playerid_;
}
inline void GamePlayerJoinedMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GamePlayerJoinedMessage.playerId)
}

// required bool isGameAdmin = 3;
inline bool GamePlayerJoinedMessage::has_isgameadmin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GamePlayerJoinedMessage::clear_isgameadmin() {
  isgameadmin_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool GamePlayerJoinedMessage::isgameadmin() const {
  // @@protoc_insertion_point(field_get:GamePlayerJoinedMessage.isGameAdmin)
  return isgameadmin_;
}
inline void GamePlayerJoinedMessage::set_isgameadmin(bool value) {
  _has_bits_[0] |= 0x00000004u;
  isgameadmin_ = value;
  // @@protoc_insertion_point(field_set:GamePlayerJoinedMessage.isGameAdmin)
}

// -------------------------------------------------------------------

// GamePlayerLeftMessage

// required uint32 gameId = 1;
inline bool GamePlayerLeftMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GamePlayerLeftMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 GamePlayerLeftMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GamePlayerLeftMessage.gameId)
  return gameid_;
}
inline void GamePlayerLeftMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GamePlayerLeftMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GamePlayerLeftMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GamePlayerLeftMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 GamePlayerLeftMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GamePlayerLeftMessage.playerId)
  return playerid_;
}
inline void GamePlayerLeftMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GamePlayerLeftMessage.playerId)
}

// required .GamePlayerLeftMessage.GamePlayerLeftReason gamePlayerLeftReason = 3;
inline bool GamePlayerLeftMessage::has_gameplayerleftreason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GamePlayerLeftMessage::clear_gameplayerleftreason() {
  gameplayerleftreason_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::GamePlayerLeftMessage_GamePlayerLeftReason GamePlayerLeftMessage::gameplayerleftreason() const {
  // @@protoc_insertion_point(field_get:GamePlayerLeftMessage.gamePlayerLeftReason)
  return static_cast< ::GamePlayerLeftMessage_GamePlayerLeftReason >(gameplayerleftreason_);
}
inline void GamePlayerLeftMessage::set_gameplayerleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value) {
  assert(::GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  gameplayerleftreason_ = value;
  // @@protoc_insertion_point(field_set:GamePlayerLeftMessage.gamePlayerLeftReason)
}

// -------------------------------------------------------------------

// GameSpectatorJoinedMessage

// required uint32 gameId = 1;
inline bool GameSpectatorJoinedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameSpectatorJoinedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 GameSpectatorJoinedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameSpectatorJoinedMessage.gameId)
  return gameid_;
}
inline void GameSpectatorJoinedMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameSpectatorJoinedMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameSpectatorJoinedMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameSpectatorJoinedMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 GameSpectatorJoinedMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameSpectatorJoinedMessage.playerId)
  return playerid_;
}
inline void GameSpectatorJoinedMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GameSpectatorJoinedMessage.playerId)
}

// -------------------------------------------------------------------

// GameSpectatorLeftMessage

// required uint32 gameId = 1;
inline bool GameSpectatorLeftMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameSpectatorLeftMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 GameSpectatorLeftMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameSpectatorLeftMessage.gameId)
  return gameid_;
}
inline void GameSpectatorLeftMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameSpectatorLeftMessage.gameId)
}

// required uint32 playerId = 2;
inline bool GameSpectatorLeftMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameSpectatorLeftMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 GameSpectatorLeftMessage::playerid() const {
  // @@protoc_insertion_point(field_get:GameSpectatorLeftMessage.playerId)
  return playerid_;
}
inline void GameSpectatorLeftMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GameSpectatorLeftMessage.playerId)
}

// required .GamePlayerLeftMessage.GamePlayerLeftReason gameSpectatorLeftReason = 3;
inline bool GameSpectatorLeftMessage::has_gamespectatorleftreason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameSpectatorLeftMessage::clear_gamespectatorleftreason() {
  gamespectatorleftreason_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::GamePlayerLeftMessage_GamePlayerLeftReason GameSpectatorLeftMessage::gamespectatorleftreason() const {
  // @@protoc_insertion_point(field_get:GameSpectatorLeftMessage.gameSpectatorLeftReason)
  return static_cast< ::GamePlayerLeftMessage_GamePlayerLeftReason >(gamespectatorleftreason_);
}
inline void GameSpectatorLeftMessage::set_gamespectatorleftreason(::GamePlayerLeftMessage_GamePlayerLeftReason value) {
  assert(::GamePlayerLeftMessage_GamePlayerLeftReason_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  gamespectatorleftreason_ = value;
  // @@protoc_insertion_point(field_set:GameSpectatorLeftMessage.gameSpectatorLeftReason)
}

// -------------------------------------------------------------------

// GameAdminChangedMessage

// required uint32 gameId = 1;
inline bool GameAdminChangedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameAdminChangedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 GameAdminChangedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameAdminChangedMessage.gameId)
  return gameid_;
}
inline void GameAdminChangedMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameAdminChangedMessage.gameId)
}

// required uint32 newAdminPlayerId = 2;
inline bool GameAdminChangedMessage::has_newadminplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameAdminChangedMessage::clear_newadminplayerid() {
  newadminplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 GameAdminChangedMessage::newadminplayerid() const {
  // @@protoc_insertion_point(field_get:GameAdminChangedMessage.newAdminPlayerId)
  return newadminplayerid_;
}
inline void GameAdminChangedMessage::set_newadminplayerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  newadminplayerid_ = value;
  // @@protoc_insertion_point(field_set:GameAdminChangedMessage.newAdminPlayerId)
}

// -------------------------------------------------------------------

// RemovedFromGameMessage

// required uint32 gameId = 1;
inline bool RemovedFromGameMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemovedFromGameMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 RemovedFromGameMessage::gameid() const {
  // @@protoc_insertion_point(field_get:RemovedFromGameMessage.gameId)
  return gameid_;
}
inline void RemovedFromGameMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:RemovedFromGameMessage.gameId)
}

// required .RemovedFromGameMessage.RemovedFromGameReason removedFromGameReason = 2;
inline bool RemovedFromGameMessage::has_removedfromgamereason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemovedFromGameMessage::clear_removedfromgamereason() {
  removedfromgamereason_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::RemovedFromGameMessage_RemovedFromGameReason RemovedFromGameMessage::removedfromgamereason() const {
  // @@protoc_insertion_point(field_get:RemovedFromGameMessage.removedFromGameReason)
  return static_cast< ::RemovedFromGameMessage_RemovedFromGameReason >(removedfromgamereason_);
}
inline void RemovedFromGameMessage::set_removedfromgamereason(::RemovedFromGameMessage_RemovedFromGameReason value) {
  assert(::RemovedFromGameMessage_RemovedFromGameReason_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  removedfromgamereason_ = value;
  // @@protoc_insertion_point(field_set:RemovedFromGameMessage.removedFromGameReason)
}

// -------------------------------------------------------------------

// KickPlayerRequestMessage

// required uint32 gameId = 1;
inline bool KickPlayerRequestMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KickPlayerRequestMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 KickPlayerRequestMessage::gameid() const {
  // @@protoc_insertion_point(field_get:KickPlayerRequestMessage.gameId)
  return gameid_;
}
inline void KickPlayerRequestMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:KickPlayerRequestMessage.gameId)
}

// required uint32 playerId = 2;
inline bool KickPlayerRequestMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KickPlayerRequestMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 KickPlayerRequestMessage::playerid() const {
  // @@protoc_insertion_point(field_get:KickPlayerRequestMessage.playerId)
  return playerid_;
}
inline void KickPlayerRequestMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:KickPlayerRequestMessage.playerId)
}

// -------------------------------------------------------------------

// LeaveGameRequestMessage

// required uint32 gameId = 1;
inline bool LeaveGameRequestMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveGameRequestMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 LeaveGameRequestMessage::gameid() const {
  // @@protoc_insertion_point(field_get:LeaveGameRequestMessage.gameId)
  return gameid_;
}
inline void LeaveGameRequestMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:LeaveGameRequestMessage.gameId)
}

// -------------------------------------------------------------------

// InvitePlayerToGameMessage

// required uint32 gameId = 1;
inline bool InvitePlayerToGameMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvitePlayerToGameMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 InvitePlayerToGameMessage::gameid() const {
  // @@protoc_insertion_point(field_get:InvitePlayerToGameMessage.gameId)
  return gameid_;
}
inline void InvitePlayerToGameMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:InvitePlayerToGameMessage.gameId)
}

// required uint32 playerId = 2;
inline bool InvitePlayerToGameMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvitePlayerToGameMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 InvitePlayerToGameMessage::playerid() const {
  // @@protoc_insertion_point(field_get:InvitePlayerToGameMessage.playerId)
  return playerid_;
}
inline void InvitePlayerToGameMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:InvitePlayerToGameMessage.playerId)
}

// -------------------------------------------------------------------

// InviteNotifyMessage

// required uint32 gameId = 1;
inline bool InviteNotifyMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InviteNotifyMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 InviteNotifyMessage::gameid() const {
  // @@protoc_insertion_point(field_get:InviteNotifyMessage.gameId)
  return gameid_;
}
inline void InviteNotifyMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:InviteNotifyMessage.gameId)
}

// required uint32 playerIdWho = 2;
inline bool InviteNotifyMessage::has_playeridwho() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InviteNotifyMessage::clear_playeridwho() {
  playeridwho_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 InviteNotifyMessage::playeridwho() const {
  // @@protoc_insertion_point(field_get:InviteNotifyMessage.playerIdWho)
  return playeridwho_;
}
inline void InviteNotifyMessage::set_playeridwho(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playeridwho_ = value;
  // @@protoc_insertion_point(field_set:InviteNotifyMessage.playerIdWho)
}

// required uint32 playerIdByWhom = 3;
inline bool InviteNotifyMessage::has_playeridbywhom() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InviteNotifyMessage::clear_playeridbywhom() {
  playeridbywhom_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 InviteNotifyMessage::playeridbywhom() const {
  // @@protoc_insertion_point(field_get:InviteNotifyMessage.playerIdByWhom)
  return playeridbywhom_;
}
inline void InviteNotifyMessage::set_playeridbywhom(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  playeridbywhom_ = value;
  // @@protoc_insertion_point(field_set:InviteNotifyMessage.playerIdByWhom)
}

// -------------------------------------------------------------------

// RejectGameInvitationMessage

// required uint32 gameId = 1;
inline bool RejectGameInvitationMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RejectGameInvitationMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 RejectGameInvitationMessage::gameid() const {
  // @@protoc_insertion_point(field_get:RejectGameInvitationMessage.gameId)
  return gameid_;
}
inline void RejectGameInvitationMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:RejectGameInvitationMessage.gameId)
}

// required .RejectGameInvitationMessage.RejectGameInvReason myRejectReason = 2;
inline bool RejectGameInvitationMessage::has_myrejectreason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RejectGameInvitationMessage::clear_myrejectreason() {
  myrejectreason_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::RejectGameInvitationMessage_RejectGameInvReason RejectGameInvitationMessage::myrejectreason() const {
  // @@protoc_insertion_point(field_get:RejectGameInvitationMessage.myRejectReason)
  return static_cast< ::RejectGameInvitationMessage_RejectGameInvReason >(myrejectreason_);
}
inline void RejectGameInvitationMessage::set_myrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value) {
  assert(::RejectGameInvitationMessage_RejectGameInvReason_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  myrejectreason_ = value;
  // @@protoc_insertion_point(field_set:RejectGameInvitationMessage.myRejectReason)
}

// -------------------------------------------------------------------

// RejectInvNotifyMessage

// required uint32 gameId = 1;
inline bool RejectInvNotifyMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RejectInvNotifyMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 RejectInvNotifyMessage::gameid() const {
  // @@protoc_insertion_point(field_get:RejectInvNotifyMessage.gameId)
  return gameid_;
}
inline void RejectInvNotifyMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:RejectInvNotifyMessage.gameId)
}

// required uint32 playerId = 2;
inline bool RejectInvNotifyMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RejectInvNotifyMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 RejectInvNotifyMessage::playerid() const {
  // @@protoc_insertion_point(field_get:RejectInvNotifyMessage.playerId)
  return playerid_;
}
inline void RejectInvNotifyMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:RejectInvNotifyMessage.playerId)
}

// required .RejectGameInvitationMessage.RejectGameInvReason playerRejectReason = 3;
inline bool RejectInvNotifyMessage::has_playerrejectreason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RejectInvNotifyMessage::clear_playerrejectreason() {
  playerrejectreason_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::RejectGameInvitationMessage_RejectGameInvReason RejectInvNotifyMessage::playerrejectreason() const {
  // @@protoc_insertion_point(field_get:RejectInvNotifyMessage.playerRejectReason)
  return static_cast< ::RejectGameInvitationMessage_RejectGameInvReason >(playerrejectreason_);
}
inline void RejectInvNotifyMessage::set_playerrejectreason(::RejectGameInvitationMessage_RejectGameInvReason value) {
  assert(::RejectGameInvitationMessage_RejectGameInvReason_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  playerrejectreason_ = value;
  // @@protoc_insertion_point(field_set:RejectInvNotifyMessage.playerRejectReason)
}

// -------------------------------------------------------------------

// StartEventMessage

// required uint32 gameId = 1;
inline bool StartEventMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartEventMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 StartEventMessage::gameid() const {
  // @@protoc_insertion_point(field_get:StartEventMessage.gameId)
  return gameid_;
}
inline void StartEventMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:StartEventMessage.gameId)
}

// required .StartEventMessage.StartEventType startEventType = 2;
inline bool StartEventMessage::has_starteventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartEventMessage::clear_starteventtype() {
  starteventtype_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::StartEventMessage_StartEventType StartEventMessage::starteventtype() const {
  // @@protoc_insertion_point(field_get:StartEventMessage.startEventType)
  return static_cast< ::StartEventMessage_StartEventType >(starteventtype_);
}
inline void StartEventMessage::set_starteventtype(::StartEventMessage_StartEventType value) {
  assert(::StartEventMessage_StartEventType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  starteventtype_ = value;
  // @@protoc_insertion_point(field_set:StartEventMessage.startEventType)
}

// optional bool fillWithComputerPlayers = 3;
inline bool StartEventMessage::has_fillwithcomputerplayers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartEventMessage::clear_fillwithcomputerplayers() {
  fillwithcomputerplayers_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool StartEventMessage::fillwithcomputerplayers() const {
  // @@protoc_insertion_point(field_get:StartEventMessage.fillWithComputerPlayers)
  return fillwithcomputerplayers_;
}
inline void StartEventMessage::set_fillwithcomputerplayers(bool value) {
  _has_bits_[0] |= 0x00000004u;
  fillwithcomputerplayers_ = value;
  // @@protoc_insertion_point(field_set:StartEventMessage.fillWithComputerPlayers)
}

// -------------------------------------------------------------------

// StartEventAckMessage

// required uint32 gameId = 1;
inline bool StartEventAckMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartEventAckMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 StartEventAckMessage::gameid() const {
  // @@protoc_insertion_point(field_get:StartEventAckMessage.gameId)
  return gameid_;
}
inline void StartEventAckMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:StartEventAckMessage.gameId)
}

// -------------------------------------------------------------------

// GameStartInitialMessage

// required uint32 gameId = 1;
inline bool GameStartInitialMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameStartInitialMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 GameStartInitialMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameStartInitialMessage.gameId)
  return gameid_;
}
inline void GameStartInitialMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameStartInitialMessage.gameId)
}

// required uint32 startDealerPlayerId = 2;
inline bool GameStartInitialMessage::has_startdealerplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameStartInitialMessage::clear_startdealerplayerid() {
  startdealerplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 GameStartInitialMessage::startdealerplayerid() const {
  // @@protoc_insertion_point(field_get:GameStartInitialMessage.startDealerPlayerId)
  return startdealerplayerid_;
}
inline void GameStartInitialMessage::set_startdealerplayerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  startdealerplayerid_ = value;
  // @@protoc_insertion_point(field_set:GameStartInitialMessage.startDealerPlayerId)
}

// repeated uint32 playerSeats = 3 [packed = true];
inline int GameStartInitialMessage::playerseats_size() const {
  return playerseats_.size();
}
inline void GameStartInitialMessage::clear_playerseats() {
  playerseats_.Clear();
}
inline ::google::protobuf::uint32 GameStartInitialMessage::playerseats(int index) const {
  // @@protoc_insertion_point(field_get:GameStartInitialMessage.playerSeats)
  return playerseats_.Get(index);
}
inline void GameStartInitialMessage::set_playerseats(int index, ::google::protobuf::uint32 value) {
  playerseats_.Set(index, value);
  // @@protoc_insertion_point(field_set:GameStartInitialMessage.playerSeats)
}
inline void GameStartInitialMessage::add_playerseats(::google::protobuf::uint32 value) {
  playerseats_.Add(value);
  // @@protoc_insertion_point(field_add:GameStartInitialMessage.playerSeats)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GameStartInitialMessage::playerseats() const {
  // @@protoc_insertion_point(field_list:GameStartInitialMessage.playerSeats)
  return playerseats_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GameStartInitialMessage::mutable_playerseats() {
  // @@protoc_insertion_point(field_mutable_list:GameStartInitialMessage.playerSeats)
  return &playerseats_;
}

// -------------------------------------------------------------------

// GameStartRejoinMessage_RejoinPlayerData

// required uint32 playerId = 1;
inline bool GameStartRejoinMessage_RejoinPlayerData::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameStartRejoinMessage_RejoinPlayerData::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 GameStartRejoinMessage_RejoinPlayerData::playerid() const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.RejoinPlayerData.playerId)
  return playerid_;
}
inline void GameStartRejoinMessage_RejoinPlayerData::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:GameStartRejoinMessage.RejoinPlayerData.playerId)
}

// required uint32 playerMoney = 2;
inline bool GameStartRejoinMessage_RejoinPlayerData::has_playermoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameStartRejoinMessage_RejoinPlayerData::clear_playermoney() {
  playermoney_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 GameStartRejoinMessage_RejoinPlayerData::playermoney() const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.RejoinPlayerData.playerMoney)
  return playermoney_;
}
inline void GameStartRejoinMessage_RejoinPlayerData::set_playermoney(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playermoney_ = value;
  // @@protoc_insertion_point(field_set:GameStartRejoinMessage.RejoinPlayerData.playerMoney)
}

// -------------------------------------------------------------------

// GameStartRejoinMessage

// required uint32 gameId = 1;
inline bool GameStartRejoinMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameStartRejoinMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 GameStartRejoinMessage::gameid() const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.gameId)
  return gameid_;
}
inline void GameStartRejoinMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:GameStartRejoinMessage.gameId)
}

// required uint32 startDealerPlayerId = 2;
inline bool GameStartRejoinMessage::has_startdealerplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameStartRejoinMessage::clear_startdealerplayerid() {
  startdealerplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 GameStartRejoinMessage::startdealerplayerid() const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.startDealerPlayerId)
  return startdealerplayerid_;
}
inline void GameStartRejoinMessage::set_startdealerplayerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  startdealerplayerid_ = value;
  // @@protoc_insertion_point(field_set:GameStartRejoinMessage.startDealerPlayerId)
}

// required uint32 handNum = 3;
inline bool GameStartRejoinMessage::has_handnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameStartRejoinMessage::clear_handnum() {
  handnum_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 GameStartRejoinMessage::handnum() const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.handNum)
  return handnum_;
}
inline void GameStartRejoinMessage::set_handnum(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  handnum_ = value;
  // @@protoc_insertion_point(field_set:GameStartRejoinMessage.handNum)
}

// repeated .GameStartRejoinMessage.RejoinPlayerData rejoinPlayerData = 4;
inline int GameStartRejoinMessage::rejoinplayerdata_size() const {
  return rejoinplayerdata_.size();
}
inline void GameStartRejoinMessage::clear_rejoinplayerdata() {
  rejoinplayerdata_.Clear();
}
inline ::GameStartRejoinMessage_RejoinPlayerData* GameStartRejoinMessage::mutable_rejoinplayerdata(int index) {
  // @@protoc_insertion_point(field_mutable:GameStartRejoinMessage.rejoinPlayerData)
  return rejoinplayerdata_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData >*
GameStartRejoinMessage::mutable_rejoinplayerdata() {
  // @@protoc_insertion_point(field_mutable_list:GameStartRejoinMessage.rejoinPlayerData)
  return &rejoinplayerdata_;
}
inline const ::GameStartRejoinMessage_RejoinPlayerData& GameStartRejoinMessage::rejoinplayerdata(int index) const {
  // @@protoc_insertion_point(field_get:GameStartRejoinMessage.rejoinPlayerData)
  return rejoinplayerdata_.Get(index);
}
inline ::GameStartRejoinMessage_RejoinPlayerData* GameStartRejoinMessage::add_rejoinplayerdata() {
  // @@protoc_insertion_point(field_add:GameStartRejoinMessage.rejoinPlayerData)
  return rejoinplayerdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GameStartRejoinMessage_RejoinPlayerData >&
GameStartRejoinMessage::rejoinplayerdata() const {
  // @@protoc_insertion_point(field_list:GameStartRejoinMessage.rejoinPlayerData)
  return rejoinplayerdata_;
}

// -------------------------------------------------------------------

// HandStartMessage_PlainCards

// required uint32 plainCard1 = 1;
inline bool HandStartMessage_PlainCards::has_plaincard1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HandStartMessage_PlainCards::clear_plaincard1() {
  plaincard1_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 HandStartMessage_PlainCards::plaincard1() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.PlainCards.plainCard1)
  return plaincard1_;
}
inline void HandStartMessage_PlainCards::set_plaincard1(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  plaincard1_ = value;
  // @@protoc_insertion_point(field_set:HandStartMessage.PlainCards.plainCard1)
}

// required uint32 plainCard2 = 2;
inline bool HandStartMessage_PlainCards::has_plaincard2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HandStartMessage_PlainCards::clear_plaincard2() {
  plaincard2_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 HandStartMessage_PlainCards::plaincard2() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.PlainCards.plainCard2)
  return plaincard2_;
}
inline void HandStartMessage_PlainCards::set_plaincard2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  plaincard2_ = value;
  // @@protoc_insertion_point(field_set:HandStartMessage.PlainCards.plainCard2)
}

// -------------------------------------------------------------------

// HandStartMessage

// required uint32 gameId = 1;
inline bool HandStartMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HandStartMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 HandStartMessage::gameid() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.gameId)
  return gameid_;
}
inline void HandStartMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:HandStartMessage.gameId)
}

// optional .HandStartMessage.PlainCards plainCards = 2;
inline bool HandStartMessage::has_plaincards() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HandStartMessage::clear_plaincards() {
  if (plaincards_ != nullptr) plaincards_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::HandStartMessage_PlainCards& HandStartMessage::plaincards() const {
  const ::HandStartMessage_PlainCards* p = plaincards_;
  // @@protoc_insertion_point(field_get:HandStartMessage.plainCards)
  return p != nullptr ? *p : *reinterpret_cast<const ::HandStartMessage_PlainCards*>(
      &::_HandStartMessage_PlainCards_default_instance_);
}
inline ::HandStartMessage_PlainCards* HandStartMessage::release_plaincards() {
  // @@protoc_insertion_point(field_release:HandStartMessage.plainCards)
  _has_bits_[0] &= ~0x00000002u;
  ::HandStartMessage_PlainCards* temp = plaincards_;
  plaincards_ = nullptr;
  return temp;
}
inline ::HandStartMessage_PlainCards* HandStartMessage::mutable_plaincards() {
  _has_bits_[0] |= 0x00000002u;
  if (plaincards_ == nullptr) {
    auto* p = CreateMaybeMessage<::HandStartMessage_PlainCards>(GetArenaNoVirtual());
    plaincards_ = p;
  }
  // @@protoc_insertion_point(field_mutable:HandStartMessage.plainCards)
  return plaincards_;
}
inline void HandStartMessage::set_allocated_plaincards(::HandStartMessage_PlainCards* plaincards) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete plaincards_;
  }
  if (plaincards) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      plaincards = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, plaincards, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  plaincards_ = plaincards;
  // @@protoc_insertion_point(field_set_allocated:HandStartMessage.plainCards)
}

// optional bytes encryptedCards = 3;
inline bool HandStartMessage::has_encryptedcards() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HandStartMessage::clear_encryptedcards() {
  encryptedcards_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& HandStartMessage::encryptedcards() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.encryptedCards)
  return encryptedcards_.GetNoArena();
}
inline void HandStartMessage::set_encryptedcards(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  encryptedcards_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:HandStartMessage.encryptedCards)
}
#if LANG_CXX11
inline void HandStartMessage::set_encryptedcards(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  encryptedcards_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:HandStartMessage.encryptedCards)
}
#endif
inline void HandStartMessage::set_encryptedcards(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  encryptedcards_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:HandStartMessage.encryptedCards)
}
inline void HandStartMessage::set_encryptedcards(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  encryptedcards_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:HandStartMessage.encryptedCards)
}
inline ::std::string* HandStartMessage::mutable_encryptedcards() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:HandStartMessage.encryptedCards)
  return encryptedcards_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HandStartMessage::release_encryptedcards() {
  // @@protoc_insertion_point(field_release:HandStartMessage.encryptedCards)
  if (!has_encryptedcards()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return encryptedcards_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HandStartMessage::set_allocated_encryptedcards(::std::string* encryptedcards) {
  if (encryptedcards != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  encryptedcards_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), encryptedcards);
  // @@protoc_insertion_point(field_set_allocated:HandStartMessage.encryptedCards)
}

// required uint32 smallBlind = 4;
inline bool HandStartMessage::has_smallblind() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HandStartMessage::clear_smallblind() {
  smallblind_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 HandStartMessage::smallblind() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.smallBlind)
  return smallblind_;
}
inline void HandStartMessage::set_smallblind(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  smallblind_ = value;
  // @@protoc_insertion_point(field_set:HandStartMessage.smallBlind)
}

// repeated .NetPlayerState seatStates = 5;
inline int HandStartMessage::seatstates_size() const {
  return seatstates_.size();
}
inline void HandStartMessage::clear_seatstates() {
  seatstates_.Clear();
}
inline ::NetPlayerState HandStartMessage::seatstates(int index) const {
  // @@protoc_insertion_point(field_get:HandStartMessage.seatStates)
  return static_cast< ::NetPlayerState >(seatstates_.Get(index));
}
inline void HandStartMessage::set_seatstates(int index, ::NetPlayerState value) {
  assert(::NetPlayerState_IsValid(value));
  seatstates_.Set(index, value);
  // @@protoc_insertion_point(field_set:HandStartMessage.seatStates)
}
inline void HandStartMessage::add_seatstates(::NetPlayerState value) {
  assert(::NetPlayerState_IsValid(value));
  seatstates_.Add(value);
  // @@protoc_insertion_point(field_add:HandStartMessage.seatStates)
}
inline const ::google::protobuf::RepeatedField<int>&
HandStartMessage::seatstates() const {
  // @@protoc_insertion_point(field_list:HandStartMessage.seatStates)
  return seatstates_;
}
inline ::google::protobuf::RepeatedField<int>*
HandStartMessage::mutable_seatstates() {
  // @@protoc_insertion_point(field_mutable_list:HandStartMessage.seatStates)
  return &seatstates_;
}

// optional uint32 dealerPlayerId = 6;
inline bool HandStartMessage::has_dealerplayerid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HandStartMessage::clear_dealerplayerid() {
  dealerplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 HandStartMessage::dealerplayerid() const {
  // @@protoc_insertion_point(field_get:HandStartMessage.dealerPlayerId)
  return dealerplayerid_;
}
inline void HandStartMessage::set_dealerplayerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  dealerplayerid_ = value;
  // @@protoc_insertion_point(field_set:HandStartMessage.dealerPlayerId)
}

// -------------------------------------------------------------------

// PlayersTurnMessage

// required uint32 gameId = 1;
inline bool PlayersTurnMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayersTurnMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 PlayersTurnMessage::gameid() const {
  // @@protoc_insertion_point(field_get:PlayersTurnMessage.gameId)
  return gameid_;
}
inline void PlayersTurnMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:PlayersTurnMessage.gameId)
}

// required uint32 playerId = 2;
inline bool PlayersTurnMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayersTurnMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 PlayersTurnMessage::playerid() const {
  // @@protoc_insertion_point(field_get:PlayersTurnMessage.playerId)
  return playerid_;
}
inline void PlayersTurnMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:PlayersTurnMessage.playerId)
}

// required .NetGameState gameState = 3;
inline bool PlayersTurnMessage::has_gamestate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayersTurnMessage::clear_gamestate() {
  gamestate_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::NetGameState PlayersTurnMessage::gamestate() const {
  // @@protoc_insertion_point(field_get:PlayersTurnMessage.gameState)
  return static_cast< ::NetGameState >(gamestate_);
}
inline void PlayersTurnMessage::set_gamestate(::NetGameState value) {
  assert(::NetGameState_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  gamestate_ = value;
  // @@protoc_insertion_point(field_set:PlayersTurnMessage.gameState)
}

// -------------------------------------------------------------------

// MyActionRequestMessage

// required uint32 gameId = 1;
inline bool MyActionRequestMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MyActionRequestMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 MyActionRequestMessage::gameid() const {
  // @@protoc_insertion_point(field_get:MyActionRequestMessage.gameId)
  return gameid_;
}
inline void MyActionRequestMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:MyActionRequestMessage.gameId)
}

// required uint32 handNum = 2;
inline bool MyActionRequestMessage::has_handnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MyActionRequestMessage::clear_handnum() {
  handnum_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 MyActionRequestMessage::handnum() const {
  // @@protoc_insertion_point(field_get:MyActionRequestMessage.handNum)
  return handnum_;
}
inline void MyActionRequestMessage::set_handnum(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  handnum_ = value;
  // @@protoc_insertion_point(field_set:MyActionRequestMessage.handNum)
}

// required .NetGameState gameState = 3;
inline bool MyActionRequestMessage::has_gamestate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MyActionRequestMessage::clear_gamestate() {
  gamestate_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::NetGameState MyActionRequestMessage::gamestate() const {
  // @@protoc_insertion_point(field_get:MyActionRequestMessage.gameState)
  return static_cast< ::NetGameState >(gamestate_);
}
inline void MyActionRequestMessage::set_gamestate(::NetGameState value) {
  assert(::NetGameState_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  gamestate_ = value;
  // @@protoc_insertion_point(field_set:MyActionRequestMessage.gameState)
}

// required .NetPlayerAction myAction = 4;
inline bool MyActionRequestMessage::has_myaction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MyActionRequestMessage::clear_myaction() {
  myaction_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::NetPlayerAction MyActionRequestMessage::myaction() const {
  // @@protoc_insertion_point(field_get:MyActionRequestMessage.myAction)
  return static_cast< ::NetPlayerAction >(myaction_);
}
inline void MyActionRequestMessage::set_myaction(::NetPlayerAction value) {
  assert(::NetPlayerAction_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  myaction_ = value;
  // @@protoc_insertion_point(field_set:MyActionRequestMessage.myAction)
}

// required uint32 myRelativeBet = 5;
inline bool MyActionRequestMessage::has_myrelativebet() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MyActionRequestMessage::clear_myrelativebet() {
  myrelativebet_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 MyActionRequestMessage::myrelativebet() const {
  // @@protoc_insertion_point(field_get:MyActionRequestMessage.myRelativeBet)
  return myrelativebet_;
}
inline void MyActionRequestMessage::set_myrelativebet(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  myrelativebet_ = value;
  // @@protoc_insertion_point(field_set:MyActionRequestMessage.myRelativeBet)
}

// -------------------------------------------------------------------

// YourActionRejectedMessage

// required uint32 gameId = 1;
inline bool YourActionRejectedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YourActionRejectedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 YourActionRejectedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:YourActionRejectedMessage.gameId)
  return gameid_;
}
inline void YourActionRejectedMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:YourActionRejectedMessage.gameId)
}

// required .NetGameState gameState = 2;
inline bool YourActionRejectedMessage::has_gamestate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YourActionRejectedMessage::clear_gamestate() {
  gamestate_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::NetGameState YourActionRejectedMessage::gamestate() const {
  // @@protoc_insertion_point(field_get:YourActionRejectedMessage.gameState)
  return static_cast< ::NetGameState >(gamestate_);
}
inline void YourActionRejectedMessage::set_gamestate(::NetGameState value) {
  assert(::NetGameState_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  gamestate_ = value;
  // @@protoc_insertion_point(field_set:YourActionRejectedMessage.gameState)
}

// required .NetPlayerAction yourAction = 3;
inline bool YourActionRejectedMessage::has_youraction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void YourActionRejectedMessage::clear_youraction() {
  youraction_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::NetPlayerAction YourActionRejectedMessage::youraction() const {
  // @@protoc_insertion_point(field_get:YourActionRejectedMessage.yourAction)
  return static_cast< ::NetPlayerAction >(youraction_);
}
inline void YourActionRejectedMessage::set_youraction(::NetPlayerAction value) {
  assert(::NetPlayerAction_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  youraction_ = value;
  // @@protoc_insertion_point(field_set:YourActionRejectedMessage.yourAction)
}

// required uint32 yourRelativeBet = 4;
inline bool YourActionRejectedMessage::has_yourrelativebet() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void YourActionRejectedMessage::clear_yourrelativebet() {
  yourrelativebet_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 YourActionRejectedMessage::yourrelativebet() const {
  // @@protoc_insertion_point(field_get:YourActionRejectedMessage.yourRelativeBet)
  return yourrelativebet_;
}
inline void YourActionRejectedMessage::set_yourrelativebet(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  yourrelativebet_ = value;
  // @@protoc_insertion_point(field_set:YourActionRejectedMessage.yourRelativeBet)
}

// required .YourActionRejectedMessage.RejectionReason rejectionReason = 5;
inline bool YourActionRejectedMessage::has_rejectionreason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void YourActionRejectedMessage::clear_rejectionreason() {
  rejectionreason_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::YourActionRejectedMessage_RejectionReason YourActionRejectedMessage::rejectionreason() const {
  // @@protoc_insertion_point(field_get:YourActionRejectedMessage.rejectionReason)
  return static_cast< ::YourActionRejectedMessage_RejectionReason >(rejectionreason_);
}
inline void YourActionRejectedMessage::set_rejectionreason(::YourActionRejectedMessage_RejectionReason value) {
  assert(::YourActionRejectedMessage_RejectionReason_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  rejectionreason_ = value;
  // @@protoc_insertion_point(field_set:YourActionRejectedMessage.rejectionReason)
}

// -------------------------------------------------------------------

// PlayersActionDoneMessage

// required uint32 gameId = 1;
inline bool PlayersActionDoneMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayersActionDoneMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::gameid() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.gameId)
  return gameid_;
}
inline void PlayersActionDoneMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.gameId)
}

// required uint32 playerId = 2;
inline bool PlayersActionDoneMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayersActionDoneMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::playerid() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.playerId)
  return playerid_;
}
inline void PlayersActionDoneMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.playerId)
}

// required .NetGameState gameState = 3;
inline bool PlayersActionDoneMessage::has_gamestate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayersActionDoneMessage::clear_gamestate() {
  gamestate_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::NetGameState PlayersActionDoneMessage::gamestate() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.gameState)
  return static_cast< ::NetGameState >(gamestate_);
}
inline void PlayersActionDoneMessage::set_gamestate(::NetGameState value) {
  assert(::NetGameState_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  gamestate_ = value;
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.gameState)
}

// required .NetPlayerAction playerAction = 4;
inline bool PlayersActionDoneMessage::has_playeraction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayersActionDoneMessage::clear_playeraction() {
  playeraction_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::NetPlayerAction PlayersActionDoneMessage::playeraction() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.playerAction)
  return static_cast< ::NetPlayerAction >(playeraction_);
}
inline void PlayersActionDoneMessage::set_playeraction(::NetPlayerAction value) {
  assert(::NetPlayerAction_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  playeraction_ = value;
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.playerAction)
}

// required uint32 totalPlayerBet = 5;
inline bool PlayersActionDoneMessage::has_totalplayerbet() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayersActionDoneMessage::clear_totalplayerbet() {
  totalplayerbet_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::totalplayerbet() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.totalPlayerBet)
  return totalplayerbet_;
}
inline void PlayersActionDoneMessage::set_totalplayerbet(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  totalplayerbet_ = value;
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.totalPlayerBet)
}

// required uint32 playerMoney = 6;
inline bool PlayersActionDoneMessage::has_playermoney() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayersActionDoneMessage::clear_playermoney() {
  playermoney_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::playermoney() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.playerMoney)
  return playermoney_;
}
inline void PlayersActionDoneMessage::set_playermoney(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  playermoney_ = value;
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.playerMoney)
}

// required uint32 highestSet = 7;
inline bool PlayersActionDoneMessage::has_highestset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayersActionDoneMessage::clear_highestset() {
  highestset_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::highestset() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.highestSet)
  return highestset_;
}
inline void PlayersActionDoneMessage::set_highestset(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  highestset_ = value;
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.highestSet)
}

// required uint32 minimumRaise = 8;
inline bool PlayersActionDoneMessage::has_minimumraise() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayersActionDoneMessage::clear_minimumraise() {
  minimumraise_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 PlayersActionDoneMessage::minimumraise() const {
  // @@protoc_insertion_point(field_get:PlayersActionDoneMessage.minimumRaise)
  return minimumraise_;
}
inline void PlayersActionDoneMessage::set_minimumraise(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  minimumraise_ = value;
  // @@protoc_insertion_point(field_set:PlayersActionDoneMessage.minimumRaise)
}

// -------------------------------------------------------------------

// DealFlopCardsMessage

// required uint32 gameId = 1;
inline bool DealFlopCardsMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DealFlopCardsMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 DealFlopCardsMessage::gameid() const {
  // @@protoc_insertion_point(field_get:DealFlopCardsMessage.gameId)
  return gameid_;
}
inline void DealFlopCardsMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:DealFlopCardsMessage.gameId)
}

// required uint32 flopCard1 = 2;
inline bool DealFlopCardsMessage::has_flopcard1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DealFlopCardsMessage::clear_flopcard1() {
  flopcard1_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 DealFlopCardsMessage::flopcard1() const {
  // @@protoc_insertion_point(field_get:DealFlopCardsMessage.flopCard1)
  return flopcard1_;
}
inline void DealFlopCardsMessage::set_flopcard1(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  flopcard1_ = value;
  // @@protoc_insertion_point(field_set:DealFlopCardsMessage.flopCard1)
}

// required uint32 flopCard2 = 3;
inline bool DealFlopCardsMessage::has_flopcard2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DealFlopCardsMessage::clear_flopcard2() {
  flopcard2_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 DealFlopCardsMessage::flopcard2() const {
  // @@protoc_insertion_point(field_get:DealFlopCardsMessage.flopCard2)
  return flopcard2_;
}
inline void DealFlopCardsMessage::set_flopcard2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  flopcard2_ = value;
  // @@protoc_insertion_point(field_set:DealFlopCardsMessage.flopCard2)
}

// required uint32 flopCard3 = 4;
inline bool DealFlopCardsMessage::has_flopcard3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DealFlopCardsMessage::clear_flopcard3() {
  flopcard3_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 DealFlopCardsMessage::flopcard3() const {
  // @@protoc_insertion_point(field_get:DealFlopCardsMessage.flopCard3)
  return flopcard3_;
}
inline void DealFlopCardsMessage::set_flopcard3(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  flopcard3_ = value;
  // @@protoc_insertion_point(field_set:DealFlopCardsMessage.flopCard3)
}

// -------------------------------------------------------------------

// DealTurnCardMessage

// required uint32 gameId = 1;
inline bool DealTurnCardMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DealTurnCardMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 DealTurnCardMessage::gameid() const {
  // @@protoc_insertion_point(field_get:DealTurnCardMessage.gameId)
  return gameid_;
}
inline void DealTurnCardMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:DealTurnCardMessage.gameId)
}

// required uint32 turnCard = 2;
inline bool DealTurnCardMessage::has_turncard() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DealTurnCardMessage::clear_turncard() {
  turncard_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 DealTurnCardMessage::turncard() const {
  // @@protoc_insertion_point(field_get:DealTurnCardMessage.turnCard)
  return turncard_;
}
inline void DealTurnCardMessage::set_turncard(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  turncard_ = value;
  // @@protoc_insertion_point(field_set:DealTurnCardMessage.turnCard)
}

// -------------------------------------------------------------------

// DealRiverCardMessage

// required uint32 gameId = 1;
inline bool DealRiverCardMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DealRiverCardMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 DealRiverCardMessage::gameid() const {
  // @@protoc_insertion_point(field_get:DealRiverCardMessage.gameId)
  return gameid_;
}
inline void DealRiverCardMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:DealRiverCardMessage.gameId)
}

// required uint32 riverCard = 2;
inline bool DealRiverCardMessage::has_rivercard() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DealRiverCardMessage::clear_rivercard() {
  rivercard_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 DealRiverCardMessage::rivercard() const {
  // @@protoc_insertion_point(field_get:DealRiverCardMessage.riverCard)
  return rivercard_;
}
inline void DealRiverCardMessage::set_rivercard(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  rivercard_ = value;
  // @@protoc_insertion_point(field_set:DealRiverCardMessage.riverCard)
}

// -------------------------------------------------------------------

// AllInShowCardsMessage_PlayerAllIn

// required uint32 playerId = 1;
inline bool AllInShowCardsMessage_PlayerAllIn::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 AllInShowCardsMessage_PlayerAllIn::playerid() const {
  // @@protoc_insertion_point(field_get:AllInShowCardsMessage.PlayerAllIn.playerId)
  return playerid_;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:AllInShowCardsMessage.PlayerAllIn.playerId)
}

// required uint32 allInCard1 = 2;
inline bool AllInShowCardsMessage_PlayerAllIn::has_allincard1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_allincard1() {
  allincard1_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 AllInShowCardsMessage_PlayerAllIn::allincard1() const {
  // @@protoc_insertion_point(field_get:AllInShowCardsMessage.PlayerAllIn.allInCard1)
  return allincard1_;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_allincard1(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  allincard1_ = value;
  // @@protoc_insertion_point(field_set:AllInShowCardsMessage.PlayerAllIn.allInCard1)
}

// required uint32 allInCard2 = 3;
inline bool AllInShowCardsMessage_PlayerAllIn::has_allincard2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AllInShowCardsMessage_PlayerAllIn::clear_allincard2() {
  allincard2_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 AllInShowCardsMessage_PlayerAllIn::allincard2() const {
  // @@protoc_insertion_point(field_get:AllInShowCardsMessage.PlayerAllIn.allInCard2)
  return allincard2_;
}
inline void AllInShowCardsMessage_PlayerAllIn::set_allincard2(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  allincard2_ = value;
  // @@protoc_insertion_point(field_set:AllInShowCardsMessage.PlayerAllIn.allInCard2)
}

// -------------------------------------------------------------------

// AllInShowCardsMessage

// required uint32 gameId = 1;
inline bool AllInShowCardsMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllInShowCardsMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 AllInShowCardsMessage::gameid() const {
  // @@protoc_insertion_point(field_get:AllInShowCardsMessage.gameId)
  return gameid_;
}
inline void AllInShowCardsMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:AllInShowCardsMessage.gameId)
}

// repeated .AllInShowCardsMessage.PlayerAllIn playersAllIn = 2;
inline int AllInShowCardsMessage::playersallin_size() const {
  return playersallin_.size();
}
inline void AllInShowCardsMessage::clear_playersallin() {
  playersallin_.Clear();
}
inline ::AllInShowCardsMessage_PlayerAllIn* AllInShowCardsMessage::mutable_playersallin(int index) {
  // @@protoc_insertion_point(field_mutable:AllInShowCardsMessage.playersAllIn)
  return playersallin_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn >*
AllInShowCardsMessage::mutable_playersallin() {
  // @@protoc_insertion_point(field_mutable_list:AllInShowCardsMessage.playersAllIn)
  return &playersallin_;
}
inline const ::AllInShowCardsMessage_PlayerAllIn& AllInShowCardsMessage::playersallin(int index) const {
  // @@protoc_insertion_point(field_get:AllInShowCardsMessage.playersAllIn)
  return playersallin_.Get(index);
}
inline ::AllInShowCardsMessage_PlayerAllIn* AllInShowCardsMessage::add_playersallin() {
  // @@protoc_insertion_point(field_add:AllInShowCardsMessage.playersAllIn)
  return playersallin_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AllInShowCardsMessage_PlayerAllIn >&
AllInShowCardsMessage::playersallin() const {
  // @@protoc_insertion_point(field_list:AllInShowCardsMessage.playersAllIn)
  return playersallin_;
}

// -------------------------------------------------------------------

// EndOfHandShowCardsMessage

// required uint32 gameId = 1;
inline bool EndOfHandShowCardsMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndOfHandShowCardsMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 EndOfHandShowCardsMessage::gameid() const {
  // @@protoc_insertion_point(field_get:EndOfHandShowCardsMessage.gameId)
  return gameid_;
}
inline void EndOfHandShowCardsMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:EndOfHandShowCardsMessage.gameId)
}

// repeated .PlayerResult playerResults = 2;
inline int EndOfHandShowCardsMessage::playerresults_size() const {
  return playerresults_.size();
}
inline void EndOfHandShowCardsMessage::clear_playerresults() {
  playerresults_.Clear();
}
inline ::PlayerResult* EndOfHandShowCardsMessage::mutable_playerresults(int index) {
  // @@protoc_insertion_point(field_mutable:EndOfHandShowCardsMessage.playerResults)
  return playerresults_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerResult >*
EndOfHandShowCardsMessage::mutable_playerresults() {
  // @@protoc_insertion_point(field_mutable_list:EndOfHandShowCardsMessage.playerResults)
  return &playerresults_;
}
inline const ::PlayerResult& EndOfHandShowCardsMessage::playerresults(int index) const {
  // @@protoc_insertion_point(field_get:EndOfHandShowCardsMessage.playerResults)
  return playerresults_.Get(index);
}
inline ::PlayerResult* EndOfHandShowCardsMessage::add_playerresults() {
  // @@protoc_insertion_point(field_add:EndOfHandShowCardsMessage.playerResults)
  return playerresults_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerResult >&
EndOfHandShowCardsMessage::playerresults() const {
  // @@protoc_insertion_point(field_list:EndOfHandShowCardsMessage.playerResults)
  return playerresults_;
}

// -------------------------------------------------------------------

// EndOfHandHideCardsMessage

// required uint32 gameId = 1;
inline bool EndOfHandHideCardsMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndOfHandHideCardsMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 EndOfHandHideCardsMessage::gameid() const {
  // @@protoc_insertion_point(field_get:EndOfHandHideCardsMessage.gameId)
  return gameid_;
}
inline void EndOfHandHideCardsMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:EndOfHandHideCardsMessage.gameId)
}

// required uint32 playerId = 2;
inline bool EndOfHandHideCardsMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndOfHandHideCardsMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 EndOfHandHideCardsMessage::playerid() const {
  // @@protoc_insertion_point(field_get:EndOfHandHideCardsMessage.playerId)
  return playerid_;
}
inline void EndOfHandHideCardsMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:EndOfHandHideCardsMessage.playerId)
}

// required uint32 moneyWon = 3;
inline bool EndOfHandHideCardsMessage::has_moneywon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EndOfHandHideCardsMessage::clear_moneywon() {
  moneywon_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 EndOfHandHideCardsMessage::moneywon() const {
  // @@protoc_insertion_point(field_get:EndOfHandHideCardsMessage.moneyWon)
  return moneywon_;
}
inline void EndOfHandHideCardsMessage::set_moneywon(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  moneywon_ = value;
  // @@protoc_insertion_point(field_set:EndOfHandHideCardsMessage.moneyWon)
}

// required uint32 playerMoney = 4;
inline bool EndOfHandHideCardsMessage::has_playermoney() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EndOfHandHideCardsMessage::clear_playermoney() {
  playermoney_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 EndOfHandHideCardsMessage::playermoney() const {
  // @@protoc_insertion_point(field_get:EndOfHandHideCardsMessage.playerMoney)
  return playermoney_;
}
inline void EndOfHandHideCardsMessage::set_playermoney(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  playermoney_ = value;
  // @@protoc_insertion_point(field_set:EndOfHandHideCardsMessage.playerMoney)
}

// -------------------------------------------------------------------

// ShowMyCardsRequestMessage

// -------------------------------------------------------------------

// AfterHandShowCardsMessage

// required .PlayerResult playerResult = 1;
inline bool AfterHandShowCardsMessage::has_playerresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AfterHandShowCardsMessage::clear_playerresult() {
  if (playerresult_ != nullptr) playerresult_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PlayerResult& AfterHandShowCardsMessage::playerresult() const {
  const ::PlayerResult* p = playerresult_;
  // @@protoc_insertion_point(field_get:AfterHandShowCardsMessage.playerResult)
  return p != nullptr ? *p : *reinterpret_cast<const ::PlayerResult*>(
      &::_PlayerResult_default_instance_);
}
inline ::PlayerResult* AfterHandShowCardsMessage::release_playerresult() {
  // @@protoc_insertion_point(field_release:AfterHandShowCardsMessage.playerResult)
  _has_bits_[0] &= ~0x00000001u;
  ::PlayerResult* temp = playerresult_;
  playerresult_ = nullptr;
  return temp;
}
inline ::PlayerResult* AfterHandShowCardsMessage::mutable_playerresult() {
  _has_bits_[0] |= 0x00000001u;
  if (playerresult_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerResult>(GetArenaNoVirtual());
    playerresult_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AfterHandShowCardsMessage.playerResult)
  return playerresult_;
}
inline void AfterHandShowCardsMessage::set_allocated_playerresult(::PlayerResult* playerresult) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete playerresult_;
  }
  if (playerresult) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      playerresult = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, playerresult, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  playerresult_ = playerresult;
  // @@protoc_insertion_point(field_set_allocated:AfterHandShowCardsMessage.playerResult)
}

// -------------------------------------------------------------------

// EndOfGameMessage

// required uint32 gameId = 1;
inline bool EndOfGameMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndOfGameMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 EndOfGameMessage::gameid() const {
  // @@protoc_insertion_point(field_get:EndOfGameMessage.gameId)
  return gameid_;
}
inline void EndOfGameMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:EndOfGameMessage.gameId)
}

// required uint32 winnerPlayerId = 2;
inline bool EndOfGameMessage::has_winnerplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndOfGameMessage::clear_winnerplayerid() {
  winnerplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 EndOfGameMessage::winnerplayerid() const {
  // @@protoc_insertion_point(field_get:EndOfGameMessage.winnerPlayerId)
  return winnerplayerid_;
}
inline void EndOfGameMessage::set_winnerplayerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  winnerplayerid_ = value;
  // @@protoc_insertion_point(field_set:EndOfGameMessage.winnerPlayerId)
}

// -------------------------------------------------------------------

// PlayerIdChangedMessage

// required uint32 oldPlayerId = 1;
inline bool PlayerIdChangedMessage::has_oldplayerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerIdChangedMessage::clear_oldplayerid() {
  oldplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 PlayerIdChangedMessage::oldplayerid() const {
  // @@protoc_insertion_point(field_get:PlayerIdChangedMessage.oldPlayerId)
  return oldplayerid_;
}
inline void PlayerIdChangedMessage::set_oldplayerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  oldplayerid_ = value;
  // @@protoc_insertion_point(field_set:PlayerIdChangedMessage.oldPlayerId)
}

// required uint32 newPlayerId = 2;
inline bool PlayerIdChangedMessage::has_newplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerIdChangedMessage::clear_newplayerid() {
  newplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 PlayerIdChangedMessage::newplayerid() const {
  // @@protoc_insertion_point(field_get:PlayerIdChangedMessage.newPlayerId)
  return newplayerid_;
}
inline void PlayerIdChangedMessage::set_newplayerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  newplayerid_ = value;
  // @@protoc_insertion_point(field_set:PlayerIdChangedMessage.newPlayerId)
}

// -------------------------------------------------------------------

// AskKickPlayerMessage

// required uint32 gameId = 1;
inline bool AskKickPlayerMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AskKickPlayerMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 AskKickPlayerMessage::gameid() const {
  // @@protoc_insertion_point(field_get:AskKickPlayerMessage.gameId)
  return gameid_;
}
inline void AskKickPlayerMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:AskKickPlayerMessage.gameId)
}

// required uint32 playerId = 2;
inline bool AskKickPlayerMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AskKickPlayerMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 AskKickPlayerMessage::playerid() const {
  // @@protoc_insertion_point(field_get:AskKickPlayerMessage.playerId)
  return playerid_;
}
inline void AskKickPlayerMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:AskKickPlayerMessage.playerId)
}

// -------------------------------------------------------------------

// AskKickDeniedMessage

// required uint32 gameId = 1;
inline bool AskKickDeniedMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AskKickDeniedMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 AskKickDeniedMessage::gameid() const {
  // @@protoc_insertion_point(field_get:AskKickDeniedMessage.gameId)
  return gameid_;
}
inline void AskKickDeniedMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:AskKickDeniedMessage.gameId)
}

// required uint32 playerId = 2;
inline bool AskKickDeniedMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AskKickDeniedMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 AskKickDeniedMessage::playerid() const {
  // @@protoc_insertion_point(field_get:AskKickDeniedMessage.playerId)
  return playerid_;
}
inline void AskKickDeniedMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:AskKickDeniedMessage.playerId)
}

// required .AskKickDeniedMessage.KickDeniedReason kickDeniedReason = 3;
inline bool AskKickDeniedMessage::has_kickdeniedreason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AskKickDeniedMessage::clear_kickdeniedreason() {
  kickdeniedreason_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::AskKickDeniedMessage_KickDeniedReason AskKickDeniedMessage::kickdeniedreason() const {
  // @@protoc_insertion_point(field_get:AskKickDeniedMessage.kickDeniedReason)
  return static_cast< ::AskKickDeniedMessage_KickDeniedReason >(kickdeniedreason_);
}
inline void AskKickDeniedMessage::set_kickdeniedreason(::AskKickDeniedMessage_KickDeniedReason value) {
  assert(::AskKickDeniedMessage_KickDeniedReason_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  kickdeniedreason_ = value;
  // @@protoc_insertion_point(field_set:AskKickDeniedMessage.kickDeniedReason)
}

// -------------------------------------------------------------------

// StartKickPetitionMessage

// required uint32 gameId = 1;
inline bool StartKickPetitionMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartKickPetitionMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::gameid() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.gameId)
  return gameid_;
}
inline void StartKickPetitionMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.gameId)
}

// required uint32 petitionId = 2;
inline bool StartKickPetitionMessage::has_petitionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartKickPetitionMessage::clear_petitionid() {
  petitionid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::petitionid() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.petitionId)
  return petitionid_;
}
inline void StartKickPetitionMessage::set_petitionid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  petitionid_ = value;
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.petitionId)
}

// required uint32 proposingPlayerId = 3;
inline bool StartKickPetitionMessage::has_proposingplayerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartKickPetitionMessage::clear_proposingplayerid() {
  proposingplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::proposingplayerid() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.proposingPlayerId)
  return proposingplayerid_;
}
inline void StartKickPetitionMessage::set_proposingplayerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  proposingplayerid_ = value;
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.proposingPlayerId)
}

// required uint32 kickPlayerId = 4;
inline bool StartKickPetitionMessage::has_kickplayerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartKickPetitionMessage::clear_kickplayerid() {
  kickplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::kickplayerid() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.kickPlayerId)
  return kickplayerid_;
}
inline void StartKickPetitionMessage::set_kickplayerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  kickplayerid_ = value;
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.kickPlayerId)
}

// required uint32 kickTimeoutSec = 5;
inline bool StartKickPetitionMessage::has_kicktimeoutsec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StartKickPetitionMessage::clear_kicktimeoutsec() {
  kicktimeoutsec_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::kicktimeoutsec() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.kickTimeoutSec)
  return kicktimeoutsec_;
}
inline void StartKickPetitionMessage::set_kicktimeoutsec(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  kicktimeoutsec_ = value;
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.kickTimeoutSec)
}

// required uint32 numVotesNeededToKick = 6;
inline bool StartKickPetitionMessage::has_numvotesneededtokick() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StartKickPetitionMessage::clear_numvotesneededtokick() {
  numvotesneededtokick_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 StartKickPetitionMessage::numvotesneededtokick() const {
  // @@protoc_insertion_point(field_get:StartKickPetitionMessage.numVotesNeededToKick)
  return numvotesneededtokick_;
}
inline void StartKickPetitionMessage::set_numvotesneededtokick(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  numvotesneededtokick_ = value;
  // @@protoc_insertion_point(field_set:StartKickPetitionMessage.numVotesNeededToKick)
}

// -------------------------------------------------------------------

// VoteKickRequestMessage

// required uint32 gameId = 1;
inline bool VoteKickRequestMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VoteKickRequestMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 VoteKickRequestMessage::gameid() const {
  // @@protoc_insertion_point(field_get:VoteKickRequestMessage.gameId)
  return gameid_;
}
inline void VoteKickRequestMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:VoteKickRequestMessage.gameId)
}

// required uint32 petitionId = 2;
inline bool VoteKickRequestMessage::has_petitionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VoteKickRequestMessage::clear_petitionid() {
  petitionid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 VoteKickRequestMessage::petitionid() const {
  // @@protoc_insertion_point(field_get:VoteKickRequestMessage.petitionId)
  return petitionid_;
}
inline void VoteKickRequestMessage::set_petitionid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  petitionid_ = value;
  // @@protoc_insertion_point(field_set:VoteKickRequestMessage.petitionId)
}

// required bool voteKick = 3;
inline bool VoteKickRequestMessage::has_votekick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VoteKickRequestMessage::clear_votekick() {
  votekick_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool VoteKickRequestMessage::votekick() const {
  // @@protoc_insertion_point(field_get:VoteKickRequestMessage.voteKick)
  return votekick_;
}
inline void VoteKickRequestMessage::set_votekick(bool value) {
  _has_bits_[0] |= 0x00000004u;
  votekick_ = value;
  // @@protoc_insertion_point(field_set:VoteKickRequestMessage.voteKick)
}

// -------------------------------------------------------------------

// VoteKickReplyMessage

// required uint32 gameId = 1;
inline bool VoteKickReplyMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VoteKickReplyMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 VoteKickReplyMessage::gameid() const {
  // @@protoc_insertion_point(field_get:VoteKickReplyMessage.gameId)
  return gameid_;
}
inline void VoteKickReplyMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:VoteKickReplyMessage.gameId)
}

// required uint32 petitionId = 2;
inline bool VoteKickReplyMessage::has_petitionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VoteKickReplyMessage::clear_petitionid() {
  petitionid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 VoteKickReplyMessage::petitionid() const {
  // @@protoc_insertion_point(field_get:VoteKickReplyMessage.petitionId)
  return petitionid_;
}
inline void VoteKickReplyMessage::set_petitionid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  petitionid_ = value;
  // @@protoc_insertion_point(field_set:VoteKickReplyMessage.petitionId)
}

// required .VoteKickReplyMessage.VoteKickReplyType voteKickReplyType = 3;
inline bool VoteKickReplyMessage::has_votekickreplytype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VoteKickReplyMessage::clear_votekickreplytype() {
  votekickreplytype_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::VoteKickReplyMessage_VoteKickReplyType VoteKickReplyMessage::votekickreplytype() const {
  // @@protoc_insertion_point(field_get:VoteKickReplyMessage.voteKickReplyType)
  return static_cast< ::VoteKickReplyMessage_VoteKickReplyType >(votekickreplytype_);
}
inline void VoteKickReplyMessage::set_votekickreplytype(::VoteKickReplyMessage_VoteKickReplyType value) {
  assert(::VoteKickReplyMessage_VoteKickReplyType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  votekickreplytype_ = value;
  // @@protoc_insertion_point(field_set:VoteKickReplyMessage.voteKickReplyType)
}

// -------------------------------------------------------------------

// KickPetitionUpdateMessage

// required uint32 gameId = 1;
inline bool KickPetitionUpdateMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KickPetitionUpdateMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 KickPetitionUpdateMessage::gameid() const {
  // @@protoc_insertion_point(field_get:KickPetitionUpdateMessage.gameId)
  return gameid_;
}
inline void KickPetitionUpdateMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:KickPetitionUpdateMessage.gameId)
}

// required uint32 petitionId = 2;
inline bool KickPetitionUpdateMessage::has_petitionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KickPetitionUpdateMessage::clear_petitionid() {
  petitionid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 KickPetitionUpdateMessage::petitionid() const {
  // @@protoc_insertion_point(field_get:KickPetitionUpdateMessage.petitionId)
  return petitionid_;
}
inline void KickPetitionUpdateMessage::set_petitionid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  petitionid_ = value;
  // @@protoc_insertion_point(field_set:KickPetitionUpdateMessage.petitionId)
}

// required uint32 numVotesAgainstKicking = 3;
inline bool KickPetitionUpdateMessage::has_numvotesagainstkicking() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KickPetitionUpdateMessage::clear_numvotesagainstkicking() {
  numvotesagainstkicking_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 KickPetitionUpdateMessage::numvotesagainstkicking() const {
  // @@protoc_insertion_point(field_get:KickPetitionUpdateMessage.numVotesAgainstKicking)
  return numvotesagainstkicking_;
}
inline void KickPetitionUpdateMessage::set_numvotesagainstkicking(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  numvotesagainstkicking_ = value;
  // @@protoc_insertion_point(field_set:KickPetitionUpdateMessage.numVotesAgainstKicking)
}

// required uint32 numVotesInFavourOfKicking = 4;
inline bool KickPetitionUpdateMessage::has_numvotesinfavourofkicking() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KickPetitionUpdateMessage::clear_numvotesinfavourofkicking() {
  numvotesinfavourofkicking_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 KickPetitionUpdateMessage::numvotesinfavourofkicking() const {
  // @@protoc_insertion_point(field_get:KickPetitionUpdateMessage.numVotesInFavourOfKicking)
  return numvotesinfavourofkicking_;
}
inline void KickPetitionUpdateMessage::set_numvotesinfavourofkicking(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  numvotesinfavourofkicking_ = value;
  // @@protoc_insertion_point(field_set:KickPetitionUpdateMessage.numVotesInFavourOfKicking)
}

// required uint32 numVotesNeededToKick = 5;
inline bool KickPetitionUpdateMessage::has_numvotesneededtokick() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void KickPetitionUpdateMessage::clear_numvotesneededtokick() {
  numvotesneededtokick_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 KickPetitionUpdateMessage::numvotesneededtokick() const {
  // @@protoc_insertion_point(field_get:KickPetitionUpdateMessage.numVotesNeededToKick)
  return numvotesneededtokick_;
}
inline void KickPetitionUpdateMessage::set_numvotesneededtokick(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  numvotesneededtokick_ = value;
  // @@protoc_insertion_point(field_set:KickPetitionUpdateMessage.numVotesNeededToKick)
}

// -------------------------------------------------------------------

// EndKickPetitionMessage

// required uint32 gameId = 1;
inline bool EndKickPetitionMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndKickPetitionMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 EndKickPetitionMessage::gameid() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.gameId)
  return gameid_;
}
inline void EndKickPetitionMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.gameId)
}

// required uint32 petitionId = 2;
inline bool EndKickPetitionMessage::has_petitionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndKickPetitionMessage::clear_petitionid() {
  petitionid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 EndKickPetitionMessage::petitionid() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.petitionId)
  return petitionid_;
}
inline void EndKickPetitionMessage::set_petitionid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  petitionid_ = value;
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.petitionId)
}

// required uint32 numVotesAgainstKicking = 3;
inline bool EndKickPetitionMessage::has_numvotesagainstkicking() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EndKickPetitionMessage::clear_numvotesagainstkicking() {
  numvotesagainstkicking_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 EndKickPetitionMessage::numvotesagainstkicking() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.numVotesAgainstKicking)
  return numvotesagainstkicking_;
}
inline void EndKickPetitionMessage::set_numvotesagainstkicking(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  numvotesagainstkicking_ = value;
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.numVotesAgainstKicking)
}

// required uint32 numVotesInFavourOfKicking = 4;
inline bool EndKickPetitionMessage::has_numvotesinfavourofkicking() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EndKickPetitionMessage::clear_numvotesinfavourofkicking() {
  numvotesinfavourofkicking_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 EndKickPetitionMessage::numvotesinfavourofkicking() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.numVotesInFavourOfKicking)
  return numvotesinfavourofkicking_;
}
inline void EndKickPetitionMessage::set_numvotesinfavourofkicking(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  numvotesinfavourofkicking_ = value;
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.numVotesInFavourOfKicking)
}

// required uint32 resultPlayerKicked = 5;
inline bool EndKickPetitionMessage::has_resultplayerkicked() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EndKickPetitionMessage::clear_resultplayerkicked() {
  resultplayerkicked_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 EndKickPetitionMessage::resultplayerkicked() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.resultPlayerKicked)
  return resultplayerkicked_;
}
inline void EndKickPetitionMessage::set_resultplayerkicked(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  resultplayerkicked_ = value;
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.resultPlayerKicked)
}

// required .EndKickPetitionMessage.PetitionEndReason petitionEndReason = 6;
inline bool EndKickPetitionMessage::has_petitionendreason() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EndKickPetitionMessage::clear_petitionendreason() {
  petitionendreason_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::EndKickPetitionMessage_PetitionEndReason EndKickPetitionMessage::petitionendreason() const {
  // @@protoc_insertion_point(field_get:EndKickPetitionMessage.petitionEndReason)
  return static_cast< ::EndKickPetitionMessage_PetitionEndReason >(petitionendreason_);
}
inline void EndKickPetitionMessage::set_petitionendreason(::EndKickPetitionMessage_PetitionEndReason value) {
  assert(::EndKickPetitionMessage_PetitionEndReason_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  petitionendreason_ = value;
  // @@protoc_insertion_point(field_set:EndKickPetitionMessage.petitionEndReason)
}

// -------------------------------------------------------------------

// StatisticsMessage_StatisticsData

// required .StatisticsMessage.StatisticsData.StatisticsType statisticsType = 1;
inline bool StatisticsMessage_StatisticsData::has_statisticstype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatisticsMessage_StatisticsData::clear_statisticstype() {
  statisticstype_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::StatisticsMessage_StatisticsData_StatisticsType StatisticsMessage_StatisticsData::statisticstype() const {
  // @@protoc_insertion_point(field_get:StatisticsMessage.StatisticsData.statisticsType)
  return static_cast< ::StatisticsMessage_StatisticsData_StatisticsType >(statisticstype_);
}
inline void StatisticsMessage_StatisticsData::set_statisticstype(::StatisticsMessage_StatisticsData_StatisticsType value) {
  assert(::StatisticsMessage_StatisticsData_StatisticsType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  statisticstype_ = value;
  // @@protoc_insertion_point(field_set:StatisticsMessage.StatisticsData.statisticsType)
}

// required uint32 statisticsValue = 2;
inline bool StatisticsMessage_StatisticsData::has_statisticsvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatisticsMessage_StatisticsData::clear_statisticsvalue() {
  statisticsvalue_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 StatisticsMessage_StatisticsData::statisticsvalue() const {
  // @@protoc_insertion_point(field_get:StatisticsMessage.StatisticsData.statisticsValue)
  return statisticsvalue_;
}
inline void StatisticsMessage_StatisticsData::set_statisticsvalue(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  statisticsvalue_ = value;
  // @@protoc_insertion_point(field_set:StatisticsMessage.StatisticsData.statisticsValue)
}

// -------------------------------------------------------------------

// StatisticsMessage

// repeated .StatisticsMessage.StatisticsData statisticsData = 1;
inline int StatisticsMessage::statisticsdata_size() const {
  return statisticsdata_.size();
}
inline void StatisticsMessage::clear_statisticsdata() {
  statisticsdata_.Clear();
}
inline ::StatisticsMessage_StatisticsData* StatisticsMessage::mutable_statisticsdata(int index) {
  // @@protoc_insertion_point(field_mutable:StatisticsMessage.statisticsData)
  return statisticsdata_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::StatisticsMessage_StatisticsData >*
StatisticsMessage::mutable_statisticsdata() {
  // @@protoc_insertion_point(field_mutable_list:StatisticsMessage.statisticsData)
  return &statisticsdata_;
}
inline const ::StatisticsMessage_StatisticsData& StatisticsMessage::statisticsdata(int index) const {
  // @@protoc_insertion_point(field_get:StatisticsMessage.statisticsData)
  return statisticsdata_.Get(index);
}
inline ::StatisticsMessage_StatisticsData* StatisticsMessage::add_statisticsdata() {
  // @@protoc_insertion_point(field_add:StatisticsMessage.statisticsData)
  return statisticsdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::StatisticsMessage_StatisticsData >&
StatisticsMessage::statisticsdata() const {
  // @@protoc_insertion_point(field_list:StatisticsMessage.statisticsData)
  return statisticsdata_;
}

// -------------------------------------------------------------------

// ChatRequestMessage

// optional uint32 targetGameId = 1;
inline bool ChatRequestMessage::has_targetgameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatRequestMessage::clear_targetgameid() {
  targetgameid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 ChatRequestMessage::targetgameid() const {
  // @@protoc_insertion_point(field_get:ChatRequestMessage.targetGameId)
  return targetgameid_;
}
inline void ChatRequestMessage::set_targetgameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  targetgameid_ = value;
  // @@protoc_insertion_point(field_set:ChatRequestMessage.targetGameId)
}

// optional uint32 targetPlayerId = 2;
inline bool ChatRequestMessage::has_targetplayerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatRequestMessage::clear_targetplayerid() {
  targetplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 ChatRequestMessage::targetplayerid() const {
  // @@protoc_insertion_point(field_get:ChatRequestMessage.targetPlayerId)
  return targetplayerid_;
}
inline void ChatRequestMessage::set_targetplayerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  targetplayerid_ = value;
  // @@protoc_insertion_point(field_set:ChatRequestMessage.targetPlayerId)
}

// required string chatText = 3;
inline bool ChatRequestMessage::has_chattext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatRequestMessage::clear_chattext() {
  chattext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ChatRequestMessage::chattext() const {
  // @@protoc_insertion_point(field_get:ChatRequestMessage.chatText)
  return chattext_.GetNoArena();
}
inline void ChatRequestMessage::set_chattext(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  chattext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ChatRequestMessage.chatText)
}
#if LANG_CXX11
inline void ChatRequestMessage::set_chattext(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  chattext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ChatRequestMessage.chatText)
}
#endif
inline void ChatRequestMessage::set_chattext(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  chattext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ChatRequestMessage.chatText)
}
inline void ChatRequestMessage::set_chattext(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  chattext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ChatRequestMessage.chatText)
}
inline ::std::string* ChatRequestMessage::mutable_chattext() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ChatRequestMessage.chatText)
  return chattext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChatRequestMessage::release_chattext() {
  // @@protoc_insertion_point(field_release:ChatRequestMessage.chatText)
  if (!has_chattext()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return chattext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatRequestMessage::set_allocated_chattext(::std::string* chattext) {
  if (chattext != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  chattext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chattext);
  // @@protoc_insertion_point(field_set_allocated:ChatRequestMessage.chatText)
}

// -------------------------------------------------------------------

// ChatMessage

// optional uint32 gameId = 1;
inline bool ChatMessage::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatMessage::clear_gameid() {
  gameid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 ChatMessage::gameid() const {
  // @@protoc_insertion_point(field_get:ChatMessage.gameId)
  return gameid_;
}
inline void ChatMessage::set_gameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  gameid_ = value;
  // @@protoc_insertion_point(field_set:ChatMessage.gameId)
}

// optional uint32 playerId = 2;
inline bool ChatMessage::has_playerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatMessage::clear_playerid() {
  playerid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 ChatMessage::playerid() const {
  // @@protoc_insertion_point(field_get:ChatMessage.playerId)
  return playerid_;
}
inline void ChatMessage::set_playerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  playerid_ = value;
  // @@protoc_insertion_point(field_set:ChatMessage.playerId)
}

// required .ChatMessage.ChatType chatType = 3;
inline bool ChatMessage::has_chattype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChatMessage::clear_chattype() {
  chattype_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::ChatMessage_ChatType ChatMessage::chattype() const {
  // @@protoc_insertion_point(field_get:ChatMessage.chatType)
  return static_cast< ::ChatMessage_ChatType >(chattype_);
}
inline void ChatMessage::set_chattype(::ChatMessage_ChatType value) {
  assert(::ChatMessage_ChatType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  chattype_ = value;
  // @@protoc_insertion_point(field_set:ChatMessage.chatType)
}

// required string chatText = 4;
inline bool ChatMessage::has_chattext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatMessage::clear_chattext() {
  chattext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ChatMessage::chattext() const {
  // @@protoc_insertion_point(field_get:ChatMessage.chatText)
  return chattext_.GetNoArena();
}
inline void ChatMessage::set_chattext(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  chattext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ChatMessage.chatText)
}
#if LANG_CXX11
inline void ChatMessage::set_chattext(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  chattext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ChatMessage.chatText)
}
#endif
inline void ChatMessage::set_chattext(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  chattext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ChatMessage.chatText)
}
inline void ChatMessage::set_chattext(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  chattext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ChatMessage.chatText)
}
inline ::std::string* ChatMessage::mutable_chattext() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ChatMessage.chatText)
  return chattext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChatMessage::release_chattext() {
  // @@protoc_insertion_point(field_release:ChatMessage.chatText)
  if (!has_chattext()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return chattext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatMessage::set_allocated_chattext(::std::string* chattext) {
  if (chattext != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  chattext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chattext);
  // @@protoc_insertion_point(field_set_allocated:ChatMessage.chatText)
}

// -------------------------------------------------------------------

// ChatRejectMessage

// required string chatText = 1;
inline bool ChatRejectMessage::has_chattext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatRejectMessage::clear_chattext() {
  chattext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ChatRejectMessage::chattext() const {
  // @@protoc_insertion_point(field_get:ChatRejectMessage.chatText)
  return chattext_.GetNoArena();
}
inline void ChatRejectMessage::set_chattext(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  chattext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ChatRejectMessage.chatText)
}
#if LANG_CXX11
inline void ChatRejectMessage::set_chattext(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  chattext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ChatRejectMessage.chatText)
}
#endif
inline void ChatRejectMessage::set_chattext(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  chattext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ChatRejectMessage.chatText)
}
inline void ChatRejectMessage::set_chattext(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  chattext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ChatRejectMessage.chatText)
}
inline ::std::string* ChatRejectMessage::mutable_chattext() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ChatRejectMessage.chatText)
  return chattext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChatRejectMessage::release_chattext() {
  // @@protoc_insertion_point(field_release:ChatRejectMessage.chatText)
  if (!has_chattext()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return chattext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatRejectMessage::set_allocated_chattext(::std::string* chattext) {
  if (chattext != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  chattext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chattext);
  // @@protoc_insertion_point(field_set_allocated:ChatRejectMessage.chatText)
}

// -------------------------------------------------------------------

// DialogMessage

// required string notificationText = 1;
inline bool DialogMessage::has_notificationtext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DialogMessage::clear_notificationtext() {
  notificationtext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DialogMessage::notificationtext() const {
  // @@protoc_insertion_point(field_get:DialogMessage.notificationText)
  return notificationtext_.GetNoArena();
}
inline void DialogMessage::set_notificationtext(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  notificationtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DialogMessage.notificationText)
}
#if LANG_CXX11
inline void DialogMessage::set_notificationtext(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  notificationtext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DialogMessage.notificationText)
}
#endif
inline void DialogMessage::set_notificationtext(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  notificationtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DialogMessage.notificationText)
}
inline void DialogMessage::set_notificationtext(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  notificationtext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DialogMessage.notificationText)
}
inline ::std::string* DialogMessage::mutable_notificationtext() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:DialogMessage.notificationText)
  return notificationtext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DialogMessage::release_notificationtext() {
  // @@protoc_insertion_point(field_release:DialogMessage.notificationText)
  if (!has_notificationtext()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return notificationtext_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DialogMessage::set_allocated_notificationtext(::std::string* notificationtext) {
  if (notificationtext != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  notificationtext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), notificationtext);
  // @@protoc_insertion_point(field_set_allocated:DialogMessage.notificationText)
}

// -------------------------------------------------------------------

// TimeoutWarningMessage

// required .TimeoutWarningMessage.TimeoutReason timeoutReason = 1;
inline bool TimeoutWarningMessage::has_timeoutreason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeoutWarningMessage::clear_timeoutreason() {
  timeoutreason_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::TimeoutWarningMessage_TimeoutReason TimeoutWarningMessage::timeoutreason() const {
  // @@protoc_insertion_point(field_get:TimeoutWarningMessage.timeoutReason)
  return static_cast< ::TimeoutWarningMessage_TimeoutReason >(timeoutreason_);
}
inline void TimeoutWarningMessage::set_timeoutreason(::TimeoutWarningMessage_TimeoutReason value) {
  assert(::TimeoutWarningMessage_TimeoutReason_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  timeoutreason_ = value;
  // @@protoc_insertion_point(field_set:TimeoutWarningMessage.timeoutReason)
}

// required uint32 remainingSeconds = 2;
inline bool TimeoutWarningMessage::has_remainingseconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeoutWarningMessage::clear_remainingseconds() {
  remainingseconds_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 TimeoutWarningMessage::remainingseconds() const {
  // @@protoc_insertion_point(field_get:TimeoutWarningMessage.remainingSeconds)
  return remainingseconds_;
}
inline void TimeoutWarningMessage::set_remainingseconds(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  remainingseconds_ = value;
  // @@protoc_insertion_point(field_set:TimeoutWarningMessage.remainingSeconds)
}

// -------------------------------------------------------------------

// ResetTimeoutMessage

// -------------------------------------------------------------------

// ReportAvatarMessage

// required uint32 reportedPlayerId = 1;
inline bool ReportAvatarMessage::has_reportedplayerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReportAvatarMessage::clear_reportedplayerid() {
  reportedplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 ReportAvatarMessage::reportedplayerid() const {
  // @@protoc_insertion_point(field_get:ReportAvatarMessage.reportedPlayerId)
  return reportedplayerid_;
}
inline void ReportAvatarMessage::set_reportedplayerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  reportedplayerid_ = value;
  // @@protoc_insertion_point(field_set:ReportAvatarMessage.reportedPlayerId)
}

// required bytes reportedAvatarHash = 2;
inline bool ReportAvatarMessage::has_reportedavatarhash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportAvatarMessage::clear_reportedavatarhash() {
  reportedavatarhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ReportAvatarMessage::reportedavatarhash() const {
  // @@protoc_insertion_point(field_get:ReportAvatarMessage.reportedAvatarHash)
  return reportedavatarhash_.GetNoArena();
}
inline void ReportAvatarMessage::set_reportedavatarhash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reportedavatarhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ReportAvatarMessage.reportedAvatarHash)
}
#if LANG_CXX11
inline void ReportAvatarMessage::set_reportedavatarhash(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  reportedavatarhash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ReportAvatarMessage.reportedAvatarHash)
}
#endif
inline void ReportAvatarMessage::set_reportedavatarhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  reportedavatarhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ReportAvatarMessage.reportedAvatarHash)
}
inline void ReportAvatarMessage::set_reportedavatarhash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  reportedavatarhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ReportAvatarMessage.reportedAvatarHash)
}
inline ::std::string* ReportAvatarMessage::mutable_reportedavatarhash() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:ReportAvatarMessage.reportedAvatarHash)
  return reportedavatarhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReportAvatarMessage::release_reportedavatarhash() {
  // @@protoc_insertion_point(field_release:ReportAvatarMessage.reportedAvatarHash)
  if (!has_reportedavatarhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return reportedavatarhash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReportAvatarMessage::set_allocated_reportedavatarhash(::std::string* reportedavatarhash) {
  if (reportedavatarhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reportedavatarhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reportedavatarhash);
  // @@protoc_insertion_point(field_set_allocated:ReportAvatarMessage.reportedAvatarHash)
}

// -------------------------------------------------------------------

// ReportAvatarAckMessage

// required uint32 reportedPlayerId = 1;
inline bool ReportAvatarAckMessage::has_reportedplayerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportAvatarAckMessage::clear_reportedplayerid() {
  reportedplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 ReportAvatarAckMessage::reportedplayerid() const {
  // @@protoc_insertion_point(field_get:ReportAvatarAckMessage.reportedPlayerId)
  return reportedplayerid_;
}
inline void ReportAvatarAckMessage::set_reportedplayerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  reportedplayerid_ = value;
  // @@protoc_insertion_point(field_set:ReportAvatarAckMessage.reportedPlayerId)
}

// required .ReportAvatarAckMessage.ReportAvatarResult reportAvatarResult = 2;
inline bool ReportAvatarAckMessage::has_reportavatarresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReportAvatarAckMessage::clear_reportavatarresult() {
  reportavatarresult_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::ReportAvatarAckMessage_ReportAvatarResult ReportAvatarAckMessage::reportavatarresult() const {
  // @@protoc_insertion_point(field_get:ReportAvatarAckMessage.reportAvatarResult)
  return static_cast< ::ReportAvatarAckMessage_ReportAvatarResult >(reportavatarresult_);
}
inline void ReportAvatarAckMessage::set_reportavatarresult(::ReportAvatarAckMessage_ReportAvatarResult value) {
  assert(::ReportAvatarAckMessage_ReportAvatarResult_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  reportavatarresult_ = value;
  // @@protoc_insertion_point(field_set:ReportAvatarAckMessage.reportAvatarResult)
}

// -------------------------------------------------------------------

// ReportGameMessage

// required uint32 reportedGameId = 1;
inline bool ReportGameMessage::has_reportedgameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportGameMessage::clear_reportedgameid() {
  reportedgameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 ReportGameMessage::reportedgameid() const {
  // @@protoc_insertion_point(field_get:ReportGameMessage.reportedGameId)
  return reportedgameid_;
}
inline void ReportGameMessage::set_reportedgameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  reportedgameid_ = value;
  // @@protoc_insertion_point(field_set:ReportGameMessage.reportedGameId)
}

// -------------------------------------------------------------------

// ReportGameAckMessage

// required uint32 reportedGameId = 1;
inline bool ReportGameAckMessage::has_reportedgameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportGameAckMessage::clear_reportedgameid() {
  reportedgameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 ReportGameAckMessage::reportedgameid() const {
  // @@protoc_insertion_point(field_get:ReportGameAckMessage.reportedGameId)
  return reportedgameid_;
}
inline void ReportGameAckMessage::set_reportedgameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  reportedgameid_ = value;
  // @@protoc_insertion_point(field_set:ReportGameAckMessage.reportedGameId)
}

// required .ReportGameAckMessage.ReportGameResult reportGameResult = 2;
inline bool ReportGameAckMessage::has_reportgameresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReportGameAckMessage::clear_reportgameresult() {
  reportgameresult_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::ReportGameAckMessage_ReportGameResult ReportGameAckMessage::reportgameresult() const {
  // @@protoc_insertion_point(field_get:ReportGameAckMessage.reportGameResult)
  return static_cast< ::ReportGameAckMessage_ReportGameResult >(reportgameresult_);
}
inline void ReportGameAckMessage::set_reportgameresult(::ReportGameAckMessage_ReportGameResult value) {
  assert(::ReportGameAckMessage_ReportGameResult_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  reportgameresult_ = value;
  // @@protoc_insertion_point(field_set:ReportGameAckMessage.reportGameResult)
}

// -------------------------------------------------------------------

// ErrorMessage

// required .ErrorMessage.ErrorReason errorReason = 1;
inline bool ErrorMessage::has_errorreason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorMessage::clear_errorreason() {
  errorreason_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::ErrorMessage_ErrorReason ErrorMessage::errorreason() const {
  // @@protoc_insertion_point(field_get:ErrorMessage.errorReason)
  return static_cast< ::ErrorMessage_ErrorReason >(errorreason_);
}
inline void ErrorMessage::set_errorreason(::ErrorMessage_ErrorReason value) {
  assert(::ErrorMessage_ErrorReason_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  errorreason_ = value;
  // @@protoc_insertion_point(field_set:ErrorMessage.errorReason)
}

// -------------------------------------------------------------------

// AdminRemoveGameMessage

// required uint32 removeGameId = 1;
inline bool AdminRemoveGameMessage::has_removegameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminRemoveGameMessage::clear_removegameid() {
  removegameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 AdminRemoveGameMessage::removegameid() const {
  // @@protoc_insertion_point(field_get:AdminRemoveGameMessage.removeGameId)
  return removegameid_;
}
inline void AdminRemoveGameMessage::set_removegameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  removegameid_ = value;
  // @@protoc_insertion_point(field_set:AdminRemoveGameMessage.removeGameId)
}

// -------------------------------------------------------------------

// AdminRemoveGameAckMessage

// required uint32 removeGameId = 1;
inline bool AdminRemoveGameAckMessage::has_removegameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminRemoveGameAckMessage::clear_removegameid() {
  removegameid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 AdminRemoveGameAckMessage::removegameid() const {
  // @@protoc_insertion_point(field_get:AdminRemoveGameAckMessage.removeGameId)
  return removegameid_;
}
inline void AdminRemoveGameAckMessage::set_removegameid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  removegameid_ = value;
  // @@protoc_insertion_point(field_set:AdminRemoveGameAckMessage.removeGameId)
}

// required .AdminRemoveGameAckMessage.AdminRemoveGameResult removeGameResult = 2;
inline bool AdminRemoveGameAckMessage::has_removegameresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdminRemoveGameAckMessage::clear_removegameresult() {
  removegameresult_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::AdminRemoveGameAckMessage_AdminRemoveGameResult AdminRemoveGameAckMessage::removegameresult() const {
  // @@protoc_insertion_point(field_get:AdminRemoveGameAckMessage.removeGameResult)
  return static_cast< ::AdminRemoveGameAckMessage_AdminRemoveGameResult >(removegameresult_);
}
inline void AdminRemoveGameAckMessage::set_removegameresult(::AdminRemoveGameAckMessage_AdminRemoveGameResult value) {
  assert(::AdminRemoveGameAckMessage_AdminRemoveGameResult_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  removegameresult_ = value;
  // @@protoc_insertion_point(field_set:AdminRemoveGameAckMessage.removeGameResult)
}

// -------------------------------------------------------------------

// AdminBanPlayerMessage

// required uint32 banPlayerId = 1;
inline bool AdminBanPlayerMessage::has_banplayerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminBanPlayerMessage::clear_banplayerid() {
  banplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 AdminBanPlayerMessage::banplayerid() const {
  // @@protoc_insertion_point(field_get:AdminBanPlayerMessage.banPlayerId)
  return banplayerid_;
}
inline void AdminBanPlayerMessage::set_banplayerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  banplayerid_ = value;
  // @@protoc_insertion_point(field_set:AdminBanPlayerMessage.banPlayerId)
}

// -------------------------------------------------------------------

// AdminBanPlayerAckMessage

// required uint32 banPlayerId = 1;
inline bool AdminBanPlayerAckMessage::has_banplayerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminBanPlayerAckMessage::clear_banplayerid() {
  banplayerid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 AdminBanPlayerAckMessage::banplayerid() const {
  // @@protoc_insertion_point(field_get:AdminBanPlayerAckMessage.banPlayerId)
  return banplayerid_;
}
inline void AdminBanPlayerAckMessage::set_banplayerid(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  banplayerid_ = value;
  // @@protoc_insertion_point(field_set:AdminBanPlayerAckMessage.banPlayerId)
}

// required .AdminBanPlayerAckMessage.AdminBanPlayerResult banPlayerResult = 2;
inline bool AdminBanPlayerAckMessage::has_banplayerresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdminBanPlayerAckMessage::clear_banplayerresult() {
  banplayerresult_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::AdminBanPlayerAckMessage_AdminBanPlayerResult AdminBanPlayerAckMessage::banplayerresult() const {
  // @@protoc_insertion_point(field_get:AdminBanPlayerAckMessage.banPlayerResult)
  return static_cast< ::AdminBanPlayerAckMessage_AdminBanPlayerResult >(banplayerresult_);
}
inline void AdminBanPlayerAckMessage::set_banplayerresult(::AdminBanPlayerAckMessage_AdminBanPlayerResult value) {
  assert(::AdminBanPlayerAckMessage_AdminBanPlayerResult_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  banplayerresult_ = value;
  // @@protoc_insertion_point(field_set:AdminBanPlayerAckMessage.banPlayerResult)
}

// -------------------------------------------------------------------

// PokerTHMessage

// required .PokerTHMessage.PokerTHMessageType messageType = 1;
inline bool PokerTHMessage::has_messagetype() const {
  return (_has_bits_[2] & 0x00020000u) != 0;
}
inline void PokerTHMessage::clear_messagetype() {
  messagetype_ = 1;
  _has_bits_[2] &= ~0x00020000u;
}
inline ::PokerTHMessage_PokerTHMessageType PokerTHMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:PokerTHMessage.messageType)
  return static_cast< ::PokerTHMessage_PokerTHMessageType >(messagetype_);
}
inline void PokerTHMessage::set_messagetype(::PokerTHMessage_PokerTHMessageType value) {
  assert(::PokerTHMessage_PokerTHMessageType_IsValid(value));
  _has_bits_[2] |= 0x00020000u;
  messagetype_ = value;
  // @@protoc_insertion_point(field_set:PokerTHMessage.messageType)
}

// optional .AnnounceMessage announceMessage = 2;
inline bool PokerTHMessage::has_announcemessage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PokerTHMessage::clear_announcemessage() {
  if (announcemessage_ != nullptr) announcemessage_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::AnnounceMessage& PokerTHMessage::announcemessage() const {
  const ::AnnounceMessage* p = announcemessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.announceMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::AnnounceMessage*>(
      &::_AnnounceMessage_default_instance_);
}
inline ::AnnounceMessage* PokerTHMessage::release_announcemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.announceMessage)
  _has_bits_[0] &= ~0x00000001u;
  ::AnnounceMessage* temp = announcemessage_;
  announcemessage_ = nullptr;
  return temp;
}
inline ::AnnounceMessage* PokerTHMessage::mutable_announcemessage() {
  _has_bits_[0] |= 0x00000001u;
  if (announcemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AnnounceMessage>(GetArenaNoVirtual());
    announcemessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.announceMessage)
  return announcemessage_;
}
inline void PokerTHMessage::set_allocated_announcemessage(::AnnounceMessage* announcemessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete announcemessage_;
  }
  if (announcemessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      announcemessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, announcemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  announcemessage_ = announcemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.announceMessage)
}

// optional .InitMessage initMessage = 3;
inline bool PokerTHMessage::has_initmessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PokerTHMessage::clear_initmessage() {
  if (initmessage_ != nullptr) initmessage_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::InitMessage& PokerTHMessage::initmessage() const {
  const ::InitMessage* p = initmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.initMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::InitMessage*>(
      &::_InitMessage_default_instance_);
}
inline ::InitMessage* PokerTHMessage::release_initmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.initMessage)
  _has_bits_[0] &= ~0x00000002u;
  ::InitMessage* temp = initmessage_;
  initmessage_ = nullptr;
  return temp;
}
inline ::InitMessage* PokerTHMessage::mutable_initmessage() {
  _has_bits_[0] |= 0x00000002u;
  if (initmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::InitMessage>(GetArenaNoVirtual());
    initmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.initMessage)
  return initmessage_;
}
inline void PokerTHMessage::set_allocated_initmessage(::InitMessage* initmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete initmessage_;
  }
  if (initmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      initmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, initmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  initmessage_ = initmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.initMessage)
}

// optional .AuthServerChallengeMessage authServerChallengeMessage = 4;
inline bool PokerTHMessage::has_authserverchallengemessage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PokerTHMessage::clear_authserverchallengemessage() {
  if (authserverchallengemessage_ != nullptr) authserverchallengemessage_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::AuthServerChallengeMessage& PokerTHMessage::authserverchallengemessage() const {
  const ::AuthServerChallengeMessage* p = authserverchallengemessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.authServerChallengeMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::AuthServerChallengeMessage*>(
      &::_AuthServerChallengeMessage_default_instance_);
}
inline ::AuthServerChallengeMessage* PokerTHMessage::release_authserverchallengemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.authServerChallengeMessage)
  _has_bits_[0] &= ~0x00000004u;
  ::AuthServerChallengeMessage* temp = authserverchallengemessage_;
  authserverchallengemessage_ = nullptr;
  return temp;
}
inline ::AuthServerChallengeMessage* PokerTHMessage::mutable_authserverchallengemessage() {
  _has_bits_[0] |= 0x00000004u;
  if (authserverchallengemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AuthServerChallengeMessage>(GetArenaNoVirtual());
    authserverchallengemessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.authServerChallengeMessage)
  return authserverchallengemessage_;
}
inline void PokerTHMessage::set_allocated_authserverchallengemessage(::AuthServerChallengeMessage* authserverchallengemessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete authserverchallengemessage_;
  }
  if (authserverchallengemessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      authserverchallengemessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authserverchallengemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  authserverchallengemessage_ = authserverchallengemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.authServerChallengeMessage)
}

// optional .AuthClientResponseMessage authClientResponseMessage = 5;
inline bool PokerTHMessage::has_authclientresponsemessage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PokerTHMessage::clear_authclientresponsemessage() {
  if (authclientresponsemessage_ != nullptr) authclientresponsemessage_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::AuthClientResponseMessage& PokerTHMessage::authclientresponsemessage() const {
  const ::AuthClientResponseMessage* p = authclientresponsemessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.authClientResponseMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::AuthClientResponseMessage*>(
      &::_AuthClientResponseMessage_default_instance_);
}
inline ::AuthClientResponseMessage* PokerTHMessage::release_authclientresponsemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.authClientResponseMessage)
  _has_bits_[0] &= ~0x00000008u;
  ::AuthClientResponseMessage* temp = authclientresponsemessage_;
  authclientresponsemessage_ = nullptr;
  return temp;
}
inline ::AuthClientResponseMessage* PokerTHMessage::mutable_authclientresponsemessage() {
  _has_bits_[0] |= 0x00000008u;
  if (authclientresponsemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AuthClientResponseMessage>(GetArenaNoVirtual());
    authclientresponsemessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.authClientResponseMessage)
  return authclientresponsemessage_;
}
inline void PokerTHMessage::set_allocated_authclientresponsemessage(::AuthClientResponseMessage* authclientresponsemessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete authclientresponsemessage_;
  }
  if (authclientresponsemessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      authclientresponsemessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authclientresponsemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  authclientresponsemessage_ = authclientresponsemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.authClientResponseMessage)
}

// optional .AuthServerVerificationMessage authServerVerificationMessage = 6;
inline bool PokerTHMessage::has_authserververificationmessage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PokerTHMessage::clear_authserververificationmessage() {
  if (authserververificationmessage_ != nullptr) authserververificationmessage_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::AuthServerVerificationMessage& PokerTHMessage::authserververificationmessage() const {
  const ::AuthServerVerificationMessage* p = authserververificationmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.authServerVerificationMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::AuthServerVerificationMessage*>(
      &::_AuthServerVerificationMessage_default_instance_);
}
inline ::AuthServerVerificationMessage* PokerTHMessage::release_authserververificationmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.authServerVerificationMessage)
  _has_bits_[0] &= ~0x00000010u;
  ::AuthServerVerificationMessage* temp = authserververificationmessage_;
  authserververificationmessage_ = nullptr;
  return temp;
}
inline ::AuthServerVerificationMessage* PokerTHMessage::mutable_authserververificationmessage() {
  _has_bits_[0] |= 0x00000010u;
  if (authserververificationmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AuthServerVerificationMessage>(GetArenaNoVirtual());
    authserververificationmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.authServerVerificationMessage)
  return authserververificationmessage_;
}
inline void PokerTHMessage::set_allocated_authserververificationmessage(::AuthServerVerificationMessage* authserververificationmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete authserververificationmessage_;
  }
  if (authserververificationmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      authserververificationmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authserververificationmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  authserververificationmessage_ = authserververificationmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.authServerVerificationMessage)
}

// optional .InitAckMessage initAckMessage = 7;
inline bool PokerTHMessage::has_initackmessage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PokerTHMessage::clear_initackmessage() {
  if (initackmessage_ != nullptr) initackmessage_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::InitAckMessage& PokerTHMessage::initackmessage() const {
  const ::InitAckMessage* p = initackmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.initAckMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::InitAckMessage*>(
      &::_InitAckMessage_default_instance_);
}
inline ::InitAckMessage* PokerTHMessage::release_initackmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.initAckMessage)
  _has_bits_[0] &= ~0x00000020u;
  ::InitAckMessage* temp = initackmessage_;
  initackmessage_ = nullptr;
  return temp;
}
inline ::InitAckMessage* PokerTHMessage::mutable_initackmessage() {
  _has_bits_[0] |= 0x00000020u;
  if (initackmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::InitAckMessage>(GetArenaNoVirtual());
    initackmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.initAckMessage)
  return initackmessage_;
}
inline void PokerTHMessage::set_allocated_initackmessage(::InitAckMessage* initackmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete initackmessage_;
  }
  if (initackmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      initackmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, initackmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  initackmessage_ = initackmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.initAckMessage)
}

// optional .AvatarRequestMessage avatarRequestMessage = 8;
inline bool PokerTHMessage::has_avatarrequestmessage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PokerTHMessage::clear_avatarrequestmessage() {
  if (avatarrequestmessage_ != nullptr) avatarrequestmessage_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::AvatarRequestMessage& PokerTHMessage::avatarrequestmessage() const {
  const ::AvatarRequestMessage* p = avatarrequestmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.avatarRequestMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::AvatarRequestMessage*>(
      &::_AvatarRequestMessage_default_instance_);
}
inline ::AvatarRequestMessage* PokerTHMessage::release_avatarrequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.avatarRequestMessage)
  _has_bits_[0] &= ~0x00000040u;
  ::AvatarRequestMessage* temp = avatarrequestmessage_;
  avatarrequestmessage_ = nullptr;
  return temp;
}
inline ::AvatarRequestMessage* PokerTHMessage::mutable_avatarrequestmessage() {
  _has_bits_[0] |= 0x00000040u;
  if (avatarrequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AvatarRequestMessage>(GetArenaNoVirtual());
    avatarrequestmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.avatarRequestMessage)
  return avatarrequestmessage_;
}
inline void PokerTHMessage::set_allocated_avatarrequestmessage(::AvatarRequestMessage* avatarrequestmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete avatarrequestmessage_;
  }
  if (avatarrequestmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      avatarrequestmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, avatarrequestmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  avatarrequestmessage_ = avatarrequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.avatarRequestMessage)
}

// optional .AvatarHeaderMessage avatarHeaderMessage = 9;
inline bool PokerTHMessage::has_avatarheadermessage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PokerTHMessage::clear_avatarheadermessage() {
  if (avatarheadermessage_ != nullptr) avatarheadermessage_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::AvatarHeaderMessage& PokerTHMessage::avatarheadermessage() const {
  const ::AvatarHeaderMessage* p = avatarheadermessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.avatarHeaderMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::AvatarHeaderMessage*>(
      &::_AvatarHeaderMessage_default_instance_);
}
inline ::AvatarHeaderMessage* PokerTHMessage::release_avatarheadermessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.avatarHeaderMessage)
  _has_bits_[0] &= ~0x00000080u;
  ::AvatarHeaderMessage* temp = avatarheadermessage_;
  avatarheadermessage_ = nullptr;
  return temp;
}
inline ::AvatarHeaderMessage* PokerTHMessage::mutable_avatarheadermessage() {
  _has_bits_[0] |= 0x00000080u;
  if (avatarheadermessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AvatarHeaderMessage>(GetArenaNoVirtual());
    avatarheadermessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.avatarHeaderMessage)
  return avatarheadermessage_;
}
inline void PokerTHMessage::set_allocated_avatarheadermessage(::AvatarHeaderMessage* avatarheadermessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete avatarheadermessage_;
  }
  if (avatarheadermessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      avatarheadermessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, avatarheadermessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  avatarheadermessage_ = avatarheadermessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.avatarHeaderMessage)
}

// optional .AvatarDataMessage avatarDataMessage = 10;
inline bool PokerTHMessage::has_avatardatamessage() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PokerTHMessage::clear_avatardatamessage() {
  if (avatardatamessage_ != nullptr) avatardatamessage_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::AvatarDataMessage& PokerTHMessage::avatardatamessage() const {
  const ::AvatarDataMessage* p = avatardatamessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.avatarDataMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::AvatarDataMessage*>(
      &::_AvatarDataMessage_default_instance_);
}
inline ::AvatarDataMessage* PokerTHMessage::release_avatardatamessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.avatarDataMessage)
  _has_bits_[0] &= ~0x00000100u;
  ::AvatarDataMessage* temp = avatardatamessage_;
  avatardatamessage_ = nullptr;
  return temp;
}
inline ::AvatarDataMessage* PokerTHMessage::mutable_avatardatamessage() {
  _has_bits_[0] |= 0x00000100u;
  if (avatardatamessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AvatarDataMessage>(GetArenaNoVirtual());
    avatardatamessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.avatarDataMessage)
  return avatardatamessage_;
}
inline void PokerTHMessage::set_allocated_avatardatamessage(::AvatarDataMessage* avatardatamessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete avatardatamessage_;
  }
  if (avatardatamessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      avatardatamessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, avatardatamessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  avatardatamessage_ = avatardatamessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.avatarDataMessage)
}

// optional .AvatarEndMessage avatarEndMessage = 11;
inline bool PokerTHMessage::has_avatarendmessage() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PokerTHMessage::clear_avatarendmessage() {
  if (avatarendmessage_ != nullptr) avatarendmessage_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::AvatarEndMessage& PokerTHMessage::avatarendmessage() const {
  const ::AvatarEndMessage* p = avatarendmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.avatarEndMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::AvatarEndMessage*>(
      &::_AvatarEndMessage_default_instance_);
}
inline ::AvatarEndMessage* PokerTHMessage::release_avatarendmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.avatarEndMessage)
  _has_bits_[0] &= ~0x00000200u;
  ::AvatarEndMessage* temp = avatarendmessage_;
  avatarendmessage_ = nullptr;
  return temp;
}
inline ::AvatarEndMessage* PokerTHMessage::mutable_avatarendmessage() {
  _has_bits_[0] |= 0x00000200u;
  if (avatarendmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AvatarEndMessage>(GetArenaNoVirtual());
    avatarendmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.avatarEndMessage)
  return avatarendmessage_;
}
inline void PokerTHMessage::set_allocated_avatarendmessage(::AvatarEndMessage* avatarendmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete avatarendmessage_;
  }
  if (avatarendmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      avatarendmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, avatarendmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  avatarendmessage_ = avatarendmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.avatarEndMessage)
}

// optional .UnknownAvatarMessage unknownAvatarMessage = 12;
inline bool PokerTHMessage::has_unknownavatarmessage() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PokerTHMessage::clear_unknownavatarmessage() {
  if (unknownavatarmessage_ != nullptr) unknownavatarmessage_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::UnknownAvatarMessage& PokerTHMessage::unknownavatarmessage() const {
  const ::UnknownAvatarMessage* p = unknownavatarmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.unknownAvatarMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::UnknownAvatarMessage*>(
      &::_UnknownAvatarMessage_default_instance_);
}
inline ::UnknownAvatarMessage* PokerTHMessage::release_unknownavatarmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.unknownAvatarMessage)
  _has_bits_[0] &= ~0x00000400u;
  ::UnknownAvatarMessage* temp = unknownavatarmessage_;
  unknownavatarmessage_ = nullptr;
  return temp;
}
inline ::UnknownAvatarMessage* PokerTHMessage::mutable_unknownavatarmessage() {
  _has_bits_[0] |= 0x00000400u;
  if (unknownavatarmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::UnknownAvatarMessage>(GetArenaNoVirtual());
    unknownavatarmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.unknownAvatarMessage)
  return unknownavatarmessage_;
}
inline void PokerTHMessage::set_allocated_unknownavatarmessage(::UnknownAvatarMessage* unknownavatarmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete unknownavatarmessage_;
  }
  if (unknownavatarmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      unknownavatarmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unknownavatarmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  unknownavatarmessage_ = unknownavatarmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.unknownAvatarMessage)
}

// optional .PlayerListMessage playerListMessage = 13;
inline bool PokerTHMessage::has_playerlistmessage() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PokerTHMessage::clear_playerlistmessage() {
  if (playerlistmessage_ != nullptr) playerlistmessage_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::PlayerListMessage& PokerTHMessage::playerlistmessage() const {
  const ::PlayerListMessage* p = playerlistmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.playerListMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::PlayerListMessage*>(
      &::_PlayerListMessage_default_instance_);
}
inline ::PlayerListMessage* PokerTHMessage::release_playerlistmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.playerListMessage)
  _has_bits_[0] &= ~0x00000800u;
  ::PlayerListMessage* temp = playerlistmessage_;
  playerlistmessage_ = nullptr;
  return temp;
}
inline ::PlayerListMessage* PokerTHMessage::mutable_playerlistmessage() {
  _has_bits_[0] |= 0x00000800u;
  if (playerlistmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerListMessage>(GetArenaNoVirtual());
    playerlistmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playerListMessage)
  return playerlistmessage_;
}
inline void PokerTHMessage::set_allocated_playerlistmessage(::PlayerListMessage* playerlistmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete playerlistmessage_;
  }
  if (playerlistmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      playerlistmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, playerlistmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  playerlistmessage_ = playerlistmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playerListMessage)
}

// optional .GameListNewMessage gameListNewMessage = 14;
inline bool PokerTHMessage::has_gamelistnewmessage() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PokerTHMessage::clear_gamelistnewmessage() {
  if (gamelistnewmessage_ != nullptr) gamelistnewmessage_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::GameListNewMessage& PokerTHMessage::gamelistnewmessage() const {
  const ::GameListNewMessage* p = gamelistnewmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListNewMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::GameListNewMessage*>(
      &::_GameListNewMessage_default_instance_);
}
inline ::GameListNewMessage* PokerTHMessage::release_gamelistnewmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameListNewMessage)
  _has_bits_[0] &= ~0x00001000u;
  ::GameListNewMessage* temp = gamelistnewmessage_;
  gamelistnewmessage_ = nullptr;
  return temp;
}
inline ::GameListNewMessage* PokerTHMessage::mutable_gamelistnewmessage() {
  _has_bits_[0] |= 0x00001000u;
  if (gamelistnewmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameListNewMessage>(GetArenaNoVirtual());
    gamelistnewmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListNewMessage)
  return gamelistnewmessage_;
}
inline void PokerTHMessage::set_allocated_gamelistnewmessage(::GameListNewMessage* gamelistnewmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gamelistnewmessage_;
  }
  if (gamelistnewmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gamelistnewmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gamelistnewmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  gamelistnewmessage_ = gamelistnewmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListNewMessage)
}

// optional .GameListUpdateMessage gameListUpdateMessage = 15;
inline bool PokerTHMessage::has_gamelistupdatemessage() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PokerTHMessage::clear_gamelistupdatemessage() {
  if (gamelistupdatemessage_ != nullptr) gamelistupdatemessage_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::GameListUpdateMessage& PokerTHMessage::gamelistupdatemessage() const {
  const ::GameListUpdateMessage* p = gamelistupdatemessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListUpdateMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::GameListUpdateMessage*>(
      &::_GameListUpdateMessage_default_instance_);
}
inline ::GameListUpdateMessage* PokerTHMessage::release_gamelistupdatemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameListUpdateMessage)
  _has_bits_[0] &= ~0x00002000u;
  ::GameListUpdateMessage* temp = gamelistupdatemessage_;
  gamelistupdatemessage_ = nullptr;
  return temp;
}
inline ::GameListUpdateMessage* PokerTHMessage::mutable_gamelistupdatemessage() {
  _has_bits_[0] |= 0x00002000u;
  if (gamelistupdatemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameListUpdateMessage>(GetArenaNoVirtual());
    gamelistupdatemessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListUpdateMessage)
  return gamelistupdatemessage_;
}
inline void PokerTHMessage::set_allocated_gamelistupdatemessage(::GameListUpdateMessage* gamelistupdatemessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gamelistupdatemessage_;
  }
  if (gamelistupdatemessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gamelistupdatemessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gamelistupdatemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  gamelistupdatemessage_ = gamelistupdatemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListUpdateMessage)
}

// optional .GameListPlayerJoinedMessage gameListPlayerJoinedMessage = 16;
inline bool PokerTHMessage::has_gamelistplayerjoinedmessage() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PokerTHMessage::clear_gamelistplayerjoinedmessage() {
  if (gamelistplayerjoinedmessage_ != nullptr) gamelistplayerjoinedmessage_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::GameListPlayerJoinedMessage& PokerTHMessage::gamelistplayerjoinedmessage() const {
  const ::GameListPlayerJoinedMessage* p = gamelistplayerjoinedmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListPlayerJoinedMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::GameListPlayerJoinedMessage*>(
      &::_GameListPlayerJoinedMessage_default_instance_);
}
inline ::GameListPlayerJoinedMessage* PokerTHMessage::release_gamelistplayerjoinedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameListPlayerJoinedMessage)
  _has_bits_[0] &= ~0x00004000u;
  ::GameListPlayerJoinedMessage* temp = gamelistplayerjoinedmessage_;
  gamelistplayerjoinedmessage_ = nullptr;
  return temp;
}
inline ::GameListPlayerJoinedMessage* PokerTHMessage::mutable_gamelistplayerjoinedmessage() {
  _has_bits_[0] |= 0x00004000u;
  if (gamelistplayerjoinedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameListPlayerJoinedMessage>(GetArenaNoVirtual());
    gamelistplayerjoinedmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListPlayerJoinedMessage)
  return gamelistplayerjoinedmessage_;
}
inline void PokerTHMessage::set_allocated_gamelistplayerjoinedmessage(::GameListPlayerJoinedMessage* gamelistplayerjoinedmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gamelistplayerjoinedmessage_;
  }
  if (gamelistplayerjoinedmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gamelistplayerjoinedmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gamelistplayerjoinedmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  gamelistplayerjoinedmessage_ = gamelistplayerjoinedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListPlayerJoinedMessage)
}

// optional .GameListPlayerLeftMessage gameListPlayerLeftMessage = 17;
inline bool PokerTHMessage::has_gamelistplayerleftmessage() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PokerTHMessage::clear_gamelistplayerleftmessage() {
  if (gamelistplayerleftmessage_ != nullptr) gamelistplayerleftmessage_->Clear();
  _has_bits_[0] &= ~0x00008000u;
}
inline const ::GameListPlayerLeftMessage& PokerTHMessage::gamelistplayerleftmessage() const {
  const ::GameListPlayerLeftMessage* p = gamelistplayerleftmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListPlayerLeftMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::GameListPlayerLeftMessage*>(
      &::_GameListPlayerLeftMessage_default_instance_);
}
inline ::GameListPlayerLeftMessage* PokerTHMessage::release_gamelistplayerleftmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameListPlayerLeftMessage)
  _has_bits_[0] &= ~0x00008000u;
  ::GameListPlayerLeftMessage* temp = gamelistplayerleftmessage_;
  gamelistplayerleftmessage_ = nullptr;
  return temp;
}
inline ::GameListPlayerLeftMessage* PokerTHMessage::mutable_gamelistplayerleftmessage() {
  _has_bits_[0] |= 0x00008000u;
  if (gamelistplayerleftmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameListPlayerLeftMessage>(GetArenaNoVirtual());
    gamelistplayerleftmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListPlayerLeftMessage)
  return gamelistplayerleftmessage_;
}
inline void PokerTHMessage::set_allocated_gamelistplayerleftmessage(::GameListPlayerLeftMessage* gamelistplayerleftmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gamelistplayerleftmessage_;
  }
  if (gamelistplayerleftmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gamelistplayerleftmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gamelistplayerleftmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  gamelistplayerleftmessage_ = gamelistplayerleftmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListPlayerLeftMessage)
}

// optional .GameListAdminChangedMessage gameListAdminChangedMessage = 18;
inline bool PokerTHMessage::has_gamelistadminchangedmessage() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PokerTHMessage::clear_gamelistadminchangedmessage() {
  if (gamelistadminchangedmessage_ != nullptr) gamelistadminchangedmessage_->Clear();
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::GameListAdminChangedMessage& PokerTHMessage::gamelistadminchangedmessage() const {
  const ::GameListAdminChangedMessage* p = gamelistadminchangedmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListAdminChangedMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::GameListAdminChangedMessage*>(
      &::_GameListAdminChangedMessage_default_instance_);
}
inline ::GameListAdminChangedMessage* PokerTHMessage::release_gamelistadminchangedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameListAdminChangedMessage)
  _has_bits_[0] &= ~0x00010000u;
  ::GameListAdminChangedMessage* temp = gamelistadminchangedmessage_;
  gamelistadminchangedmessage_ = nullptr;
  return temp;
}
inline ::GameListAdminChangedMessage* PokerTHMessage::mutable_gamelistadminchangedmessage() {
  _has_bits_[0] |= 0x00010000u;
  if (gamelistadminchangedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameListAdminChangedMessage>(GetArenaNoVirtual());
    gamelistadminchangedmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListAdminChangedMessage)
  return gamelistadminchangedmessage_;
}
inline void PokerTHMessage::set_allocated_gamelistadminchangedmessage(::GameListAdminChangedMessage* gamelistadminchangedmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gamelistadminchangedmessage_;
  }
  if (gamelistadminchangedmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gamelistadminchangedmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gamelistadminchangedmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  gamelistadminchangedmessage_ = gamelistadminchangedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListAdminChangedMessage)
}

// optional .PlayerInfoRequestMessage playerInfoRequestMessage = 19;
inline bool PokerTHMessage::has_playerinforequestmessage() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PokerTHMessage::clear_playerinforequestmessage() {
  if (playerinforequestmessage_ != nullptr) playerinforequestmessage_->Clear();
  _has_bits_[0] &= ~0x00020000u;
}
inline const ::PlayerInfoRequestMessage& PokerTHMessage::playerinforequestmessage() const {
  const ::PlayerInfoRequestMessage* p = playerinforequestmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.playerInfoRequestMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::PlayerInfoRequestMessage*>(
      &::_PlayerInfoRequestMessage_default_instance_);
}
inline ::PlayerInfoRequestMessage* PokerTHMessage::release_playerinforequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.playerInfoRequestMessage)
  _has_bits_[0] &= ~0x00020000u;
  ::PlayerInfoRequestMessage* temp = playerinforequestmessage_;
  playerinforequestmessage_ = nullptr;
  return temp;
}
inline ::PlayerInfoRequestMessage* PokerTHMessage::mutable_playerinforequestmessage() {
  _has_bits_[0] |= 0x00020000u;
  if (playerinforequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerInfoRequestMessage>(GetArenaNoVirtual());
    playerinforequestmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playerInfoRequestMessage)
  return playerinforequestmessage_;
}
inline void PokerTHMessage::set_allocated_playerinforequestmessage(::PlayerInfoRequestMessage* playerinforequestmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete playerinforequestmessage_;
  }
  if (playerinforequestmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      playerinforequestmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, playerinforequestmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  playerinforequestmessage_ = playerinforequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playerInfoRequestMessage)
}

// optional .PlayerInfoReplyMessage playerInfoReplyMessage = 20;
inline bool PokerTHMessage::has_playerinforeplymessage() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PokerTHMessage::clear_playerinforeplymessage() {
  if (playerinforeplymessage_ != nullptr) playerinforeplymessage_->Clear();
  _has_bits_[0] &= ~0x00040000u;
}
inline const ::PlayerInfoReplyMessage& PokerTHMessage::playerinforeplymessage() const {
  const ::PlayerInfoReplyMessage* p = playerinforeplymessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.playerInfoReplyMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::PlayerInfoReplyMessage*>(
      &::_PlayerInfoReplyMessage_default_instance_);
}
inline ::PlayerInfoReplyMessage* PokerTHMessage::release_playerinforeplymessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.playerInfoReplyMessage)
  _has_bits_[0] &= ~0x00040000u;
  ::PlayerInfoReplyMessage* temp = playerinforeplymessage_;
  playerinforeplymessage_ = nullptr;
  return temp;
}
inline ::PlayerInfoReplyMessage* PokerTHMessage::mutable_playerinforeplymessage() {
  _has_bits_[0] |= 0x00040000u;
  if (playerinforeplymessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerInfoReplyMessage>(GetArenaNoVirtual());
    playerinforeplymessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playerInfoReplyMessage)
  return playerinforeplymessage_;
}
inline void PokerTHMessage::set_allocated_playerinforeplymessage(::PlayerInfoReplyMessage* playerinforeplymessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete playerinforeplymessage_;
  }
  if (playerinforeplymessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      playerinforeplymessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, playerinforeplymessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  playerinforeplymessage_ = playerinforeplymessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playerInfoReplyMessage)
}

// optional .SubscriptionRequestMessage subscriptionRequestMessage = 21;
inline bool PokerTHMessage::has_subscriptionrequestmessage() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PokerTHMessage::clear_subscriptionrequestmessage() {
  if (subscriptionrequestmessage_ != nullptr) subscriptionrequestmessage_->Clear();
  _has_bits_[0] &= ~0x00080000u;
}
inline const ::SubscriptionRequestMessage& PokerTHMessage::subscriptionrequestmessage() const {
  const ::SubscriptionRequestMessage* p = subscriptionrequestmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.subscriptionRequestMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::SubscriptionRequestMessage*>(
      &::_SubscriptionRequestMessage_default_instance_);
}
inline ::SubscriptionRequestMessage* PokerTHMessage::release_subscriptionrequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.subscriptionRequestMessage)
  _has_bits_[0] &= ~0x00080000u;
  ::SubscriptionRequestMessage* temp = subscriptionrequestmessage_;
  subscriptionrequestmessage_ = nullptr;
  return temp;
}
inline ::SubscriptionRequestMessage* PokerTHMessage::mutable_subscriptionrequestmessage() {
  _has_bits_[0] |= 0x00080000u;
  if (subscriptionrequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::SubscriptionRequestMessage>(GetArenaNoVirtual());
    subscriptionrequestmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.subscriptionRequestMessage)
  return subscriptionrequestmessage_;
}
inline void PokerTHMessage::set_allocated_subscriptionrequestmessage(::SubscriptionRequestMessage* subscriptionrequestmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete subscriptionrequestmessage_;
  }
  if (subscriptionrequestmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      subscriptionrequestmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, subscriptionrequestmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  subscriptionrequestmessage_ = subscriptionrequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.subscriptionRequestMessage)
}

// optional .JoinExistingGameMessage joinExistingGameMessage = 22;
inline bool PokerTHMessage::has_joinexistinggamemessage() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PokerTHMessage::clear_joinexistinggamemessage() {
  if (joinexistinggamemessage_ != nullptr) joinexistinggamemessage_->Clear();
  _has_bits_[0] &= ~0x00100000u;
}
inline const ::JoinExistingGameMessage& PokerTHMessage::joinexistinggamemessage() const {
  const ::JoinExistingGameMessage* p = joinexistinggamemessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.joinExistingGameMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::JoinExistingGameMessage*>(
      &::_JoinExistingGameMessage_default_instance_);
}
inline ::JoinExistingGameMessage* PokerTHMessage::release_joinexistinggamemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.joinExistingGameMessage)
  _has_bits_[0] &= ~0x00100000u;
  ::JoinExistingGameMessage* temp = joinexistinggamemessage_;
  joinexistinggamemessage_ = nullptr;
  return temp;
}
inline ::JoinExistingGameMessage* PokerTHMessage::mutable_joinexistinggamemessage() {
  _has_bits_[0] |= 0x00100000u;
  if (joinexistinggamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::JoinExistingGameMessage>(GetArenaNoVirtual());
    joinexistinggamemessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.joinExistingGameMessage)
  return joinexistinggamemessage_;
}
inline void PokerTHMessage::set_allocated_joinexistinggamemessage(::JoinExistingGameMessage* joinexistinggamemessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete joinexistinggamemessage_;
  }
  if (joinexistinggamemessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      joinexistinggamemessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, joinexistinggamemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  joinexistinggamemessage_ = joinexistinggamemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.joinExistingGameMessage)
}

// optional .JoinNewGameMessage joinNewGameMessage = 23;
inline bool PokerTHMessage::has_joinnewgamemessage() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PokerTHMessage::clear_joinnewgamemessage() {
  if (joinnewgamemessage_ != nullptr) joinnewgamemessage_->Clear();
  _has_bits_[0] &= ~0x00200000u;
}
inline const ::JoinNewGameMessage& PokerTHMessage::joinnewgamemessage() const {
  const ::JoinNewGameMessage* p = joinnewgamemessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.joinNewGameMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::JoinNewGameMessage*>(
      &::_JoinNewGameMessage_default_instance_);
}
inline ::JoinNewGameMessage* PokerTHMessage::release_joinnewgamemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.joinNewGameMessage)
  _has_bits_[0] &= ~0x00200000u;
  ::JoinNewGameMessage* temp = joinnewgamemessage_;
  joinnewgamemessage_ = nullptr;
  return temp;
}
inline ::JoinNewGameMessage* PokerTHMessage::mutable_joinnewgamemessage() {
  _has_bits_[0] |= 0x00200000u;
  if (joinnewgamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::JoinNewGameMessage>(GetArenaNoVirtual());
    joinnewgamemessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.joinNewGameMessage)
  return joinnewgamemessage_;
}
inline void PokerTHMessage::set_allocated_joinnewgamemessage(::JoinNewGameMessage* joinnewgamemessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete joinnewgamemessage_;
  }
  if (joinnewgamemessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      joinnewgamemessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, joinnewgamemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  joinnewgamemessage_ = joinnewgamemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.joinNewGameMessage)
}

// optional .RejoinExistingGameMessage rejoinExistingGameMessage = 24;
inline bool PokerTHMessage::has_rejoinexistinggamemessage() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PokerTHMessage::clear_rejoinexistinggamemessage() {
  if (rejoinexistinggamemessage_ != nullptr) rejoinexistinggamemessage_->Clear();
  _has_bits_[0] &= ~0x00400000u;
}
inline const ::RejoinExistingGameMessage& PokerTHMessage::rejoinexistinggamemessage() const {
  const ::RejoinExistingGameMessage* p = rejoinexistinggamemessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.rejoinExistingGameMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::RejoinExistingGameMessage*>(
      &::_RejoinExistingGameMessage_default_instance_);
}
inline ::RejoinExistingGameMessage* PokerTHMessage::release_rejoinexistinggamemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.rejoinExistingGameMessage)
  _has_bits_[0] &= ~0x00400000u;
  ::RejoinExistingGameMessage* temp = rejoinexistinggamemessage_;
  rejoinexistinggamemessage_ = nullptr;
  return temp;
}
inline ::RejoinExistingGameMessage* PokerTHMessage::mutable_rejoinexistinggamemessage() {
  _has_bits_[0] |= 0x00400000u;
  if (rejoinexistinggamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::RejoinExistingGameMessage>(GetArenaNoVirtual());
    rejoinexistinggamemessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.rejoinExistingGameMessage)
  return rejoinexistinggamemessage_;
}
inline void PokerTHMessage::set_allocated_rejoinexistinggamemessage(::RejoinExistingGameMessage* rejoinexistinggamemessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rejoinexistinggamemessage_;
  }
  if (rejoinexistinggamemessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rejoinexistinggamemessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rejoinexistinggamemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00400000u;
  } else {
    _has_bits_[0] &= ~0x00400000u;
  }
  rejoinexistinggamemessage_ = rejoinexistinggamemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.rejoinExistingGameMessage)
}

// optional .JoinGameAckMessage joinGameAckMessage = 25;
inline bool PokerTHMessage::has_joingameackmessage() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PokerTHMessage::clear_joingameackmessage() {
  if (joingameackmessage_ != nullptr) joingameackmessage_->Clear();
  _has_bits_[0] &= ~0x00800000u;
}
inline const ::JoinGameAckMessage& PokerTHMessage::joingameackmessage() const {
  const ::JoinGameAckMessage* p = joingameackmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.joinGameAckMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::JoinGameAckMessage*>(
      &::_JoinGameAckMessage_default_instance_);
}
inline ::JoinGameAckMessage* PokerTHMessage::release_joingameackmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.joinGameAckMessage)
  _has_bits_[0] &= ~0x00800000u;
  ::JoinGameAckMessage* temp = joingameackmessage_;
  joingameackmessage_ = nullptr;
  return temp;
}
inline ::JoinGameAckMessage* PokerTHMessage::mutable_joingameackmessage() {
  _has_bits_[0] |= 0x00800000u;
  if (joingameackmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::JoinGameAckMessage>(GetArenaNoVirtual());
    joingameackmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.joinGameAckMessage)
  return joingameackmessage_;
}
inline void PokerTHMessage::set_allocated_joingameackmessage(::JoinGameAckMessage* joingameackmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete joingameackmessage_;
  }
  if (joingameackmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      joingameackmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, joingameackmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00800000u;
  } else {
    _has_bits_[0] &= ~0x00800000u;
  }
  joingameackmessage_ = joingameackmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.joinGameAckMessage)
}

// optional .JoinGameFailedMessage joinGameFailedMessage = 26;
inline bool PokerTHMessage::has_joingamefailedmessage() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PokerTHMessage::clear_joingamefailedmessage() {
  if (joingamefailedmessage_ != nullptr) joingamefailedmessage_->Clear();
  _has_bits_[0] &= ~0x01000000u;
}
inline const ::JoinGameFailedMessage& PokerTHMessage::joingamefailedmessage() const {
  const ::JoinGameFailedMessage* p = joingamefailedmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.joinGameFailedMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::JoinGameFailedMessage*>(
      &::_JoinGameFailedMessage_default_instance_);
}
inline ::JoinGameFailedMessage* PokerTHMessage::release_joingamefailedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.joinGameFailedMessage)
  _has_bits_[0] &= ~0x01000000u;
  ::JoinGameFailedMessage* temp = joingamefailedmessage_;
  joingamefailedmessage_ = nullptr;
  return temp;
}
inline ::JoinGameFailedMessage* PokerTHMessage::mutable_joingamefailedmessage() {
  _has_bits_[0] |= 0x01000000u;
  if (joingamefailedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::JoinGameFailedMessage>(GetArenaNoVirtual());
    joingamefailedmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.joinGameFailedMessage)
  return joingamefailedmessage_;
}
inline void PokerTHMessage::set_allocated_joingamefailedmessage(::JoinGameFailedMessage* joingamefailedmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete joingamefailedmessage_;
  }
  if (joingamefailedmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      joingamefailedmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, joingamefailedmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x01000000u;
  } else {
    _has_bits_[0] &= ~0x01000000u;
  }
  joingamefailedmessage_ = joingamefailedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.joinGameFailedMessage)
}

// optional .GamePlayerJoinedMessage gamePlayerJoinedMessage = 27;
inline bool PokerTHMessage::has_gameplayerjoinedmessage() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PokerTHMessage::clear_gameplayerjoinedmessage() {
  if (gameplayerjoinedmessage_ != nullptr) gameplayerjoinedmessage_->Clear();
  _has_bits_[0] &= ~0x02000000u;
}
inline const ::GamePlayerJoinedMessage& PokerTHMessage::gameplayerjoinedmessage() const {
  const ::GamePlayerJoinedMessage* p = gameplayerjoinedmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.gamePlayerJoinedMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::GamePlayerJoinedMessage*>(
      &::_GamePlayerJoinedMessage_default_instance_);
}
inline ::GamePlayerJoinedMessage* PokerTHMessage::release_gameplayerjoinedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gamePlayerJoinedMessage)
  _has_bits_[0] &= ~0x02000000u;
  ::GamePlayerJoinedMessage* temp = gameplayerjoinedmessage_;
  gameplayerjoinedmessage_ = nullptr;
  return temp;
}
inline ::GamePlayerJoinedMessage* PokerTHMessage::mutable_gameplayerjoinedmessage() {
  _has_bits_[0] |= 0x02000000u;
  if (gameplayerjoinedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GamePlayerJoinedMessage>(GetArenaNoVirtual());
    gameplayerjoinedmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gamePlayerJoinedMessage)
  return gameplayerjoinedmessage_;
}
inline void PokerTHMessage::set_allocated_gameplayerjoinedmessage(::GamePlayerJoinedMessage* gameplayerjoinedmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gameplayerjoinedmessage_;
  }
  if (gameplayerjoinedmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gameplayerjoinedmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gameplayerjoinedmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x02000000u;
  } else {
    _has_bits_[0] &= ~0x02000000u;
  }
  gameplayerjoinedmessage_ = gameplayerjoinedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gamePlayerJoinedMessage)
}

// optional .GamePlayerLeftMessage gamePlayerLeftMessage = 28;
inline bool PokerTHMessage::has_gameplayerleftmessage() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PokerTHMessage::clear_gameplayerleftmessage() {
  if (gameplayerleftmessage_ != nullptr) gameplayerleftmessage_->Clear();
  _has_bits_[0] &= ~0x04000000u;
}
inline const ::GamePlayerLeftMessage& PokerTHMessage::gameplayerleftmessage() const {
  const ::GamePlayerLeftMessage* p = gameplayerleftmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.gamePlayerLeftMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::GamePlayerLeftMessage*>(
      &::_GamePlayerLeftMessage_default_instance_);
}
inline ::GamePlayerLeftMessage* PokerTHMessage::release_gameplayerleftmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gamePlayerLeftMessage)
  _has_bits_[0] &= ~0x04000000u;
  ::GamePlayerLeftMessage* temp = gameplayerleftmessage_;
  gameplayerleftmessage_ = nullptr;
  return temp;
}
inline ::GamePlayerLeftMessage* PokerTHMessage::mutable_gameplayerleftmessage() {
  _has_bits_[0] |= 0x04000000u;
  if (gameplayerleftmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GamePlayerLeftMessage>(GetArenaNoVirtual());
    gameplayerleftmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gamePlayerLeftMessage)
  return gameplayerleftmessage_;
}
inline void PokerTHMessage::set_allocated_gameplayerleftmessage(::GamePlayerLeftMessage* gameplayerleftmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gameplayerleftmessage_;
  }
  if (gameplayerleftmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gameplayerleftmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gameplayerleftmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x04000000u;
  } else {
    _has_bits_[0] &= ~0x04000000u;
  }
  gameplayerleftmessage_ = gameplayerleftmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gamePlayerLeftMessage)
}

// optional .GameAdminChangedMessage gameAdminChangedMessage = 29;
inline bool PokerTHMessage::has_gameadminchangedmessage() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PokerTHMessage::clear_gameadminchangedmessage() {
  if (gameadminchangedmessage_ != nullptr) gameadminchangedmessage_->Clear();
  _has_bits_[0] &= ~0x08000000u;
}
inline const ::GameAdminChangedMessage& PokerTHMessage::gameadminchangedmessage() const {
  const ::GameAdminChangedMessage* p = gameadminchangedmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameAdminChangedMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::GameAdminChangedMessage*>(
      &::_GameAdminChangedMessage_default_instance_);
}
inline ::GameAdminChangedMessage* PokerTHMessage::release_gameadminchangedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameAdminChangedMessage)
  _has_bits_[0] &= ~0x08000000u;
  ::GameAdminChangedMessage* temp = gameadminchangedmessage_;
  gameadminchangedmessage_ = nullptr;
  return temp;
}
inline ::GameAdminChangedMessage* PokerTHMessage::mutable_gameadminchangedmessage() {
  _has_bits_[0] |= 0x08000000u;
  if (gameadminchangedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameAdminChangedMessage>(GetArenaNoVirtual());
    gameadminchangedmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameAdminChangedMessage)
  return gameadminchangedmessage_;
}
inline void PokerTHMessage::set_allocated_gameadminchangedmessage(::GameAdminChangedMessage* gameadminchangedmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gameadminchangedmessage_;
  }
  if (gameadminchangedmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gameadminchangedmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gameadminchangedmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x08000000u;
  } else {
    _has_bits_[0] &= ~0x08000000u;
  }
  gameadminchangedmessage_ = gameadminchangedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameAdminChangedMessage)
}

// optional .RemovedFromGameMessage removedFromGameMessage = 30;
inline bool PokerTHMessage::has_removedfromgamemessage() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PokerTHMessage::clear_removedfromgamemessage() {
  if (removedfromgamemessage_ != nullptr) removedfromgamemessage_->Clear();
  _has_bits_[0] &= ~0x10000000u;
}
inline const ::RemovedFromGameMessage& PokerTHMessage::removedfromgamemessage() const {
  const ::RemovedFromGameMessage* p = removedfromgamemessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.removedFromGameMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::RemovedFromGameMessage*>(
      &::_RemovedFromGameMessage_default_instance_);
}
inline ::RemovedFromGameMessage* PokerTHMessage::release_removedfromgamemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.removedFromGameMessage)
  _has_bits_[0] &= ~0x10000000u;
  ::RemovedFromGameMessage* temp = removedfromgamemessage_;
  removedfromgamemessage_ = nullptr;
  return temp;
}
inline ::RemovedFromGameMessage* PokerTHMessage::mutable_removedfromgamemessage() {
  _has_bits_[0] |= 0x10000000u;
  if (removedfromgamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::RemovedFromGameMessage>(GetArenaNoVirtual());
    removedfromgamemessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.removedFromGameMessage)
  return removedfromgamemessage_;
}
inline void PokerTHMessage::set_allocated_removedfromgamemessage(::RemovedFromGameMessage* removedfromgamemessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete removedfromgamemessage_;
  }
  if (removedfromgamemessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      removedfromgamemessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, removedfromgamemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x10000000u;
  } else {
    _has_bits_[0] &= ~0x10000000u;
  }
  removedfromgamemessage_ = removedfromgamemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.removedFromGameMessage)
}

// optional .KickPlayerRequestMessage kickPlayerRequestMessage = 31;
inline bool PokerTHMessage::has_kickplayerrequestmessage() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PokerTHMessage::clear_kickplayerrequestmessage() {
  if (kickplayerrequestmessage_ != nullptr) kickplayerrequestmessage_->Clear();
  _has_bits_[0] &= ~0x20000000u;
}
inline const ::KickPlayerRequestMessage& PokerTHMessage::kickplayerrequestmessage() const {
  const ::KickPlayerRequestMessage* p = kickplayerrequestmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.kickPlayerRequestMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::KickPlayerRequestMessage*>(
      &::_KickPlayerRequestMessage_default_instance_);
}
inline ::KickPlayerRequestMessage* PokerTHMessage::release_kickplayerrequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.kickPlayerRequestMessage)
  _has_bits_[0] &= ~0x20000000u;
  ::KickPlayerRequestMessage* temp = kickplayerrequestmessage_;
  kickplayerrequestmessage_ = nullptr;
  return temp;
}
inline ::KickPlayerRequestMessage* PokerTHMessage::mutable_kickplayerrequestmessage() {
  _has_bits_[0] |= 0x20000000u;
  if (kickplayerrequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::KickPlayerRequestMessage>(GetArenaNoVirtual());
    kickplayerrequestmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.kickPlayerRequestMessage)
  return kickplayerrequestmessage_;
}
inline void PokerTHMessage::set_allocated_kickplayerrequestmessage(::KickPlayerRequestMessage* kickplayerrequestmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete kickplayerrequestmessage_;
  }
  if (kickplayerrequestmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      kickplayerrequestmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kickplayerrequestmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x20000000u;
  } else {
    _has_bits_[0] &= ~0x20000000u;
  }
  kickplayerrequestmessage_ = kickplayerrequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.kickPlayerRequestMessage)
}

// optional .LeaveGameRequestMessage leaveGameRequestMessage = 32;
inline bool PokerTHMessage::has_leavegamerequestmessage() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PokerTHMessage::clear_leavegamerequestmessage() {
  if (leavegamerequestmessage_ != nullptr) leavegamerequestmessage_->Clear();
  _has_bits_[0] &= ~0x40000000u;
}
inline const ::LeaveGameRequestMessage& PokerTHMessage::leavegamerequestmessage() const {
  const ::LeaveGameRequestMessage* p = leavegamerequestmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.leaveGameRequestMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::LeaveGameRequestMessage*>(
      &::_LeaveGameRequestMessage_default_instance_);
}
inline ::LeaveGameRequestMessage* PokerTHMessage::release_leavegamerequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.leaveGameRequestMessage)
  _has_bits_[0] &= ~0x40000000u;
  ::LeaveGameRequestMessage* temp = leavegamerequestmessage_;
  leavegamerequestmessage_ = nullptr;
  return temp;
}
inline ::LeaveGameRequestMessage* PokerTHMessage::mutable_leavegamerequestmessage() {
  _has_bits_[0] |= 0x40000000u;
  if (leavegamerequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::LeaveGameRequestMessage>(GetArenaNoVirtual());
    leavegamerequestmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.leaveGameRequestMessage)
  return leavegamerequestmessage_;
}
inline void PokerTHMessage::set_allocated_leavegamerequestmessage(::LeaveGameRequestMessage* leavegamerequestmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete leavegamerequestmessage_;
  }
  if (leavegamerequestmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      leavegamerequestmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, leavegamerequestmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x40000000u;
  } else {
    _has_bits_[0] &= ~0x40000000u;
  }
  leavegamerequestmessage_ = leavegamerequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.leaveGameRequestMessage)
}

// optional .InvitePlayerToGameMessage invitePlayerToGameMessage = 33;
inline bool PokerTHMessage::has_inviteplayertogamemessage() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PokerTHMessage::clear_inviteplayertogamemessage() {
  if (inviteplayertogamemessage_ != nullptr) inviteplayertogamemessage_->Clear();
  _has_bits_[0] &= ~0x80000000u;
}
inline const ::InvitePlayerToGameMessage& PokerTHMessage::inviteplayertogamemessage() const {
  const ::InvitePlayerToGameMessage* p = inviteplayertogamemessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.invitePlayerToGameMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::InvitePlayerToGameMessage*>(
      &::_InvitePlayerToGameMessage_default_instance_);
}
inline ::InvitePlayerToGameMessage* PokerTHMessage::release_inviteplayertogamemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.invitePlayerToGameMessage)
  _has_bits_[0] &= ~0x80000000u;
  ::InvitePlayerToGameMessage* temp = inviteplayertogamemessage_;
  inviteplayertogamemessage_ = nullptr;
  return temp;
}
inline ::InvitePlayerToGameMessage* PokerTHMessage::mutable_inviteplayertogamemessage() {
  _has_bits_[0] |= 0x80000000u;
  if (inviteplayertogamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::InvitePlayerToGameMessage>(GetArenaNoVirtual());
    inviteplayertogamemessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.invitePlayerToGameMessage)
  return inviteplayertogamemessage_;
}
inline void PokerTHMessage::set_allocated_inviteplayertogamemessage(::InvitePlayerToGameMessage* inviteplayertogamemessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete inviteplayertogamemessage_;
  }
  if (inviteplayertogamemessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      inviteplayertogamemessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, inviteplayertogamemessage, submessage_arena);
    }
    _has_bits_[0] |= 0x80000000u;
  } else {
    _has_bits_[0] &= ~0x80000000u;
  }
  inviteplayertogamemessage_ = inviteplayertogamemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.invitePlayerToGameMessage)
}

// optional .InviteNotifyMessage inviteNotifyMessage = 34;
inline bool PokerTHMessage::has_invitenotifymessage() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PokerTHMessage::clear_invitenotifymessage() {
  if (invitenotifymessage_ != nullptr) invitenotifymessage_->Clear();
  _has_bits_[1] &= ~0x00000001u;
}
inline const ::InviteNotifyMessage& PokerTHMessage::invitenotifymessage() const {
  const ::InviteNotifyMessage* p = invitenotifymessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.inviteNotifyMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::InviteNotifyMessage*>(
      &::_InviteNotifyMessage_default_instance_);
}
inline ::InviteNotifyMessage* PokerTHMessage::release_invitenotifymessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.inviteNotifyMessage)
  _has_bits_[1] &= ~0x00000001u;
  ::InviteNotifyMessage* temp = invitenotifymessage_;
  invitenotifymessage_ = nullptr;
  return temp;
}
inline ::InviteNotifyMessage* PokerTHMessage::mutable_invitenotifymessage() {
  _has_bits_[1] |= 0x00000001u;
  if (invitenotifymessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::InviteNotifyMessage>(GetArenaNoVirtual());
    invitenotifymessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.inviteNotifyMessage)
  return invitenotifymessage_;
}
inline void PokerTHMessage::set_allocated_invitenotifymessage(::InviteNotifyMessage* invitenotifymessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete invitenotifymessage_;
  }
  if (invitenotifymessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      invitenotifymessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, invitenotifymessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000001u;
  } else {
    _has_bits_[1] &= ~0x00000001u;
  }
  invitenotifymessage_ = invitenotifymessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.inviteNotifyMessage)
}

// optional .RejectGameInvitationMessage rejectGameInvitationMessage = 35;
inline bool PokerTHMessage::has_rejectgameinvitationmessage() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void PokerTHMessage::clear_rejectgameinvitationmessage() {
  if (rejectgameinvitationmessage_ != nullptr) rejectgameinvitationmessage_->Clear();
  _has_bits_[1] &= ~0x00000002u;
}
inline const ::RejectGameInvitationMessage& PokerTHMessage::rejectgameinvitationmessage() const {
  const ::RejectGameInvitationMessage* p = rejectgameinvitationmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.rejectGameInvitationMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::RejectGameInvitationMessage*>(
      &::_RejectGameInvitationMessage_default_instance_);
}
inline ::RejectGameInvitationMessage* PokerTHMessage::release_rejectgameinvitationmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.rejectGameInvitationMessage)
  _has_bits_[1] &= ~0x00000002u;
  ::RejectGameInvitationMessage* temp = rejectgameinvitationmessage_;
  rejectgameinvitationmessage_ = nullptr;
  return temp;
}
inline ::RejectGameInvitationMessage* PokerTHMessage::mutable_rejectgameinvitationmessage() {
  _has_bits_[1] |= 0x00000002u;
  if (rejectgameinvitationmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::RejectGameInvitationMessage>(GetArenaNoVirtual());
    rejectgameinvitationmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.rejectGameInvitationMessage)
  return rejectgameinvitationmessage_;
}
inline void PokerTHMessage::set_allocated_rejectgameinvitationmessage(::RejectGameInvitationMessage* rejectgameinvitationmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rejectgameinvitationmessage_;
  }
  if (rejectgameinvitationmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rejectgameinvitationmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rejectgameinvitationmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000002u;
  } else {
    _has_bits_[1] &= ~0x00000002u;
  }
  rejectgameinvitationmessage_ = rejectgameinvitationmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.rejectGameInvitationMessage)
}

// optional .RejectInvNotifyMessage rejectInvNotifyMessage = 36;
inline bool PokerTHMessage::has_rejectinvnotifymessage() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void PokerTHMessage::clear_rejectinvnotifymessage() {
  if (rejectinvnotifymessage_ != nullptr) rejectinvnotifymessage_->Clear();
  _has_bits_[1] &= ~0x00000004u;
}
inline const ::RejectInvNotifyMessage& PokerTHMessage::rejectinvnotifymessage() const {
  const ::RejectInvNotifyMessage* p = rejectinvnotifymessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.rejectInvNotifyMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::RejectInvNotifyMessage*>(
      &::_RejectInvNotifyMessage_default_instance_);
}
inline ::RejectInvNotifyMessage* PokerTHMessage::release_rejectinvnotifymessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.rejectInvNotifyMessage)
  _has_bits_[1] &= ~0x00000004u;
  ::RejectInvNotifyMessage* temp = rejectinvnotifymessage_;
  rejectinvnotifymessage_ = nullptr;
  return temp;
}
inline ::RejectInvNotifyMessage* PokerTHMessage::mutable_rejectinvnotifymessage() {
  _has_bits_[1] |= 0x00000004u;
  if (rejectinvnotifymessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::RejectInvNotifyMessage>(GetArenaNoVirtual());
    rejectinvnotifymessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.rejectInvNotifyMessage)
  return rejectinvnotifymessage_;
}
inline void PokerTHMessage::set_allocated_rejectinvnotifymessage(::RejectInvNotifyMessage* rejectinvnotifymessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rejectinvnotifymessage_;
  }
  if (rejectinvnotifymessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rejectinvnotifymessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rejectinvnotifymessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000004u;
  } else {
    _has_bits_[1] &= ~0x00000004u;
  }
  rejectinvnotifymessage_ = rejectinvnotifymessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.rejectInvNotifyMessage)
}

// optional .StartEventMessage startEventMessage = 37;
inline bool PokerTHMessage::has_starteventmessage() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void PokerTHMessage::clear_starteventmessage() {
  if (starteventmessage_ != nullptr) starteventmessage_->Clear();
  _has_bits_[1] &= ~0x00000008u;
}
inline const ::StartEventMessage& PokerTHMessage::starteventmessage() const {
  const ::StartEventMessage* p = starteventmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.startEventMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::StartEventMessage*>(
      &::_StartEventMessage_default_instance_);
}
inline ::StartEventMessage* PokerTHMessage::release_starteventmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.startEventMessage)
  _has_bits_[1] &= ~0x00000008u;
  ::StartEventMessage* temp = starteventmessage_;
  starteventmessage_ = nullptr;
  return temp;
}
inline ::StartEventMessage* PokerTHMessage::mutable_starteventmessage() {
  _has_bits_[1] |= 0x00000008u;
  if (starteventmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::StartEventMessage>(GetArenaNoVirtual());
    starteventmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.startEventMessage)
  return starteventmessage_;
}
inline void PokerTHMessage::set_allocated_starteventmessage(::StartEventMessage* starteventmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete starteventmessage_;
  }
  if (starteventmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      starteventmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, starteventmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000008u;
  } else {
    _has_bits_[1] &= ~0x00000008u;
  }
  starteventmessage_ = starteventmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.startEventMessage)
}

// optional .StartEventAckMessage startEventAckMessage = 38;
inline bool PokerTHMessage::has_starteventackmessage() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void PokerTHMessage::clear_starteventackmessage() {
  if (starteventackmessage_ != nullptr) starteventackmessage_->Clear();
  _has_bits_[1] &= ~0x00000010u;
}
inline const ::StartEventAckMessage& PokerTHMessage::starteventackmessage() const {
  const ::StartEventAckMessage* p = starteventackmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.startEventAckMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::StartEventAckMessage*>(
      &::_StartEventAckMessage_default_instance_);
}
inline ::StartEventAckMessage* PokerTHMessage::release_starteventackmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.startEventAckMessage)
  _has_bits_[1] &= ~0x00000010u;
  ::StartEventAckMessage* temp = starteventackmessage_;
  starteventackmessage_ = nullptr;
  return temp;
}
inline ::StartEventAckMessage* PokerTHMessage::mutable_starteventackmessage() {
  _has_bits_[1] |= 0x00000010u;
  if (starteventackmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::StartEventAckMessage>(GetArenaNoVirtual());
    starteventackmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.startEventAckMessage)
  return starteventackmessage_;
}
inline void PokerTHMessage::set_allocated_starteventackmessage(::StartEventAckMessage* starteventackmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete starteventackmessage_;
  }
  if (starteventackmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      starteventackmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, starteventackmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000010u;
  } else {
    _has_bits_[1] &= ~0x00000010u;
  }
  starteventackmessage_ = starteventackmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.startEventAckMessage)
}

// optional .GameStartInitialMessage gameStartInitialMessage = 39;
inline bool PokerTHMessage::has_gamestartinitialmessage() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void PokerTHMessage::clear_gamestartinitialmessage() {
  if (gamestartinitialmessage_ != nullptr) gamestartinitialmessage_->Clear();
  _has_bits_[1] &= ~0x00000020u;
}
inline const ::GameStartInitialMessage& PokerTHMessage::gamestartinitialmessage() const {
  const ::GameStartInitialMessage* p = gamestartinitialmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameStartInitialMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::GameStartInitialMessage*>(
      &::_GameStartInitialMessage_default_instance_);
}
inline ::GameStartInitialMessage* PokerTHMessage::release_gamestartinitialmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameStartInitialMessage)
  _has_bits_[1] &= ~0x00000020u;
  ::GameStartInitialMessage* temp = gamestartinitialmessage_;
  gamestartinitialmessage_ = nullptr;
  return temp;
}
inline ::GameStartInitialMessage* PokerTHMessage::mutable_gamestartinitialmessage() {
  _has_bits_[1] |= 0x00000020u;
  if (gamestartinitialmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameStartInitialMessage>(GetArenaNoVirtual());
    gamestartinitialmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameStartInitialMessage)
  return gamestartinitialmessage_;
}
inline void PokerTHMessage::set_allocated_gamestartinitialmessage(::GameStartInitialMessage* gamestartinitialmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gamestartinitialmessage_;
  }
  if (gamestartinitialmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gamestartinitialmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gamestartinitialmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000020u;
  } else {
    _has_bits_[1] &= ~0x00000020u;
  }
  gamestartinitialmessage_ = gamestartinitialmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameStartInitialMessage)
}

// optional .GameStartRejoinMessage gameStartRejoinMessage = 40;
inline bool PokerTHMessage::has_gamestartrejoinmessage() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void PokerTHMessage::clear_gamestartrejoinmessage() {
  if (gamestartrejoinmessage_ != nullptr) gamestartrejoinmessage_->Clear();
  _has_bits_[1] &= ~0x00000040u;
}
inline const ::GameStartRejoinMessage& PokerTHMessage::gamestartrejoinmessage() const {
  const ::GameStartRejoinMessage* p = gamestartrejoinmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameStartRejoinMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::GameStartRejoinMessage*>(
      &::_GameStartRejoinMessage_default_instance_);
}
inline ::GameStartRejoinMessage* PokerTHMessage::release_gamestartrejoinmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameStartRejoinMessage)
  _has_bits_[1] &= ~0x00000040u;
  ::GameStartRejoinMessage* temp = gamestartrejoinmessage_;
  gamestartrejoinmessage_ = nullptr;
  return temp;
}
inline ::GameStartRejoinMessage* PokerTHMessage::mutable_gamestartrejoinmessage() {
  _has_bits_[1] |= 0x00000040u;
  if (gamestartrejoinmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameStartRejoinMessage>(GetArenaNoVirtual());
    gamestartrejoinmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameStartRejoinMessage)
  return gamestartrejoinmessage_;
}
inline void PokerTHMessage::set_allocated_gamestartrejoinmessage(::GameStartRejoinMessage* gamestartrejoinmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gamestartrejoinmessage_;
  }
  if (gamestartrejoinmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gamestartrejoinmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gamestartrejoinmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000040u;
  } else {
    _has_bits_[1] &= ~0x00000040u;
  }
  gamestartrejoinmessage_ = gamestartrejoinmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameStartRejoinMessage)
}

// optional .HandStartMessage handStartMessage = 41;
inline bool PokerTHMessage::has_handstartmessage() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void PokerTHMessage::clear_handstartmessage() {
  if (handstartmessage_ != nullptr) handstartmessage_->Clear();
  _has_bits_[1] &= ~0x00000080u;
}
inline const ::HandStartMessage& PokerTHMessage::handstartmessage() const {
  const ::HandStartMessage* p = handstartmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.handStartMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::HandStartMessage*>(
      &::_HandStartMessage_default_instance_);
}
inline ::HandStartMessage* PokerTHMessage::release_handstartmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.handStartMessage)
  _has_bits_[1] &= ~0x00000080u;
  ::HandStartMessage* temp = handstartmessage_;
  handstartmessage_ = nullptr;
  return temp;
}
inline ::HandStartMessage* PokerTHMessage::mutable_handstartmessage() {
  _has_bits_[1] |= 0x00000080u;
  if (handstartmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::HandStartMessage>(GetArenaNoVirtual());
    handstartmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.handStartMessage)
  return handstartmessage_;
}
inline void PokerTHMessage::set_allocated_handstartmessage(::HandStartMessage* handstartmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete handstartmessage_;
  }
  if (handstartmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      handstartmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handstartmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000080u;
  } else {
    _has_bits_[1] &= ~0x00000080u;
  }
  handstartmessage_ = handstartmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.handStartMessage)
}

// optional .PlayersTurnMessage playersTurnMessage = 42;
inline bool PokerTHMessage::has_playersturnmessage() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void PokerTHMessage::clear_playersturnmessage() {
  if (playersturnmessage_ != nullptr) playersturnmessage_->Clear();
  _has_bits_[1] &= ~0x00000100u;
}
inline const ::PlayersTurnMessage& PokerTHMessage::playersturnmessage() const {
  const ::PlayersTurnMessage* p = playersturnmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.playersTurnMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::PlayersTurnMessage*>(
      &::_PlayersTurnMessage_default_instance_);
}
inline ::PlayersTurnMessage* PokerTHMessage::release_playersturnmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.playersTurnMessage)
  _has_bits_[1] &= ~0x00000100u;
  ::PlayersTurnMessage* temp = playersturnmessage_;
  playersturnmessage_ = nullptr;
  return temp;
}
inline ::PlayersTurnMessage* PokerTHMessage::mutable_playersturnmessage() {
  _has_bits_[1] |= 0x00000100u;
  if (playersturnmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayersTurnMessage>(GetArenaNoVirtual());
    playersturnmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playersTurnMessage)
  return playersturnmessage_;
}
inline void PokerTHMessage::set_allocated_playersturnmessage(::PlayersTurnMessage* playersturnmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete playersturnmessage_;
  }
  if (playersturnmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      playersturnmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, playersturnmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000100u;
  } else {
    _has_bits_[1] &= ~0x00000100u;
  }
  playersturnmessage_ = playersturnmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playersTurnMessage)
}

// optional .MyActionRequestMessage myActionRequestMessage = 43;
inline bool PokerTHMessage::has_myactionrequestmessage() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void PokerTHMessage::clear_myactionrequestmessage() {
  if (myactionrequestmessage_ != nullptr) myactionrequestmessage_->Clear();
  _has_bits_[1] &= ~0x00000200u;
}
inline const ::MyActionRequestMessage& PokerTHMessage::myactionrequestmessage() const {
  const ::MyActionRequestMessage* p = myactionrequestmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.myActionRequestMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::MyActionRequestMessage*>(
      &::_MyActionRequestMessage_default_instance_);
}
inline ::MyActionRequestMessage* PokerTHMessage::release_myactionrequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.myActionRequestMessage)
  _has_bits_[1] &= ~0x00000200u;
  ::MyActionRequestMessage* temp = myactionrequestmessage_;
  myactionrequestmessage_ = nullptr;
  return temp;
}
inline ::MyActionRequestMessage* PokerTHMessage::mutable_myactionrequestmessage() {
  _has_bits_[1] |= 0x00000200u;
  if (myactionrequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::MyActionRequestMessage>(GetArenaNoVirtual());
    myactionrequestmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.myActionRequestMessage)
  return myactionrequestmessage_;
}
inline void PokerTHMessage::set_allocated_myactionrequestmessage(::MyActionRequestMessage* myactionrequestmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete myactionrequestmessage_;
  }
  if (myactionrequestmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      myactionrequestmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, myactionrequestmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000200u;
  } else {
    _has_bits_[1] &= ~0x00000200u;
  }
  myactionrequestmessage_ = myactionrequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.myActionRequestMessage)
}

// optional .YourActionRejectedMessage yourActionRejectedMessage = 44;
inline bool PokerTHMessage::has_youractionrejectedmessage() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void PokerTHMessage::clear_youractionrejectedmessage() {
  if (youractionrejectedmessage_ != nullptr) youractionrejectedmessage_->Clear();
  _has_bits_[1] &= ~0x00000400u;
}
inline const ::YourActionRejectedMessage& PokerTHMessage::youractionrejectedmessage() const {
  const ::YourActionRejectedMessage* p = youractionrejectedmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.yourActionRejectedMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::YourActionRejectedMessage*>(
      &::_YourActionRejectedMessage_default_instance_);
}
inline ::YourActionRejectedMessage* PokerTHMessage::release_youractionrejectedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.yourActionRejectedMessage)
  _has_bits_[1] &= ~0x00000400u;
  ::YourActionRejectedMessage* temp = youractionrejectedmessage_;
  youractionrejectedmessage_ = nullptr;
  return temp;
}
inline ::YourActionRejectedMessage* PokerTHMessage::mutable_youractionrejectedmessage() {
  _has_bits_[1] |= 0x00000400u;
  if (youractionrejectedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::YourActionRejectedMessage>(GetArenaNoVirtual());
    youractionrejectedmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.yourActionRejectedMessage)
  return youractionrejectedmessage_;
}
inline void PokerTHMessage::set_allocated_youractionrejectedmessage(::YourActionRejectedMessage* youractionrejectedmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete youractionrejectedmessage_;
  }
  if (youractionrejectedmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      youractionrejectedmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, youractionrejectedmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000400u;
  } else {
    _has_bits_[1] &= ~0x00000400u;
  }
  youractionrejectedmessage_ = youractionrejectedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.yourActionRejectedMessage)
}

// optional .PlayersActionDoneMessage playersActionDoneMessage = 45;
inline bool PokerTHMessage::has_playersactiondonemessage() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void PokerTHMessage::clear_playersactiondonemessage() {
  if (playersactiondonemessage_ != nullptr) playersactiondonemessage_->Clear();
  _has_bits_[1] &= ~0x00000800u;
}
inline const ::PlayersActionDoneMessage& PokerTHMessage::playersactiondonemessage() const {
  const ::PlayersActionDoneMessage* p = playersactiondonemessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.playersActionDoneMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::PlayersActionDoneMessage*>(
      &::_PlayersActionDoneMessage_default_instance_);
}
inline ::PlayersActionDoneMessage* PokerTHMessage::release_playersactiondonemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.playersActionDoneMessage)
  _has_bits_[1] &= ~0x00000800u;
  ::PlayersActionDoneMessage* temp = playersactiondonemessage_;
  playersactiondonemessage_ = nullptr;
  return temp;
}
inline ::PlayersActionDoneMessage* PokerTHMessage::mutable_playersactiondonemessage() {
  _has_bits_[1] |= 0x00000800u;
  if (playersactiondonemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayersActionDoneMessage>(GetArenaNoVirtual());
    playersactiondonemessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playersActionDoneMessage)
  return playersactiondonemessage_;
}
inline void PokerTHMessage::set_allocated_playersactiondonemessage(::PlayersActionDoneMessage* playersactiondonemessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete playersactiondonemessage_;
  }
  if (playersactiondonemessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      playersactiondonemessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, playersactiondonemessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00000800u;
  } else {
    _has_bits_[1] &= ~0x00000800u;
  }
  playersactiondonemessage_ = playersactiondonemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playersActionDoneMessage)
}

// optional .DealFlopCardsMessage dealFlopCardsMessage = 46;
inline bool PokerTHMessage::has_dealflopcardsmessage() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void PokerTHMessage::clear_dealflopcardsmessage() {
  if (dealflopcardsmessage_ != nullptr) dealflopcardsmessage_->Clear();
  _has_bits_[1] &= ~0x00001000u;
}
inline const ::DealFlopCardsMessage& PokerTHMessage::dealflopcardsmessage() const {
  const ::DealFlopCardsMessage* p = dealflopcardsmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.dealFlopCardsMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::DealFlopCardsMessage*>(
      &::_DealFlopCardsMessage_default_instance_);
}
inline ::DealFlopCardsMessage* PokerTHMessage::release_dealflopcardsmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.dealFlopCardsMessage)
  _has_bits_[1] &= ~0x00001000u;
  ::DealFlopCardsMessage* temp = dealflopcardsmessage_;
  dealflopcardsmessage_ = nullptr;
  return temp;
}
inline ::DealFlopCardsMessage* PokerTHMessage::mutable_dealflopcardsmessage() {
  _has_bits_[1] |= 0x00001000u;
  if (dealflopcardsmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::DealFlopCardsMessage>(GetArenaNoVirtual());
    dealflopcardsmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.dealFlopCardsMessage)
  return dealflopcardsmessage_;
}
inline void PokerTHMessage::set_allocated_dealflopcardsmessage(::DealFlopCardsMessage* dealflopcardsmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dealflopcardsmessage_;
  }
  if (dealflopcardsmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dealflopcardsmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dealflopcardsmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00001000u;
  } else {
    _has_bits_[1] &= ~0x00001000u;
  }
  dealflopcardsmessage_ = dealflopcardsmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.dealFlopCardsMessage)
}

// optional .DealTurnCardMessage dealTurnCardMessage = 47;
inline bool PokerTHMessage::has_dealturncardmessage() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void PokerTHMessage::clear_dealturncardmessage() {
  if (dealturncardmessage_ != nullptr) dealturncardmessage_->Clear();
  _has_bits_[1] &= ~0x00002000u;
}
inline const ::DealTurnCardMessage& PokerTHMessage::dealturncardmessage() const {
  const ::DealTurnCardMessage* p = dealturncardmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.dealTurnCardMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::DealTurnCardMessage*>(
      &::_DealTurnCardMessage_default_instance_);
}
inline ::DealTurnCardMessage* PokerTHMessage::release_dealturncardmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.dealTurnCardMessage)
  _has_bits_[1] &= ~0x00002000u;
  ::DealTurnCardMessage* temp = dealturncardmessage_;
  dealturncardmessage_ = nullptr;
  return temp;
}
inline ::DealTurnCardMessage* PokerTHMessage::mutable_dealturncardmessage() {
  _has_bits_[1] |= 0x00002000u;
  if (dealturncardmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::DealTurnCardMessage>(GetArenaNoVirtual());
    dealturncardmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.dealTurnCardMessage)
  return dealturncardmessage_;
}
inline void PokerTHMessage::set_allocated_dealturncardmessage(::DealTurnCardMessage* dealturncardmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dealturncardmessage_;
  }
  if (dealturncardmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dealturncardmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dealturncardmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00002000u;
  } else {
    _has_bits_[1] &= ~0x00002000u;
  }
  dealturncardmessage_ = dealturncardmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.dealTurnCardMessage)
}

// optional .DealRiverCardMessage dealRiverCardMessage = 48;
inline bool PokerTHMessage::has_dealrivercardmessage() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void PokerTHMessage::clear_dealrivercardmessage() {
  if (dealrivercardmessage_ != nullptr) dealrivercardmessage_->Clear();
  _has_bits_[1] &= ~0x00004000u;
}
inline const ::DealRiverCardMessage& PokerTHMessage::dealrivercardmessage() const {
  const ::DealRiverCardMessage* p = dealrivercardmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.dealRiverCardMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::DealRiverCardMessage*>(
      &::_DealRiverCardMessage_default_instance_);
}
inline ::DealRiverCardMessage* PokerTHMessage::release_dealrivercardmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.dealRiverCardMessage)
  _has_bits_[1] &= ~0x00004000u;
  ::DealRiverCardMessage* temp = dealrivercardmessage_;
  dealrivercardmessage_ = nullptr;
  return temp;
}
inline ::DealRiverCardMessage* PokerTHMessage::mutable_dealrivercardmessage() {
  _has_bits_[1] |= 0x00004000u;
  if (dealrivercardmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::DealRiverCardMessage>(GetArenaNoVirtual());
    dealrivercardmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.dealRiverCardMessage)
  return dealrivercardmessage_;
}
inline void PokerTHMessage::set_allocated_dealrivercardmessage(::DealRiverCardMessage* dealrivercardmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dealrivercardmessage_;
  }
  if (dealrivercardmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dealrivercardmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dealrivercardmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00004000u;
  } else {
    _has_bits_[1] &= ~0x00004000u;
  }
  dealrivercardmessage_ = dealrivercardmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.dealRiverCardMessage)
}

// optional .AllInShowCardsMessage allInShowCardsMessage = 49;
inline bool PokerTHMessage::has_allinshowcardsmessage() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void PokerTHMessage::clear_allinshowcardsmessage() {
  if (allinshowcardsmessage_ != nullptr) allinshowcardsmessage_->Clear();
  _has_bits_[1] &= ~0x00008000u;
}
inline const ::AllInShowCardsMessage& PokerTHMessage::allinshowcardsmessage() const {
  const ::AllInShowCardsMessage* p = allinshowcardsmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.allInShowCardsMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::AllInShowCardsMessage*>(
      &::_AllInShowCardsMessage_default_instance_);
}
inline ::AllInShowCardsMessage* PokerTHMessage::release_allinshowcardsmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.allInShowCardsMessage)
  _has_bits_[1] &= ~0x00008000u;
  ::AllInShowCardsMessage* temp = allinshowcardsmessage_;
  allinshowcardsmessage_ = nullptr;
  return temp;
}
inline ::AllInShowCardsMessage* PokerTHMessage::mutable_allinshowcardsmessage() {
  _has_bits_[1] |= 0x00008000u;
  if (allinshowcardsmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AllInShowCardsMessage>(GetArenaNoVirtual());
    allinshowcardsmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.allInShowCardsMessage)
  return allinshowcardsmessage_;
}
inline void PokerTHMessage::set_allocated_allinshowcardsmessage(::AllInShowCardsMessage* allinshowcardsmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete allinshowcardsmessage_;
  }
  if (allinshowcardsmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      allinshowcardsmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, allinshowcardsmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00008000u;
  } else {
    _has_bits_[1] &= ~0x00008000u;
  }
  allinshowcardsmessage_ = allinshowcardsmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.allInShowCardsMessage)
}

// optional .EndOfHandShowCardsMessage endOfHandShowCardsMessage = 50;
inline bool PokerTHMessage::has_endofhandshowcardsmessage() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void PokerTHMessage::clear_endofhandshowcardsmessage() {
  if (endofhandshowcardsmessage_ != nullptr) endofhandshowcardsmessage_->Clear();
  _has_bits_[1] &= ~0x00010000u;
}
inline const ::EndOfHandShowCardsMessage& PokerTHMessage::endofhandshowcardsmessage() const {
  const ::EndOfHandShowCardsMessage* p = endofhandshowcardsmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.endOfHandShowCardsMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::EndOfHandShowCardsMessage*>(
      &::_EndOfHandShowCardsMessage_default_instance_);
}
inline ::EndOfHandShowCardsMessage* PokerTHMessage::release_endofhandshowcardsmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.endOfHandShowCardsMessage)
  _has_bits_[1] &= ~0x00010000u;
  ::EndOfHandShowCardsMessage* temp = endofhandshowcardsmessage_;
  endofhandshowcardsmessage_ = nullptr;
  return temp;
}
inline ::EndOfHandShowCardsMessage* PokerTHMessage::mutable_endofhandshowcardsmessage() {
  _has_bits_[1] |= 0x00010000u;
  if (endofhandshowcardsmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::EndOfHandShowCardsMessage>(GetArenaNoVirtual());
    endofhandshowcardsmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.endOfHandShowCardsMessage)
  return endofhandshowcardsmessage_;
}
inline void PokerTHMessage::set_allocated_endofhandshowcardsmessage(::EndOfHandShowCardsMessage* endofhandshowcardsmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete endofhandshowcardsmessage_;
  }
  if (endofhandshowcardsmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      endofhandshowcardsmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, endofhandshowcardsmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00010000u;
  } else {
    _has_bits_[1] &= ~0x00010000u;
  }
  endofhandshowcardsmessage_ = endofhandshowcardsmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.endOfHandShowCardsMessage)
}

// optional .EndOfHandHideCardsMessage endOfHandHideCardsMessage = 51;
inline bool PokerTHMessage::has_endofhandhidecardsmessage() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void PokerTHMessage::clear_endofhandhidecardsmessage() {
  if (endofhandhidecardsmessage_ != nullptr) endofhandhidecardsmessage_->Clear();
  _has_bits_[1] &= ~0x00020000u;
}
inline const ::EndOfHandHideCardsMessage& PokerTHMessage::endofhandhidecardsmessage() const {
  const ::EndOfHandHideCardsMessage* p = endofhandhidecardsmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.endOfHandHideCardsMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::EndOfHandHideCardsMessage*>(
      &::_EndOfHandHideCardsMessage_default_instance_);
}
inline ::EndOfHandHideCardsMessage* PokerTHMessage::release_endofhandhidecardsmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.endOfHandHideCardsMessage)
  _has_bits_[1] &= ~0x00020000u;
  ::EndOfHandHideCardsMessage* temp = endofhandhidecardsmessage_;
  endofhandhidecardsmessage_ = nullptr;
  return temp;
}
inline ::EndOfHandHideCardsMessage* PokerTHMessage::mutable_endofhandhidecardsmessage() {
  _has_bits_[1] |= 0x00020000u;
  if (endofhandhidecardsmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::EndOfHandHideCardsMessage>(GetArenaNoVirtual());
    endofhandhidecardsmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.endOfHandHideCardsMessage)
  return endofhandhidecardsmessage_;
}
inline void PokerTHMessage::set_allocated_endofhandhidecardsmessage(::EndOfHandHideCardsMessage* endofhandhidecardsmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete endofhandhidecardsmessage_;
  }
  if (endofhandhidecardsmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      endofhandhidecardsmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, endofhandhidecardsmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00020000u;
  } else {
    _has_bits_[1] &= ~0x00020000u;
  }
  endofhandhidecardsmessage_ = endofhandhidecardsmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.endOfHandHideCardsMessage)
}

// optional .ShowMyCardsRequestMessage showMyCardsRequestMessage = 52;
inline bool PokerTHMessage::has_showmycardsrequestmessage() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void PokerTHMessage::clear_showmycardsrequestmessage() {
  if (showmycardsrequestmessage_ != nullptr) showmycardsrequestmessage_->Clear();
  _has_bits_[1] &= ~0x00040000u;
}
inline const ::ShowMyCardsRequestMessage& PokerTHMessage::showmycardsrequestmessage() const {
  const ::ShowMyCardsRequestMessage* p = showmycardsrequestmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.showMyCardsRequestMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::ShowMyCardsRequestMessage*>(
      &::_ShowMyCardsRequestMessage_default_instance_);
}
inline ::ShowMyCardsRequestMessage* PokerTHMessage::release_showmycardsrequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.showMyCardsRequestMessage)
  _has_bits_[1] &= ~0x00040000u;
  ::ShowMyCardsRequestMessage* temp = showmycardsrequestmessage_;
  showmycardsrequestmessage_ = nullptr;
  return temp;
}
inline ::ShowMyCardsRequestMessage* PokerTHMessage::mutable_showmycardsrequestmessage() {
  _has_bits_[1] |= 0x00040000u;
  if (showmycardsrequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ShowMyCardsRequestMessage>(GetArenaNoVirtual());
    showmycardsrequestmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.showMyCardsRequestMessage)
  return showmycardsrequestmessage_;
}
inline void PokerTHMessage::set_allocated_showmycardsrequestmessage(::ShowMyCardsRequestMessage* showmycardsrequestmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete showmycardsrequestmessage_;
  }
  if (showmycardsrequestmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      showmycardsrequestmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, showmycardsrequestmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00040000u;
  } else {
    _has_bits_[1] &= ~0x00040000u;
  }
  showmycardsrequestmessage_ = showmycardsrequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.showMyCardsRequestMessage)
}

// optional .AfterHandShowCardsMessage afterHandShowCardsMessage = 53;
inline bool PokerTHMessage::has_afterhandshowcardsmessage() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void PokerTHMessage::clear_afterhandshowcardsmessage() {
  if (afterhandshowcardsmessage_ != nullptr) afterhandshowcardsmessage_->Clear();
  _has_bits_[1] &= ~0x00080000u;
}
inline const ::AfterHandShowCardsMessage& PokerTHMessage::afterhandshowcardsmessage() const {
  const ::AfterHandShowCardsMessage* p = afterhandshowcardsmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.afterHandShowCardsMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::AfterHandShowCardsMessage*>(
      &::_AfterHandShowCardsMessage_default_instance_);
}
inline ::AfterHandShowCardsMessage* PokerTHMessage::release_afterhandshowcardsmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.afterHandShowCardsMessage)
  _has_bits_[1] &= ~0x00080000u;
  ::AfterHandShowCardsMessage* temp = afterhandshowcardsmessage_;
  afterhandshowcardsmessage_ = nullptr;
  return temp;
}
inline ::AfterHandShowCardsMessage* PokerTHMessage::mutable_afterhandshowcardsmessage() {
  _has_bits_[1] |= 0x00080000u;
  if (afterhandshowcardsmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AfterHandShowCardsMessage>(GetArenaNoVirtual());
    afterhandshowcardsmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.afterHandShowCardsMessage)
  return afterhandshowcardsmessage_;
}
inline void PokerTHMessage::set_allocated_afterhandshowcardsmessage(::AfterHandShowCardsMessage* afterhandshowcardsmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete afterhandshowcardsmessage_;
  }
  if (afterhandshowcardsmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      afterhandshowcardsmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, afterhandshowcardsmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00080000u;
  } else {
    _has_bits_[1] &= ~0x00080000u;
  }
  afterhandshowcardsmessage_ = afterhandshowcardsmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.afterHandShowCardsMessage)
}

// optional .EndOfGameMessage endOfGameMessage = 54;
inline bool PokerTHMessage::has_endofgamemessage() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void PokerTHMessage::clear_endofgamemessage() {
  if (endofgamemessage_ != nullptr) endofgamemessage_->Clear();
  _has_bits_[1] &= ~0x00100000u;
}
inline const ::EndOfGameMessage& PokerTHMessage::endofgamemessage() const {
  const ::EndOfGameMessage* p = endofgamemessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.endOfGameMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::EndOfGameMessage*>(
      &::_EndOfGameMessage_default_instance_);
}
inline ::EndOfGameMessage* PokerTHMessage::release_endofgamemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.endOfGameMessage)
  _has_bits_[1] &= ~0x00100000u;
  ::EndOfGameMessage* temp = endofgamemessage_;
  endofgamemessage_ = nullptr;
  return temp;
}
inline ::EndOfGameMessage* PokerTHMessage::mutable_endofgamemessage() {
  _has_bits_[1] |= 0x00100000u;
  if (endofgamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::EndOfGameMessage>(GetArenaNoVirtual());
    endofgamemessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.endOfGameMessage)
  return endofgamemessage_;
}
inline void PokerTHMessage::set_allocated_endofgamemessage(::EndOfGameMessage* endofgamemessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete endofgamemessage_;
  }
  if (endofgamemessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      endofgamemessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, endofgamemessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00100000u;
  } else {
    _has_bits_[1] &= ~0x00100000u;
  }
  endofgamemessage_ = endofgamemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.endOfGameMessage)
}

// optional .PlayerIdChangedMessage playerIdChangedMessage = 55;
inline bool PokerTHMessage::has_playeridchangedmessage() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void PokerTHMessage::clear_playeridchangedmessage() {
  if (playeridchangedmessage_ != nullptr) playeridchangedmessage_->Clear();
  _has_bits_[1] &= ~0x00200000u;
}
inline const ::PlayerIdChangedMessage& PokerTHMessage::playeridchangedmessage() const {
  const ::PlayerIdChangedMessage* p = playeridchangedmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.playerIdChangedMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::PlayerIdChangedMessage*>(
      &::_PlayerIdChangedMessage_default_instance_);
}
inline ::PlayerIdChangedMessage* PokerTHMessage::release_playeridchangedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.playerIdChangedMessage)
  _has_bits_[1] &= ~0x00200000u;
  ::PlayerIdChangedMessage* temp = playeridchangedmessage_;
  playeridchangedmessage_ = nullptr;
  return temp;
}
inline ::PlayerIdChangedMessage* PokerTHMessage::mutable_playeridchangedmessage() {
  _has_bits_[1] |= 0x00200000u;
  if (playeridchangedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::PlayerIdChangedMessage>(GetArenaNoVirtual());
    playeridchangedmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.playerIdChangedMessage)
  return playeridchangedmessage_;
}
inline void PokerTHMessage::set_allocated_playeridchangedmessage(::PlayerIdChangedMessage* playeridchangedmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete playeridchangedmessage_;
  }
  if (playeridchangedmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      playeridchangedmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, playeridchangedmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00200000u;
  } else {
    _has_bits_[1] &= ~0x00200000u;
  }
  playeridchangedmessage_ = playeridchangedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.playerIdChangedMessage)
}

// optional .AskKickPlayerMessage askKickPlayerMessage = 56;
inline bool PokerTHMessage::has_askkickplayermessage() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void PokerTHMessage::clear_askkickplayermessage() {
  if (askkickplayermessage_ != nullptr) askkickplayermessage_->Clear();
  _has_bits_[1] &= ~0x00400000u;
}
inline const ::AskKickPlayerMessage& PokerTHMessage::askkickplayermessage() const {
  const ::AskKickPlayerMessage* p = askkickplayermessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.askKickPlayerMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::AskKickPlayerMessage*>(
      &::_AskKickPlayerMessage_default_instance_);
}
inline ::AskKickPlayerMessage* PokerTHMessage::release_askkickplayermessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.askKickPlayerMessage)
  _has_bits_[1] &= ~0x00400000u;
  ::AskKickPlayerMessage* temp = askkickplayermessage_;
  askkickplayermessage_ = nullptr;
  return temp;
}
inline ::AskKickPlayerMessage* PokerTHMessage::mutable_askkickplayermessage() {
  _has_bits_[1] |= 0x00400000u;
  if (askkickplayermessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AskKickPlayerMessage>(GetArenaNoVirtual());
    askkickplayermessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.askKickPlayerMessage)
  return askkickplayermessage_;
}
inline void PokerTHMessage::set_allocated_askkickplayermessage(::AskKickPlayerMessage* askkickplayermessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete askkickplayermessage_;
  }
  if (askkickplayermessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      askkickplayermessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, askkickplayermessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00400000u;
  } else {
    _has_bits_[1] &= ~0x00400000u;
  }
  askkickplayermessage_ = askkickplayermessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.askKickPlayerMessage)
}

// optional .AskKickDeniedMessage askKickDeniedMessage = 57;
inline bool PokerTHMessage::has_askkickdeniedmessage() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void PokerTHMessage::clear_askkickdeniedmessage() {
  if (askkickdeniedmessage_ != nullptr) askkickdeniedmessage_->Clear();
  _has_bits_[1] &= ~0x00800000u;
}
inline const ::AskKickDeniedMessage& PokerTHMessage::askkickdeniedmessage() const {
  const ::AskKickDeniedMessage* p = askkickdeniedmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.askKickDeniedMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::AskKickDeniedMessage*>(
      &::_AskKickDeniedMessage_default_instance_);
}
inline ::AskKickDeniedMessage* PokerTHMessage::release_askkickdeniedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.askKickDeniedMessage)
  _has_bits_[1] &= ~0x00800000u;
  ::AskKickDeniedMessage* temp = askkickdeniedmessage_;
  askkickdeniedmessage_ = nullptr;
  return temp;
}
inline ::AskKickDeniedMessage* PokerTHMessage::mutable_askkickdeniedmessage() {
  _has_bits_[1] |= 0x00800000u;
  if (askkickdeniedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AskKickDeniedMessage>(GetArenaNoVirtual());
    askkickdeniedmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.askKickDeniedMessage)
  return askkickdeniedmessage_;
}
inline void PokerTHMessage::set_allocated_askkickdeniedmessage(::AskKickDeniedMessage* askkickdeniedmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete askkickdeniedmessage_;
  }
  if (askkickdeniedmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      askkickdeniedmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, askkickdeniedmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x00800000u;
  } else {
    _has_bits_[1] &= ~0x00800000u;
  }
  askkickdeniedmessage_ = askkickdeniedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.askKickDeniedMessage)
}

// optional .StartKickPetitionMessage startKickPetitionMessage = 58;
inline bool PokerTHMessage::has_startkickpetitionmessage() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void PokerTHMessage::clear_startkickpetitionmessage() {
  if (startkickpetitionmessage_ != nullptr) startkickpetitionmessage_->Clear();
  _has_bits_[1] &= ~0x01000000u;
}
inline const ::StartKickPetitionMessage& PokerTHMessage::startkickpetitionmessage() const {
  const ::StartKickPetitionMessage* p = startkickpetitionmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.startKickPetitionMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::StartKickPetitionMessage*>(
      &::_StartKickPetitionMessage_default_instance_);
}
inline ::StartKickPetitionMessage* PokerTHMessage::release_startkickpetitionmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.startKickPetitionMessage)
  _has_bits_[1] &= ~0x01000000u;
  ::StartKickPetitionMessage* temp = startkickpetitionmessage_;
  startkickpetitionmessage_ = nullptr;
  return temp;
}
inline ::StartKickPetitionMessage* PokerTHMessage::mutable_startkickpetitionmessage() {
  _has_bits_[1] |= 0x01000000u;
  if (startkickpetitionmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::StartKickPetitionMessage>(GetArenaNoVirtual());
    startkickpetitionmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.startKickPetitionMessage)
  return startkickpetitionmessage_;
}
inline void PokerTHMessage::set_allocated_startkickpetitionmessage(::StartKickPetitionMessage* startkickpetitionmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete startkickpetitionmessage_;
  }
  if (startkickpetitionmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      startkickpetitionmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, startkickpetitionmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x01000000u;
  } else {
    _has_bits_[1] &= ~0x01000000u;
  }
  startkickpetitionmessage_ = startkickpetitionmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.startKickPetitionMessage)
}

// optional .VoteKickRequestMessage voteKickRequestMessage = 59;
inline bool PokerTHMessage::has_votekickrequestmessage() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void PokerTHMessage::clear_votekickrequestmessage() {
  if (votekickrequestmessage_ != nullptr) votekickrequestmessage_->Clear();
  _has_bits_[1] &= ~0x02000000u;
}
inline const ::VoteKickRequestMessage& PokerTHMessage::votekickrequestmessage() const {
  const ::VoteKickRequestMessage* p = votekickrequestmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.voteKickRequestMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::VoteKickRequestMessage*>(
      &::_VoteKickRequestMessage_default_instance_);
}
inline ::VoteKickRequestMessage* PokerTHMessage::release_votekickrequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.voteKickRequestMessage)
  _has_bits_[1] &= ~0x02000000u;
  ::VoteKickRequestMessage* temp = votekickrequestmessage_;
  votekickrequestmessage_ = nullptr;
  return temp;
}
inline ::VoteKickRequestMessage* PokerTHMessage::mutable_votekickrequestmessage() {
  _has_bits_[1] |= 0x02000000u;
  if (votekickrequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::VoteKickRequestMessage>(GetArenaNoVirtual());
    votekickrequestmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.voteKickRequestMessage)
  return votekickrequestmessage_;
}
inline void PokerTHMessage::set_allocated_votekickrequestmessage(::VoteKickRequestMessage* votekickrequestmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete votekickrequestmessage_;
  }
  if (votekickrequestmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      votekickrequestmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, votekickrequestmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x02000000u;
  } else {
    _has_bits_[1] &= ~0x02000000u;
  }
  votekickrequestmessage_ = votekickrequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.voteKickRequestMessage)
}

// optional .VoteKickReplyMessage voteKickReplyMessage = 60;
inline bool PokerTHMessage::has_votekickreplymessage() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void PokerTHMessage::clear_votekickreplymessage() {
  if (votekickreplymessage_ != nullptr) votekickreplymessage_->Clear();
  _has_bits_[1] &= ~0x04000000u;
}
inline const ::VoteKickReplyMessage& PokerTHMessage::votekickreplymessage() const {
  const ::VoteKickReplyMessage* p = votekickreplymessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.voteKickReplyMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::VoteKickReplyMessage*>(
      &::_VoteKickReplyMessage_default_instance_);
}
inline ::VoteKickReplyMessage* PokerTHMessage::release_votekickreplymessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.voteKickReplyMessage)
  _has_bits_[1] &= ~0x04000000u;
  ::VoteKickReplyMessage* temp = votekickreplymessage_;
  votekickreplymessage_ = nullptr;
  return temp;
}
inline ::VoteKickReplyMessage* PokerTHMessage::mutable_votekickreplymessage() {
  _has_bits_[1] |= 0x04000000u;
  if (votekickreplymessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::VoteKickReplyMessage>(GetArenaNoVirtual());
    votekickreplymessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.voteKickReplyMessage)
  return votekickreplymessage_;
}
inline void PokerTHMessage::set_allocated_votekickreplymessage(::VoteKickReplyMessage* votekickreplymessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete votekickreplymessage_;
  }
  if (votekickreplymessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      votekickreplymessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, votekickreplymessage, submessage_arena);
    }
    _has_bits_[1] |= 0x04000000u;
  } else {
    _has_bits_[1] &= ~0x04000000u;
  }
  votekickreplymessage_ = votekickreplymessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.voteKickReplyMessage)
}

// optional .KickPetitionUpdateMessage kickPetitionUpdateMessage = 61;
inline bool PokerTHMessage::has_kickpetitionupdatemessage() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void PokerTHMessage::clear_kickpetitionupdatemessage() {
  if (kickpetitionupdatemessage_ != nullptr) kickpetitionupdatemessage_->Clear();
  _has_bits_[1] &= ~0x08000000u;
}
inline const ::KickPetitionUpdateMessage& PokerTHMessage::kickpetitionupdatemessage() const {
  const ::KickPetitionUpdateMessage* p = kickpetitionupdatemessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.kickPetitionUpdateMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::KickPetitionUpdateMessage*>(
      &::_KickPetitionUpdateMessage_default_instance_);
}
inline ::KickPetitionUpdateMessage* PokerTHMessage::release_kickpetitionupdatemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.kickPetitionUpdateMessage)
  _has_bits_[1] &= ~0x08000000u;
  ::KickPetitionUpdateMessage* temp = kickpetitionupdatemessage_;
  kickpetitionupdatemessage_ = nullptr;
  return temp;
}
inline ::KickPetitionUpdateMessage* PokerTHMessage::mutable_kickpetitionupdatemessage() {
  _has_bits_[1] |= 0x08000000u;
  if (kickpetitionupdatemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::KickPetitionUpdateMessage>(GetArenaNoVirtual());
    kickpetitionupdatemessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.kickPetitionUpdateMessage)
  return kickpetitionupdatemessage_;
}
inline void PokerTHMessage::set_allocated_kickpetitionupdatemessage(::KickPetitionUpdateMessage* kickpetitionupdatemessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete kickpetitionupdatemessage_;
  }
  if (kickpetitionupdatemessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      kickpetitionupdatemessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kickpetitionupdatemessage, submessage_arena);
    }
    _has_bits_[1] |= 0x08000000u;
  } else {
    _has_bits_[1] &= ~0x08000000u;
  }
  kickpetitionupdatemessage_ = kickpetitionupdatemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.kickPetitionUpdateMessage)
}

// optional .EndKickPetitionMessage endKickPetitionMessage = 62;
inline bool PokerTHMessage::has_endkickpetitionmessage() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void PokerTHMessage::clear_endkickpetitionmessage() {
  if (endkickpetitionmessage_ != nullptr) endkickpetitionmessage_->Clear();
  _has_bits_[1] &= ~0x10000000u;
}
inline const ::EndKickPetitionMessage& PokerTHMessage::endkickpetitionmessage() const {
  const ::EndKickPetitionMessage* p = endkickpetitionmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.endKickPetitionMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::EndKickPetitionMessage*>(
      &::_EndKickPetitionMessage_default_instance_);
}
inline ::EndKickPetitionMessage* PokerTHMessage::release_endkickpetitionmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.endKickPetitionMessage)
  _has_bits_[1] &= ~0x10000000u;
  ::EndKickPetitionMessage* temp = endkickpetitionmessage_;
  endkickpetitionmessage_ = nullptr;
  return temp;
}
inline ::EndKickPetitionMessage* PokerTHMessage::mutable_endkickpetitionmessage() {
  _has_bits_[1] |= 0x10000000u;
  if (endkickpetitionmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::EndKickPetitionMessage>(GetArenaNoVirtual());
    endkickpetitionmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.endKickPetitionMessage)
  return endkickpetitionmessage_;
}
inline void PokerTHMessage::set_allocated_endkickpetitionmessage(::EndKickPetitionMessage* endkickpetitionmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete endkickpetitionmessage_;
  }
  if (endkickpetitionmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      endkickpetitionmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, endkickpetitionmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x10000000u;
  } else {
    _has_bits_[1] &= ~0x10000000u;
  }
  endkickpetitionmessage_ = endkickpetitionmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.endKickPetitionMessage)
}

// optional .StatisticsMessage statisticsMessage = 63;
inline bool PokerTHMessage::has_statisticsmessage() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void PokerTHMessage::clear_statisticsmessage() {
  if (statisticsmessage_ != nullptr) statisticsmessage_->Clear();
  _has_bits_[1] &= ~0x20000000u;
}
inline const ::StatisticsMessage& PokerTHMessage::statisticsmessage() const {
  const ::StatisticsMessage* p = statisticsmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.statisticsMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::StatisticsMessage*>(
      &::_StatisticsMessage_default_instance_);
}
inline ::StatisticsMessage* PokerTHMessage::release_statisticsmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.statisticsMessage)
  _has_bits_[1] &= ~0x20000000u;
  ::StatisticsMessage* temp = statisticsmessage_;
  statisticsmessage_ = nullptr;
  return temp;
}
inline ::StatisticsMessage* PokerTHMessage::mutable_statisticsmessage() {
  _has_bits_[1] |= 0x20000000u;
  if (statisticsmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::StatisticsMessage>(GetArenaNoVirtual());
    statisticsmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.statisticsMessage)
  return statisticsmessage_;
}
inline void PokerTHMessage::set_allocated_statisticsmessage(::StatisticsMessage* statisticsmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete statisticsmessage_;
  }
  if (statisticsmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      statisticsmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, statisticsmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x20000000u;
  } else {
    _has_bits_[1] &= ~0x20000000u;
  }
  statisticsmessage_ = statisticsmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.statisticsMessage)
}

// optional .ChatRequestMessage chatRequestMessage = 64;
inline bool PokerTHMessage::has_chatrequestmessage() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void PokerTHMessage::clear_chatrequestmessage() {
  if (chatrequestmessage_ != nullptr) chatrequestmessage_->Clear();
  _has_bits_[1] &= ~0x40000000u;
}
inline const ::ChatRequestMessage& PokerTHMessage::chatrequestmessage() const {
  const ::ChatRequestMessage* p = chatrequestmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.chatRequestMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::ChatRequestMessage*>(
      &::_ChatRequestMessage_default_instance_);
}
inline ::ChatRequestMessage* PokerTHMessage::release_chatrequestmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.chatRequestMessage)
  _has_bits_[1] &= ~0x40000000u;
  ::ChatRequestMessage* temp = chatrequestmessage_;
  chatrequestmessage_ = nullptr;
  return temp;
}
inline ::ChatRequestMessage* PokerTHMessage::mutable_chatrequestmessage() {
  _has_bits_[1] |= 0x40000000u;
  if (chatrequestmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChatRequestMessage>(GetArenaNoVirtual());
    chatrequestmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.chatRequestMessage)
  return chatrequestmessage_;
}
inline void PokerTHMessage::set_allocated_chatrequestmessage(::ChatRequestMessage* chatrequestmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete chatrequestmessage_;
  }
  if (chatrequestmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      chatrequestmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, chatrequestmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x40000000u;
  } else {
    _has_bits_[1] &= ~0x40000000u;
  }
  chatrequestmessage_ = chatrequestmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.chatRequestMessage)
}

// optional .ChatMessage chatMessage = 65;
inline bool PokerTHMessage::has_chatmessage() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void PokerTHMessage::clear_chatmessage() {
  if (chatmessage_ != nullptr) chatmessage_->Clear();
  _has_bits_[1] &= ~0x80000000u;
}
inline const ::ChatMessage& PokerTHMessage::chatmessage() const {
  const ::ChatMessage* p = chatmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.chatMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::ChatMessage*>(
      &::_ChatMessage_default_instance_);
}
inline ::ChatMessage* PokerTHMessage::release_chatmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.chatMessage)
  _has_bits_[1] &= ~0x80000000u;
  ::ChatMessage* temp = chatmessage_;
  chatmessage_ = nullptr;
  return temp;
}
inline ::ChatMessage* PokerTHMessage::mutable_chatmessage() {
  _has_bits_[1] |= 0x80000000u;
  if (chatmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChatMessage>(GetArenaNoVirtual());
    chatmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.chatMessage)
  return chatmessage_;
}
inline void PokerTHMessage::set_allocated_chatmessage(::ChatMessage* chatmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete chatmessage_;
  }
  if (chatmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      chatmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, chatmessage, submessage_arena);
    }
    _has_bits_[1] |= 0x80000000u;
  } else {
    _has_bits_[1] &= ~0x80000000u;
  }
  chatmessage_ = chatmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.chatMessage)
}

// optional .ChatRejectMessage chatRejectMessage = 66;
inline bool PokerTHMessage::has_chatrejectmessage() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void PokerTHMessage::clear_chatrejectmessage() {
  if (chatrejectmessage_ != nullptr) chatrejectmessage_->Clear();
  _has_bits_[2] &= ~0x00000001u;
}
inline const ::ChatRejectMessage& PokerTHMessage::chatrejectmessage() const {
  const ::ChatRejectMessage* p = chatrejectmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.chatRejectMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::ChatRejectMessage*>(
      &::_ChatRejectMessage_default_instance_);
}
inline ::ChatRejectMessage* PokerTHMessage::release_chatrejectmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.chatRejectMessage)
  _has_bits_[2] &= ~0x00000001u;
  ::ChatRejectMessage* temp = chatrejectmessage_;
  chatrejectmessage_ = nullptr;
  return temp;
}
inline ::ChatRejectMessage* PokerTHMessage::mutable_chatrejectmessage() {
  _has_bits_[2] |= 0x00000001u;
  if (chatrejectmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChatRejectMessage>(GetArenaNoVirtual());
    chatrejectmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.chatRejectMessage)
  return chatrejectmessage_;
}
inline void PokerTHMessage::set_allocated_chatrejectmessage(::ChatRejectMessage* chatrejectmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete chatrejectmessage_;
  }
  if (chatrejectmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      chatrejectmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, chatrejectmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000001u;
  } else {
    _has_bits_[2] &= ~0x00000001u;
  }
  chatrejectmessage_ = chatrejectmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.chatRejectMessage)
}

// optional .DialogMessage dialogMessage = 67;
inline bool PokerTHMessage::has_dialogmessage() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void PokerTHMessage::clear_dialogmessage() {
  if (dialogmessage_ != nullptr) dialogmessage_->Clear();
  _has_bits_[2] &= ~0x00000002u;
}
inline const ::DialogMessage& PokerTHMessage::dialogmessage() const {
  const ::DialogMessage* p = dialogmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.dialogMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::DialogMessage*>(
      &::_DialogMessage_default_instance_);
}
inline ::DialogMessage* PokerTHMessage::release_dialogmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.dialogMessage)
  _has_bits_[2] &= ~0x00000002u;
  ::DialogMessage* temp = dialogmessage_;
  dialogmessage_ = nullptr;
  return temp;
}
inline ::DialogMessage* PokerTHMessage::mutable_dialogmessage() {
  _has_bits_[2] |= 0x00000002u;
  if (dialogmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::DialogMessage>(GetArenaNoVirtual());
    dialogmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.dialogMessage)
  return dialogmessage_;
}
inline void PokerTHMessage::set_allocated_dialogmessage(::DialogMessage* dialogmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dialogmessage_;
  }
  if (dialogmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dialogmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dialogmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000002u;
  } else {
    _has_bits_[2] &= ~0x00000002u;
  }
  dialogmessage_ = dialogmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.dialogMessage)
}

// optional .TimeoutWarningMessage timeoutWarningMessage = 68;
inline bool PokerTHMessage::has_timeoutwarningmessage() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void PokerTHMessage::clear_timeoutwarningmessage() {
  if (timeoutwarningmessage_ != nullptr) timeoutwarningmessage_->Clear();
  _has_bits_[2] &= ~0x00000004u;
}
inline const ::TimeoutWarningMessage& PokerTHMessage::timeoutwarningmessage() const {
  const ::TimeoutWarningMessage* p = timeoutwarningmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.timeoutWarningMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::TimeoutWarningMessage*>(
      &::_TimeoutWarningMessage_default_instance_);
}
inline ::TimeoutWarningMessage* PokerTHMessage::release_timeoutwarningmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.timeoutWarningMessage)
  _has_bits_[2] &= ~0x00000004u;
  ::TimeoutWarningMessage* temp = timeoutwarningmessage_;
  timeoutwarningmessage_ = nullptr;
  return temp;
}
inline ::TimeoutWarningMessage* PokerTHMessage::mutable_timeoutwarningmessage() {
  _has_bits_[2] |= 0x00000004u;
  if (timeoutwarningmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TimeoutWarningMessage>(GetArenaNoVirtual());
    timeoutwarningmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.timeoutWarningMessage)
  return timeoutwarningmessage_;
}
inline void PokerTHMessage::set_allocated_timeoutwarningmessage(::TimeoutWarningMessage* timeoutwarningmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete timeoutwarningmessage_;
  }
  if (timeoutwarningmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      timeoutwarningmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timeoutwarningmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000004u;
  } else {
    _has_bits_[2] &= ~0x00000004u;
  }
  timeoutwarningmessage_ = timeoutwarningmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.timeoutWarningMessage)
}

// optional .ResetTimeoutMessage resetTimeoutMessage = 69;
inline bool PokerTHMessage::has_resettimeoutmessage() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void PokerTHMessage::clear_resettimeoutmessage() {
  if (resettimeoutmessage_ != nullptr) resettimeoutmessage_->Clear();
  _has_bits_[2] &= ~0x00000008u;
}
inline const ::ResetTimeoutMessage& PokerTHMessage::resettimeoutmessage() const {
  const ::ResetTimeoutMessage* p = resettimeoutmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.resetTimeoutMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::ResetTimeoutMessage*>(
      &::_ResetTimeoutMessage_default_instance_);
}
inline ::ResetTimeoutMessage* PokerTHMessage::release_resettimeoutmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.resetTimeoutMessage)
  _has_bits_[2] &= ~0x00000008u;
  ::ResetTimeoutMessage* temp = resettimeoutmessage_;
  resettimeoutmessage_ = nullptr;
  return temp;
}
inline ::ResetTimeoutMessage* PokerTHMessage::mutable_resettimeoutmessage() {
  _has_bits_[2] |= 0x00000008u;
  if (resettimeoutmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ResetTimeoutMessage>(GetArenaNoVirtual());
    resettimeoutmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.resetTimeoutMessage)
  return resettimeoutmessage_;
}
inline void PokerTHMessage::set_allocated_resettimeoutmessage(::ResetTimeoutMessage* resettimeoutmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete resettimeoutmessage_;
  }
  if (resettimeoutmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      resettimeoutmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resettimeoutmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000008u;
  } else {
    _has_bits_[2] &= ~0x00000008u;
  }
  resettimeoutmessage_ = resettimeoutmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.resetTimeoutMessage)
}

// optional .ReportAvatarMessage reportAvatarMessage = 70;
inline bool PokerTHMessage::has_reportavatarmessage() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void PokerTHMessage::clear_reportavatarmessage() {
  if (reportavatarmessage_ != nullptr) reportavatarmessage_->Clear();
  _has_bits_[2] &= ~0x00000010u;
}
inline const ::ReportAvatarMessage& PokerTHMessage::reportavatarmessage() const {
  const ::ReportAvatarMessage* p = reportavatarmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.reportAvatarMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::ReportAvatarMessage*>(
      &::_ReportAvatarMessage_default_instance_);
}
inline ::ReportAvatarMessage* PokerTHMessage::release_reportavatarmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.reportAvatarMessage)
  _has_bits_[2] &= ~0x00000010u;
  ::ReportAvatarMessage* temp = reportavatarmessage_;
  reportavatarmessage_ = nullptr;
  return temp;
}
inline ::ReportAvatarMessage* PokerTHMessage::mutable_reportavatarmessage() {
  _has_bits_[2] |= 0x00000010u;
  if (reportavatarmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ReportAvatarMessage>(GetArenaNoVirtual());
    reportavatarmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.reportAvatarMessage)
  return reportavatarmessage_;
}
inline void PokerTHMessage::set_allocated_reportavatarmessage(::ReportAvatarMessage* reportavatarmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reportavatarmessage_;
  }
  if (reportavatarmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reportavatarmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reportavatarmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000010u;
  } else {
    _has_bits_[2] &= ~0x00000010u;
  }
  reportavatarmessage_ = reportavatarmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.reportAvatarMessage)
}

// optional .ReportAvatarAckMessage reportAvatarAckMessage = 71;
inline bool PokerTHMessage::has_reportavatarackmessage() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void PokerTHMessage::clear_reportavatarackmessage() {
  if (reportavatarackmessage_ != nullptr) reportavatarackmessage_->Clear();
  _has_bits_[2] &= ~0x00000020u;
}
inline const ::ReportAvatarAckMessage& PokerTHMessage::reportavatarackmessage() const {
  const ::ReportAvatarAckMessage* p = reportavatarackmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.reportAvatarAckMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::ReportAvatarAckMessage*>(
      &::_ReportAvatarAckMessage_default_instance_);
}
inline ::ReportAvatarAckMessage* PokerTHMessage::release_reportavatarackmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.reportAvatarAckMessage)
  _has_bits_[2] &= ~0x00000020u;
  ::ReportAvatarAckMessage* temp = reportavatarackmessage_;
  reportavatarackmessage_ = nullptr;
  return temp;
}
inline ::ReportAvatarAckMessage* PokerTHMessage::mutable_reportavatarackmessage() {
  _has_bits_[2] |= 0x00000020u;
  if (reportavatarackmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ReportAvatarAckMessage>(GetArenaNoVirtual());
    reportavatarackmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.reportAvatarAckMessage)
  return reportavatarackmessage_;
}
inline void PokerTHMessage::set_allocated_reportavatarackmessage(::ReportAvatarAckMessage* reportavatarackmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reportavatarackmessage_;
  }
  if (reportavatarackmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reportavatarackmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reportavatarackmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000020u;
  } else {
    _has_bits_[2] &= ~0x00000020u;
  }
  reportavatarackmessage_ = reportavatarackmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.reportAvatarAckMessage)
}

// optional .ReportGameMessage reportGameMessage = 72;
inline bool PokerTHMessage::has_reportgamemessage() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void PokerTHMessage::clear_reportgamemessage() {
  if (reportgamemessage_ != nullptr) reportgamemessage_->Clear();
  _has_bits_[2] &= ~0x00000040u;
}
inline const ::ReportGameMessage& PokerTHMessage::reportgamemessage() const {
  const ::ReportGameMessage* p = reportgamemessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.reportGameMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::ReportGameMessage*>(
      &::_ReportGameMessage_default_instance_);
}
inline ::ReportGameMessage* PokerTHMessage::release_reportgamemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.reportGameMessage)
  _has_bits_[2] &= ~0x00000040u;
  ::ReportGameMessage* temp = reportgamemessage_;
  reportgamemessage_ = nullptr;
  return temp;
}
inline ::ReportGameMessage* PokerTHMessage::mutable_reportgamemessage() {
  _has_bits_[2] |= 0x00000040u;
  if (reportgamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ReportGameMessage>(GetArenaNoVirtual());
    reportgamemessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.reportGameMessage)
  return reportgamemessage_;
}
inline void PokerTHMessage::set_allocated_reportgamemessage(::ReportGameMessage* reportgamemessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reportgamemessage_;
  }
  if (reportgamemessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reportgamemessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reportgamemessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000040u;
  } else {
    _has_bits_[2] &= ~0x00000040u;
  }
  reportgamemessage_ = reportgamemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.reportGameMessage)
}

// optional .ReportGameAckMessage reportGameAckMessage = 73;
inline bool PokerTHMessage::has_reportgameackmessage() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void PokerTHMessage::clear_reportgameackmessage() {
  if (reportgameackmessage_ != nullptr) reportgameackmessage_->Clear();
  _has_bits_[2] &= ~0x00000080u;
}
inline const ::ReportGameAckMessage& PokerTHMessage::reportgameackmessage() const {
  const ::ReportGameAckMessage* p = reportgameackmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.reportGameAckMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::ReportGameAckMessage*>(
      &::_ReportGameAckMessage_default_instance_);
}
inline ::ReportGameAckMessage* PokerTHMessage::release_reportgameackmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.reportGameAckMessage)
  _has_bits_[2] &= ~0x00000080u;
  ::ReportGameAckMessage* temp = reportgameackmessage_;
  reportgameackmessage_ = nullptr;
  return temp;
}
inline ::ReportGameAckMessage* PokerTHMessage::mutable_reportgameackmessage() {
  _has_bits_[2] |= 0x00000080u;
  if (reportgameackmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ReportGameAckMessage>(GetArenaNoVirtual());
    reportgameackmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.reportGameAckMessage)
  return reportgameackmessage_;
}
inline void PokerTHMessage::set_allocated_reportgameackmessage(::ReportGameAckMessage* reportgameackmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reportgameackmessage_;
  }
  if (reportgameackmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reportgameackmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reportgameackmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000080u;
  } else {
    _has_bits_[2] &= ~0x00000080u;
  }
  reportgameackmessage_ = reportgameackmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.reportGameAckMessage)
}

// optional .ErrorMessage errorMessage = 74;
inline bool PokerTHMessage::has_errormessage() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void PokerTHMessage::clear_errormessage() {
  if (errormessage_ != nullptr) errormessage_->Clear();
  _has_bits_[2] &= ~0x00000100u;
}
inline const ::ErrorMessage& PokerTHMessage::errormessage() const {
  const ::ErrorMessage* p = errormessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.errorMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::ErrorMessage*>(
      &::_ErrorMessage_default_instance_);
}
inline ::ErrorMessage* PokerTHMessage::release_errormessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.errorMessage)
  _has_bits_[2] &= ~0x00000100u;
  ::ErrorMessage* temp = errormessage_;
  errormessage_ = nullptr;
  return temp;
}
inline ::ErrorMessage* PokerTHMessage::mutable_errormessage() {
  _has_bits_[2] |= 0x00000100u;
  if (errormessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::ErrorMessage>(GetArenaNoVirtual());
    errormessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.errorMessage)
  return errormessage_;
}
inline void PokerTHMessage::set_allocated_errormessage(::ErrorMessage* errormessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete errormessage_;
  }
  if (errormessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      errormessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, errormessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000100u;
  } else {
    _has_bits_[2] &= ~0x00000100u;
  }
  errormessage_ = errormessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.errorMessage)
}

// optional .AdminRemoveGameMessage adminRemoveGameMessage = 75;
inline bool PokerTHMessage::has_adminremovegamemessage() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void PokerTHMessage::clear_adminremovegamemessage() {
  if (adminremovegamemessage_ != nullptr) adminremovegamemessage_->Clear();
  _has_bits_[2] &= ~0x00000200u;
}
inline const ::AdminRemoveGameMessage& PokerTHMessage::adminremovegamemessage() const {
  const ::AdminRemoveGameMessage* p = adminremovegamemessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.adminRemoveGameMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::AdminRemoveGameMessage*>(
      &::_AdminRemoveGameMessage_default_instance_);
}
inline ::AdminRemoveGameMessage* PokerTHMessage::release_adminremovegamemessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.adminRemoveGameMessage)
  _has_bits_[2] &= ~0x00000200u;
  ::AdminRemoveGameMessage* temp = adminremovegamemessage_;
  adminremovegamemessage_ = nullptr;
  return temp;
}
inline ::AdminRemoveGameMessage* PokerTHMessage::mutable_adminremovegamemessage() {
  _has_bits_[2] |= 0x00000200u;
  if (adminremovegamemessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AdminRemoveGameMessage>(GetArenaNoVirtual());
    adminremovegamemessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.adminRemoveGameMessage)
  return adminremovegamemessage_;
}
inline void PokerTHMessage::set_allocated_adminremovegamemessage(::AdminRemoveGameMessage* adminremovegamemessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete adminremovegamemessage_;
  }
  if (adminremovegamemessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      adminremovegamemessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, adminremovegamemessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000200u;
  } else {
    _has_bits_[2] &= ~0x00000200u;
  }
  adminremovegamemessage_ = adminremovegamemessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.adminRemoveGameMessage)
}

// optional .AdminRemoveGameAckMessage adminRemoveGameAckMessage = 76;
inline bool PokerTHMessage::has_adminremovegameackmessage() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void PokerTHMessage::clear_adminremovegameackmessage() {
  if (adminremovegameackmessage_ != nullptr) adminremovegameackmessage_->Clear();
  _has_bits_[2] &= ~0x00000400u;
}
inline const ::AdminRemoveGameAckMessage& PokerTHMessage::adminremovegameackmessage() const {
  const ::AdminRemoveGameAckMessage* p = adminremovegameackmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.adminRemoveGameAckMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::AdminRemoveGameAckMessage*>(
      &::_AdminRemoveGameAckMessage_default_instance_);
}
inline ::AdminRemoveGameAckMessage* PokerTHMessage::release_adminremovegameackmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.adminRemoveGameAckMessage)
  _has_bits_[2] &= ~0x00000400u;
  ::AdminRemoveGameAckMessage* temp = adminremovegameackmessage_;
  adminremovegameackmessage_ = nullptr;
  return temp;
}
inline ::AdminRemoveGameAckMessage* PokerTHMessage::mutable_adminremovegameackmessage() {
  _has_bits_[2] |= 0x00000400u;
  if (adminremovegameackmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AdminRemoveGameAckMessage>(GetArenaNoVirtual());
    adminremovegameackmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.adminRemoveGameAckMessage)
  return adminremovegameackmessage_;
}
inline void PokerTHMessage::set_allocated_adminremovegameackmessage(::AdminRemoveGameAckMessage* adminremovegameackmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete adminremovegameackmessage_;
  }
  if (adminremovegameackmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      adminremovegameackmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, adminremovegameackmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000400u;
  } else {
    _has_bits_[2] &= ~0x00000400u;
  }
  adminremovegameackmessage_ = adminremovegameackmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.adminRemoveGameAckMessage)
}

// optional .AdminBanPlayerMessage adminBanPlayerMessage = 77;
inline bool PokerTHMessage::has_adminbanplayermessage() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void PokerTHMessage::clear_adminbanplayermessage() {
  if (adminbanplayermessage_ != nullptr) adminbanplayermessage_->Clear();
  _has_bits_[2] &= ~0x00000800u;
}
inline const ::AdminBanPlayerMessage& PokerTHMessage::adminbanplayermessage() const {
  const ::AdminBanPlayerMessage* p = adminbanplayermessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.adminBanPlayerMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::AdminBanPlayerMessage*>(
      &::_AdminBanPlayerMessage_default_instance_);
}
inline ::AdminBanPlayerMessage* PokerTHMessage::release_adminbanplayermessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.adminBanPlayerMessage)
  _has_bits_[2] &= ~0x00000800u;
  ::AdminBanPlayerMessage* temp = adminbanplayermessage_;
  adminbanplayermessage_ = nullptr;
  return temp;
}
inline ::AdminBanPlayerMessage* PokerTHMessage::mutable_adminbanplayermessage() {
  _has_bits_[2] |= 0x00000800u;
  if (adminbanplayermessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AdminBanPlayerMessage>(GetArenaNoVirtual());
    adminbanplayermessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.adminBanPlayerMessage)
  return adminbanplayermessage_;
}
inline void PokerTHMessage::set_allocated_adminbanplayermessage(::AdminBanPlayerMessage* adminbanplayermessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete adminbanplayermessage_;
  }
  if (adminbanplayermessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      adminbanplayermessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, adminbanplayermessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00000800u;
  } else {
    _has_bits_[2] &= ~0x00000800u;
  }
  adminbanplayermessage_ = adminbanplayermessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.adminBanPlayerMessage)
}

// optional .AdminBanPlayerAckMessage adminBanPlayerAckMessage = 78;
inline bool PokerTHMessage::has_adminbanplayerackmessage() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void PokerTHMessage::clear_adminbanplayerackmessage() {
  if (adminbanplayerackmessage_ != nullptr) adminbanplayerackmessage_->Clear();
  _has_bits_[2] &= ~0x00001000u;
}
inline const ::AdminBanPlayerAckMessage& PokerTHMessage::adminbanplayerackmessage() const {
  const ::AdminBanPlayerAckMessage* p = adminbanplayerackmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.adminBanPlayerAckMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::AdminBanPlayerAckMessage*>(
      &::_AdminBanPlayerAckMessage_default_instance_);
}
inline ::AdminBanPlayerAckMessage* PokerTHMessage::release_adminbanplayerackmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.adminBanPlayerAckMessage)
  _has_bits_[2] &= ~0x00001000u;
  ::AdminBanPlayerAckMessage* temp = adminbanplayerackmessage_;
  adminbanplayerackmessage_ = nullptr;
  return temp;
}
inline ::AdminBanPlayerAckMessage* PokerTHMessage::mutable_adminbanplayerackmessage() {
  _has_bits_[2] |= 0x00001000u;
  if (adminbanplayerackmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::AdminBanPlayerAckMessage>(GetArenaNoVirtual());
    adminbanplayerackmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.adminBanPlayerAckMessage)
  return adminbanplayerackmessage_;
}
inline void PokerTHMessage::set_allocated_adminbanplayerackmessage(::AdminBanPlayerAckMessage* adminbanplayerackmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete adminbanplayerackmessage_;
  }
  if (adminbanplayerackmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      adminbanplayerackmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, adminbanplayerackmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00001000u;
  } else {
    _has_bits_[2] &= ~0x00001000u;
  }
  adminbanplayerackmessage_ = adminbanplayerackmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.adminBanPlayerAckMessage)
}

// optional .GameListSpectatorJoinedMessage gameListSpectatorJoinedMessage = 79;
inline bool PokerTHMessage::has_gamelistspectatorjoinedmessage() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void PokerTHMessage::clear_gamelistspectatorjoinedmessage() {
  if (gamelistspectatorjoinedmessage_ != nullptr) gamelistspectatorjoinedmessage_->Clear();
  _has_bits_[2] &= ~0x00002000u;
}
inline const ::GameListSpectatorJoinedMessage& PokerTHMessage::gamelistspectatorjoinedmessage() const {
  const ::GameListSpectatorJoinedMessage* p = gamelistspectatorjoinedmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListSpectatorJoinedMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::GameListSpectatorJoinedMessage*>(
      &::_GameListSpectatorJoinedMessage_default_instance_);
}
inline ::GameListSpectatorJoinedMessage* PokerTHMessage::release_gamelistspectatorjoinedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameListSpectatorJoinedMessage)
  _has_bits_[2] &= ~0x00002000u;
  ::GameListSpectatorJoinedMessage* temp = gamelistspectatorjoinedmessage_;
  gamelistspectatorjoinedmessage_ = nullptr;
  return temp;
}
inline ::GameListSpectatorJoinedMessage* PokerTHMessage::mutable_gamelistspectatorjoinedmessage() {
  _has_bits_[2] |= 0x00002000u;
  if (gamelistspectatorjoinedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameListSpectatorJoinedMessage>(GetArenaNoVirtual());
    gamelistspectatorjoinedmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListSpectatorJoinedMessage)
  return gamelistspectatorjoinedmessage_;
}
inline void PokerTHMessage::set_allocated_gamelistspectatorjoinedmessage(::GameListSpectatorJoinedMessage* gamelistspectatorjoinedmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gamelistspectatorjoinedmessage_;
  }
  if (gamelistspectatorjoinedmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gamelistspectatorjoinedmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gamelistspectatorjoinedmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00002000u;
  } else {
    _has_bits_[2] &= ~0x00002000u;
  }
  gamelistspectatorjoinedmessage_ = gamelistspectatorjoinedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListSpectatorJoinedMessage)
}

// optional .GameListSpectatorLeftMessage gameListSpectatorLeftMessage = 80;
inline bool PokerTHMessage::has_gamelistspectatorleftmessage() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void PokerTHMessage::clear_gamelistspectatorleftmessage() {
  if (gamelistspectatorleftmessage_ != nullptr) gamelistspectatorleftmessage_->Clear();
  _has_bits_[2] &= ~0x00004000u;
}
inline const ::GameListSpectatorLeftMessage& PokerTHMessage::gamelistspectatorleftmessage() const {
  const ::GameListSpectatorLeftMessage* p = gamelistspectatorleftmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameListSpectatorLeftMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::GameListSpectatorLeftMessage*>(
      &::_GameListSpectatorLeftMessage_default_instance_);
}
inline ::GameListSpectatorLeftMessage* PokerTHMessage::release_gamelistspectatorleftmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameListSpectatorLeftMessage)
  _has_bits_[2] &= ~0x00004000u;
  ::GameListSpectatorLeftMessage* temp = gamelistspectatorleftmessage_;
  gamelistspectatorleftmessage_ = nullptr;
  return temp;
}
inline ::GameListSpectatorLeftMessage* PokerTHMessage::mutable_gamelistspectatorleftmessage() {
  _has_bits_[2] |= 0x00004000u;
  if (gamelistspectatorleftmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameListSpectatorLeftMessage>(GetArenaNoVirtual());
    gamelistspectatorleftmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameListSpectatorLeftMessage)
  return gamelistspectatorleftmessage_;
}
inline void PokerTHMessage::set_allocated_gamelistspectatorleftmessage(::GameListSpectatorLeftMessage* gamelistspectatorleftmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gamelistspectatorleftmessage_;
  }
  if (gamelistspectatorleftmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gamelistspectatorleftmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gamelistspectatorleftmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00004000u;
  } else {
    _has_bits_[2] &= ~0x00004000u;
  }
  gamelistspectatorleftmessage_ = gamelistspectatorleftmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameListSpectatorLeftMessage)
}

// optional .GameSpectatorJoinedMessage gameSpectatorJoinedMessage = 81;
inline bool PokerTHMessage::has_gamespectatorjoinedmessage() const {
  return (_has_bits_[2] & 0x00008000u) != 0;
}
inline void PokerTHMessage::clear_gamespectatorjoinedmessage() {
  if (gamespectatorjoinedmessage_ != nullptr) gamespectatorjoinedmessage_->Clear();
  _has_bits_[2] &= ~0x00008000u;
}
inline const ::GameSpectatorJoinedMessage& PokerTHMessage::gamespectatorjoinedmessage() const {
  const ::GameSpectatorJoinedMessage* p = gamespectatorjoinedmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameSpectatorJoinedMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::GameSpectatorJoinedMessage*>(
      &::_GameSpectatorJoinedMessage_default_instance_);
}
inline ::GameSpectatorJoinedMessage* PokerTHMessage::release_gamespectatorjoinedmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameSpectatorJoinedMessage)
  _has_bits_[2] &= ~0x00008000u;
  ::GameSpectatorJoinedMessage* temp = gamespectatorjoinedmessage_;
  gamespectatorjoinedmessage_ = nullptr;
  return temp;
}
inline ::GameSpectatorJoinedMessage* PokerTHMessage::mutable_gamespectatorjoinedmessage() {
  _has_bits_[2] |= 0x00008000u;
  if (gamespectatorjoinedmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameSpectatorJoinedMessage>(GetArenaNoVirtual());
    gamespectatorjoinedmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameSpectatorJoinedMessage)
  return gamespectatorjoinedmessage_;
}
inline void PokerTHMessage::set_allocated_gamespectatorjoinedmessage(::GameSpectatorJoinedMessage* gamespectatorjoinedmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gamespectatorjoinedmessage_;
  }
  if (gamespectatorjoinedmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gamespectatorjoinedmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gamespectatorjoinedmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00008000u;
  } else {
    _has_bits_[2] &= ~0x00008000u;
  }
  gamespectatorjoinedmessage_ = gamespectatorjoinedmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameSpectatorJoinedMessage)
}

// optional .GameSpectatorLeftMessage gameSpectatorLeftMessage = 82;
inline bool PokerTHMessage::has_gamespectatorleftmessage() const {
  return (_has_bits_[2] & 0x00010000u) != 0;
}
inline void PokerTHMessage::clear_gamespectatorleftmessage() {
  if (gamespectatorleftmessage_ != nullptr) gamespectatorleftmessage_->Clear();
  _has_bits_[2] &= ~0x00010000u;
}
inline const ::GameSpectatorLeftMessage& PokerTHMessage::gamespectatorleftmessage() const {
  const ::GameSpectatorLeftMessage* p = gamespectatorleftmessage_;
  // @@protoc_insertion_point(field_get:PokerTHMessage.gameSpectatorLeftMessage)
  return p != nullptr ? *p : *reinterpret_cast<const ::GameSpectatorLeftMessage*>(
      &::_GameSpectatorLeftMessage_default_instance_);
}
inline ::GameSpectatorLeftMessage* PokerTHMessage::release_gamespectatorleftmessage() {
  // @@protoc_insertion_point(field_release:PokerTHMessage.gameSpectatorLeftMessage)
  _has_bits_[2] &= ~0x00010000u;
  ::GameSpectatorLeftMessage* temp = gamespectatorleftmessage_;
  gamespectatorleftmessage_ = nullptr;
  return temp;
}
inline ::GameSpectatorLeftMessage* PokerTHMessage::mutable_gamespectatorleftmessage() {
  _has_bits_[2] |= 0x00010000u;
  if (gamespectatorleftmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameSpectatorLeftMessage>(GetArenaNoVirtual());
    gamespectatorleftmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerTHMessage.gameSpectatorLeftMessage)
  return gamespectatorleftmessage_;
}
inline void PokerTHMessage::set_allocated_gamespectatorleftmessage(::GameSpectatorLeftMessage* gamespectatorleftmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gamespectatorleftmessage_;
  }
  if (gamespectatorleftmessage) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gamespectatorleftmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gamespectatorleftmessage, submessage_arena);
    }
    _has_bits_[2] |= 0x00010000u;
  } else {
    _has_bits_[2] &= ~0x00010000u;
  }
  gamespectatorleftmessage_ = gamespectatorleftmessage;
  // @@protoc_insertion_point(field_set_allocated:PokerTHMessage.gameSpectatorLeftMessage)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::NetGameInfo_NetGameType> : ::std::true_type {};
template <> struct is_proto_enum< ::NetGameInfo_RaiseIntervalMode> : ::std::true_type {};
template <> struct is_proto_enum< ::NetGameInfo_EndRaiseMode> : ::std::true_type {};
template <> struct is_proto_enum< ::AnnounceMessage_ServerType> : ::std::true_type {};
template <> struct is_proto_enum< ::InitMessage_LoginType> : ::std::true_type {};
template <> struct is_proto_enum< ::PlayerListMessage_PlayerListNotification> : ::std::true_type {};
template <> struct is_proto_enum< ::SubscriptionRequestMessage_SubscriptionAction> : ::std::true_type {};
template <> struct is_proto_enum< ::JoinGameFailedMessage_JoinGameFailureReason> : ::std::true_type {};
template <> struct is_proto_enum< ::GamePlayerLeftMessage_GamePlayerLeftReason> : ::std::true_type {};
template <> struct is_proto_enum< ::RemovedFromGameMessage_RemovedFromGameReason> : ::std::true_type {};
template <> struct is_proto_enum< ::RejectGameInvitationMessage_RejectGameInvReason> : ::std::true_type {};
template <> struct is_proto_enum< ::StartEventMessage_StartEventType> : ::std::true_type {};
template <> struct is_proto_enum< ::YourActionRejectedMessage_RejectionReason> : ::std::true_type {};
template <> struct is_proto_enum< ::AskKickDeniedMessage_KickDeniedReason> : ::std::true_type {};
template <> struct is_proto_enum< ::VoteKickReplyMessage_VoteKickReplyType> : ::std::true_type {};
template <> struct is_proto_enum< ::EndKickPetitionMessage_PetitionEndReason> : ::std::true_type {};
template <> struct is_proto_enum< ::StatisticsMessage_StatisticsData_StatisticsType> : ::std::true_type {};
template <> struct is_proto_enum< ::ChatMessage_ChatType> : ::std::true_type {};
template <> struct is_proto_enum< ::TimeoutWarningMessage_TimeoutReason> : ::std::true_type {};
template <> struct is_proto_enum< ::ReportAvatarAckMessage_ReportAvatarResult> : ::std::true_type {};
template <> struct is_proto_enum< ::ReportGameAckMessage_ReportGameResult> : ::std::true_type {};
template <> struct is_proto_enum< ::ErrorMessage_ErrorReason> : ::std::true_type {};
template <> struct is_proto_enum< ::AdminRemoveGameAckMessage_AdminRemoveGameResult> : ::std::true_type {};
template <> struct is_proto_enum< ::AdminBanPlayerAckMessage_AdminBanPlayerResult> : ::std::true_type {};
template <> struct is_proto_enum< ::PokerTHMessage_PokerTHMessageType> : ::std::true_type {};
template <> struct is_proto_enum< ::NetGameMode> : ::std::true_type {};
template <> struct is_proto_enum< ::NetGameState> : ::std::true_type {};
template <> struct is_proto_enum< ::NetPlayerAction> : ::std::true_type {};
template <> struct is_proto_enum< ::NetPlayerState> : ::std::true_type {};
template <> struct is_proto_enum< ::NetPlayerInfoRights> : ::std::true_type {};
template <> struct is_proto_enum< ::NetAvatarType> : ::std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_pokerth_2eproto
